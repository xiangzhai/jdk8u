diff -r 555c45b3456e src/cpu/x86/vm/c1_Defs_x86.hpp
--- a/src/cpu/x86/vm/c1_Defs_x86.hpp	Sat Mar 24 11:03:39 2018 +0800
+++ b/src/cpu/x86/vm/c1_Defs_x86.hpp	Sat Mar 24 11:04:51 2018 +0800
@@ -59,6 +59,9 @@
   pd_nof_cpu_regs_linearscan = pd_nof_cpu_regs_frame_map, // number of registers visible to linear scan
   pd_nof_fpu_regs_linearscan = pd_nof_fpu_regs_frame_map, // number of registers visible to linear scan
   pd_nof_xmm_regs_linearscan = pd_nof_xmm_regs_frame_map, // number of registers visible to linear scan
+  pd_nof_cpu_regs_greedy = pd_nof_cpu_regs_frame_map,
+  pd_nof_fpu_regs_greedy = pd_nof_fpu_regs_frame_map,
+  pd_nof_xmm_regs_greedy = pd_nof_xmm_regs_frame_map,
   pd_first_cpu_reg = 0,
   pd_last_cpu_reg = NOT_LP64(5) LP64_ONLY(11),
   pd_first_byte_reg = NOT_LP64(2) LP64_ONLY(0),
diff -r 555c45b3456e src/cpu/x86/vm/c1_Greedy_x86.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/x86/vm/c1_Greedy_x86.cpp	Sat Mar 24 11:04:51 2018 +0800
@@ -0,0 +1,1242 @@
+/*
+ * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "c1/c1_Instruction.hpp"
+#include "c1/c1_Greedy.hpp"
+#include "utilities/bitMap.inline.hpp"
+
+
+//----------------------------------------------------------------------
+// Allocation of FPU stack slots (Intel x86 only)
+//----------------------------------------------------------------------
+
+void Greedy::allocate_fpu_stack() {
+  // First compute which FPU registers are live at the start of each basic block
+  // (To minimize the amount of work we have to do if we have to merge FPU stacks)
+  if (ComputeExactFPURegisterUsage) {
+    GreedyInterval* intervals_in_register, *intervals_in_memory;
+    create_unhandled_lists(&intervals_in_register, &intervals_in_memory, is_in_fpu_register, NULL);
+
+    // ignore memory intervals by overwriting intervals_in_memory
+    // the dummy interval is needed to enforce the walker to walk until the given id:
+    // without it, the walker stops when the unhandled-list is empty -> live information
+    // beyond this point would be incorrect.
+    GreedyInterval* dummy_interval = new GreedyInterval(any_reg);
+    dummy_interval->add_range(max_jint - 2, max_jint - 1);
+    dummy_interval->set_next(GreedyInterval::end());
+    intervals_in_memory = dummy_interval;
+
+    GreedyIntervalWalker iw(this, intervals_in_register, intervals_in_memory);
+
+    const int num_blocks = block_count();
+    for (int i = 0; i < num_blocks; i++) {
+      BlockBegin* b = block_at(i);
+
+      // register usage is only needed for merging stacks -> compute only
+      // when more than one predecessor.
+      // the block must not have any spill moves at the beginning (checked by assertions)
+      // spill moves would use intervals that are marked as handled and so the usage bit
+      // would been set incorrectly
+
+      // NOTE: the check for number_of_preds > 1 is necessary. A block with only one
+      //       predecessor may have spill moves at the begin of the block.
+      //       If an interval ends at the current instruction id, it is not possible
+      //       to decide if the register is live or not at the block begin -> the
+      //       register information would be incorrect.
+      if (b->number_of_preds() > 1) {
+        int id = b->first_lir_instruction_id();
+        BitMap regs(FrameMap::nof_fpu_regs);
+        regs.clear();
+
+        iw.walk_to(id);   // walk after the first instruction (always a label) of the block
+        assert(iw.current_position() == id, "did not walk completely to id");
+
+        // Only consider FPU values in registers
+        GreedyInterval* interval = iw.active_first(fixedKind);
+        while (interval != GreedyInterval::end()) {
+          int reg = interval->assigned_reg();
+          assert(reg >= pd_first_fpu_reg && reg <= pd_last_fpu_reg, "no fpu register");
+          assert(interval->assigned_regHi() == -1, "must not have hi register (doubles stored in one register)");
+          assert(interval->from() <= id && id < interval->to(), "interval out of range");
+
+#ifndef PRODUCT
+          if (TraceFPURegisterUsage) {
+            tty->print("fpu reg %d is live because of ", reg - pd_first_fpu_reg); interval->print();
+          }
+#endif
+
+          regs.set_bit(reg - pd_first_fpu_reg);
+          interval = interval->next();
+        }
+
+        b->set_fpu_register_usage(regs);
+
+#ifndef PRODUCT
+        if (TraceFPURegisterUsage) {
+          tty->print("FPU regs for block %d, LIR instr %d): ", b->block_id(), id); regs.print_on(tty); tty->cr();
+        }
+#endif
+      }
+    }
+  }
+
+  GreedyFpuStackAllocator alloc(ir()->compilation(), this);
+  _fpu_stack_allocator = &alloc;
+  alloc.allocate();
+  _fpu_stack_allocator = NULL;
+}
+
+
+GreedyFpuStackAllocator::GreedyFpuStackAllocator(Compilation* compilation, Greedy* allocator)
+  : _compilation(compilation)
+  , _lir(NULL)
+  , _pos(-1)
+  , _allocator(allocator)
+  , _sim(compilation)
+  , _temp_sim(compilation)
+{}
+
+void GreedyFpuStackAllocator::allocate() {
+  int num_blocks = allocator()->block_count();
+  for (int i = 0; i < num_blocks; i++) {
+    // Set up to process block
+    BlockBegin* block = allocator()->block_at(i);
+    intArray* fpu_stack_state = block->fpu_stack_state();
+
+#ifndef PRODUCT
+    if (TraceFPUStack) {
+      tty->cr();
+      tty->print_cr("------- Begin of new Block %d -------", block->block_id());
+    }
+#endif
+
+    assert(fpu_stack_state != NULL ||
+           block->end()->as_Base() != NULL ||
+           block->is_set(BlockBegin::exception_entry_flag),
+           "FPU stack state must be present due to greedy order for FPU stack allocation");
+    // note: exception handler entries always start with an empty fpu stack
+    //       because stack merging would be too complicated
+
+    if (fpu_stack_state != NULL) {
+      sim()->read_state(fpu_stack_state);
+    } else {
+      sim()->clear();
+    }
+
+#ifndef PRODUCT
+    if (TraceFPUStack) {
+      tty->print("Reading FPU state for block %d:", block->block_id());
+      sim()->print();
+      tty->cr();
+    }
+#endif
+
+    allocate_block(block);
+    CHECK_BAILOUT();
+  }
+}
+
+void GreedyFpuStackAllocator::allocate_block(BlockBegin* block) {
+  bool processed_merge = false;
+  LIR_OpList* insts = block->lir()->instructions_list();
+  set_lir(block->lir());
+  set_pos(0);
+
+
+  // Note: insts->length() may change during loop
+  while (pos() < insts->length()) {
+    LIR_Op* op = insts->at(pos());
+    _debug_information_computed = false;
+
+#ifndef PRODUCT
+    if (TraceFPUStack) {
+      op->print();
+    }
+    check_invalid_lir_op(op);
+#endif
+
+    LIR_OpBranch* branch = op->as_OpBranch();
+    LIR_Op1* op1 = op->as_Op1();
+    LIR_Op2* op2 = op->as_Op2();
+    LIR_OpCall* opCall = op->as_OpCall();
+
+    if (branch != NULL && branch->block() != NULL) {
+      if (!processed_merge) {
+        // propagate stack at first branch to a successor
+        processed_merge = true;
+        bool required_merge = merge_fpu_stack_with_successors(block);
+
+        assert(!required_merge || branch->cond() == lir_cond_always, "splitting of critical edges should prevent FPU stack mismatches at cond branches");
+      }
+
+    } else if (op1 != NULL) {
+      handle_op1(op1);
+    } else if (op2 != NULL) {
+      handle_op2(op2);
+    } else if (opCall != NULL) {
+      handle_opCall(opCall);
+    }
+
+    compute_debug_information(op);
+
+    set_pos(1 + pos());
+  }
+
+  // Propagate stack when block does not end with branch
+  if (!processed_merge) {
+    merge_fpu_stack_with_successors(block);
+  }
+}
+
+
+void GreedyFpuStackAllocator::compute_debug_information(LIR_Op* op) {
+  if (!_debug_information_computed && op->id() != -1 && allocator()->has_info(op->id())) {
+    visitor.visit(op);
+
+    // exception handling
+    if (allocator()->compilation()->has_exception_handlers()) {
+      XHandlers* xhandlers = visitor.all_xhandler();
+      int n = xhandlers->length();
+      for (int k = 0; k < n; k++) {
+        allocate_exception_handler(xhandlers->handler_at(k));
+      }
+    } else {
+      assert(visitor.all_xhandler()->length() == 0, "missed exception handler");
+    }
+
+    // compute debug information
+    int n = visitor.info_count();
+    assert(n > 0, "should not visit operation otherwise");
+
+    for (int j = 0; j < n; j++) {
+      CodeEmitInfo* info = visitor.info_at(j);
+      // Compute debug information
+      allocator()->compute_debug_info(info, op->id());
+    }
+  }
+  _debug_information_computed = true;
+}
+
+void GreedyFpuStackAllocator::allocate_exception_handler(XHandler* xhandler) {
+  if (!sim()->is_empty()) {
+    LIR_List* old_lir = lir();
+    int old_pos = pos();
+    intArray* old_state = sim()->write_state();
+
+#ifndef PRODUCT
+    if (TraceFPUStack) {
+      tty->cr();
+      tty->print_cr("------- begin of exception handler -------");
+    }
+#endif
+
+    if (xhandler->entry_code() == NULL) {
+      // need entry code to clear FPU stack
+      LIR_List* entry_code = new LIR_List(_compilation);
+      entry_code->jump(xhandler->entry_block());
+      xhandler->set_entry_code(entry_code);
+    }
+
+    LIR_OpList* insts = xhandler->entry_code()->instructions_list();
+    set_lir(xhandler->entry_code());
+    set_pos(0);
+
+    // Note: insts->length() may change during loop
+    while (pos() < insts->length()) {
+      LIR_Op* op = insts->at(pos());
+
+#ifndef PRODUCT
+      if (TraceFPUStack) {
+        op->print();
+      }
+      check_invalid_lir_op(op);
+#endif
+
+      switch (op->code()) {
+        case lir_move:
+          assert(op->as_Op1() != NULL, "must be LIR_Op1");
+          assert(pos() != insts->length() - 1, "must not be last operation");
+
+          handle_op1((LIR_Op1*)op);
+          break;
+
+        case lir_branch:
+          assert(op->as_OpBranch()->cond() == lir_cond_always, "must be unconditional branch");
+          assert(pos() == insts->length() - 1, "must be last operation");
+
+          // remove all remaining dead registers from FPU stack
+          clear_fpu_stack(LIR_OprFact::illegalOpr);
+          break;
+
+        default:
+          // other operations not allowed in exception entry code
+          ShouldNotReachHere();
+      }
+
+      set_pos(pos() + 1);
+    }
+
+#ifndef PRODUCT
+    if (TraceFPUStack) {
+      tty->cr();
+      tty->print_cr("------- end of exception handler -------");
+    }
+#endif
+
+    set_lir(old_lir);
+    set_pos(old_pos);
+    sim()->read_state(old_state);
+  }
+}
+
+
+int GreedyFpuStackAllocator::fpu_num(LIR_Opr opr) {
+  assert(opr->is_fpu_register() && !opr->is_xmm_register(), "shouldn't call this otherwise");
+  return opr->is_single_fpu() ? opr->fpu_regnr() : opr->fpu_regnrLo();
+}
+
+int GreedyFpuStackAllocator::tos_offset(LIR_Opr opr) {
+  return sim()->offset_from_tos(fpu_num(opr));
+}
+
+
+LIR_Opr GreedyFpuStackAllocator::to_fpu_stack(LIR_Opr opr) {
+  assert(opr->is_fpu_register() && !opr->is_xmm_register(), "shouldn't call this otherwise");
+
+  int stack_offset = tos_offset(opr);
+  if (opr->is_single_fpu()) {
+    return LIR_OprFact::single_fpu(stack_offset)->make_fpu_stack_offset();
+  } else {
+    assert(opr->is_double_fpu(), "shouldn't call this otherwise");
+    return LIR_OprFact::double_fpu(stack_offset)->make_fpu_stack_offset();
+  }
+}
+
+LIR_Opr GreedyFpuStackAllocator::to_fpu_stack_top(LIR_Opr opr, bool dont_check_offset) {
+  assert(opr->is_fpu_register() && !opr->is_xmm_register(), "shouldn't call this otherwise");
+  assert(dont_check_offset || tos_offset(opr) == 0, "operand is not on stack top");
+
+  int stack_offset = 0;
+  if (opr->is_single_fpu()) {
+    return LIR_OprFact::single_fpu(stack_offset)->make_fpu_stack_offset();
+  } else {
+    assert(opr->is_double_fpu(), "shouldn't call this otherwise");
+    return LIR_OprFact::double_fpu(stack_offset)->make_fpu_stack_offset();
+  }
+}
+
+
+
+void GreedyFpuStackAllocator::insert_op(LIR_Op* op) {
+  lir()->insert_before(pos(), op);
+  set_pos(1 + pos());
+}
+
+
+void GreedyFpuStackAllocator::insert_exchange(int offset) {
+  if (offset > 0) {
+    LIR_Op1* fxch_op = new LIR_Op1(lir_fxch, LIR_OprFact::intConst(offset), LIR_OprFact::illegalOpr);
+    insert_op(fxch_op);
+    sim()->swap(offset);
+
+#ifndef PRODUCT
+    if (TraceFPUStack) {
+      tty->print("Exchanged register: %d         New state: ", sim()->get_slot(0)); sim()->print(); tty->cr();
+    }
+#endif
+
+  }
+}
+
+void GreedyFpuStackAllocator::insert_exchange(LIR_Opr opr) {
+  insert_exchange(tos_offset(opr));
+}
+
+
+void GreedyFpuStackAllocator::insert_free(int offset) {
+  // move stack slot to the top of stack and then pop it
+  insert_exchange(offset);
+
+  LIR_Op* fpop = new LIR_Op0(lir_fpop_raw);
+  insert_op(fpop);
+  sim()->pop();
+
+#ifndef PRODUCT
+    if (TraceFPUStack) {
+      tty->print("Inserted pop                   New state: "); sim()->print(); tty->cr();
+    }
+#endif
+}
+
+
+void GreedyFpuStackAllocator::insert_free_if_dead(LIR_Opr opr) {
+  if (sim()->contains(fpu_num(opr))) {
+    int res_slot = tos_offset(opr);
+    insert_free(res_slot);
+  }
+}
+
+void GreedyFpuStackAllocator::insert_free_if_dead(LIR_Opr opr, LIR_Opr ignore) {
+  if (fpu_num(opr) != fpu_num(ignore) && sim()->contains(fpu_num(opr))) {
+    int res_slot = tos_offset(opr);
+    insert_free(res_slot);
+  }
+}
+
+void GreedyFpuStackAllocator::insert_copy(LIR_Opr from, LIR_Opr to) {
+  int offset = tos_offset(from);
+  LIR_Op1* fld = new LIR_Op1(lir_fld, LIR_OprFact::intConst(offset), LIR_OprFact::illegalOpr);
+  insert_op(fld);
+
+  sim()->push(fpu_num(to));
+
+#ifndef PRODUCT
+  if (TraceFPUStack) {
+    tty->print("Inserted copy (%d -> %d)         New state: ", fpu_num(from), fpu_num(to)); sim()->print(); tty->cr();
+  }
+#endif
+}
+
+void GreedyFpuStackAllocator::do_rename(LIR_Opr from, LIR_Opr to) {
+  sim()->rename(fpu_num(from), fpu_num(to));
+}
+
+void GreedyFpuStackAllocator::do_push(LIR_Opr opr) {
+  sim()->push(fpu_num(opr));
+}
+
+void GreedyFpuStackAllocator::pop_if_last_use(LIR_Op* op, LIR_Opr opr) {
+  assert(op->fpu_pop_count() == 0, "fpu_pop_count alredy set");
+  assert(tos_offset(opr) == 0, "can only pop stack top");
+
+  if (opr->is_last_use()) {
+    op->set_fpu_pop_count(1);
+    sim()->pop();
+  }
+}
+
+void GreedyFpuStackAllocator::pop_always(LIR_Op* op, LIR_Opr opr) {
+  assert(op->fpu_pop_count() == 0, "fpu_pop_count alredy set");
+  assert(tos_offset(opr) == 0, "can only pop stack top");
+
+  op->set_fpu_pop_count(1);
+  sim()->pop();
+}
+
+void GreedyFpuStackAllocator::clear_fpu_stack(LIR_Opr preserve) {
+  int result_stack_size = (preserve->is_fpu_register() && !preserve->is_xmm_register() ? 1 : 0);
+  while (sim()->stack_size() > result_stack_size) {
+    assert(!sim()->slot_is_empty(0), "not allowed");
+
+    if (result_stack_size == 0 || sim()->get_slot(0) != fpu_num(preserve)) {
+      insert_free(0);
+    } else {
+      // move "preserve" to bottom of stack so that all other stack slots can be popped
+      insert_exchange(sim()->stack_size() - 1);
+    }
+  }
+}
+
+
+void GreedyFpuStackAllocator::handle_op1(LIR_Op1* op1) {
+  LIR_Opr in  = op1->in_opr();
+  LIR_Opr res = op1->result_opr();
+
+  LIR_Opr new_in  = in;  // new operands relative to the actual fpu stack top
+  LIR_Opr new_res = res;
+
+  // Note: this switch is processed for all LIR_Op1, regardless if they have FPU-arguments,
+  //       so checks for is_float_kind() are necessary inside the cases
+  switch (op1->code()) {
+
+    case lir_return: {
+      // FPU-Stack must only contain the (optional) fpu return value.
+      // All remaining dead values are popped from the stack
+      // If the input operand is a fpu-register, it is exchanged to the bottom of the stack
+
+      clear_fpu_stack(in);
+      if (in->is_fpu_register() && !in->is_xmm_register()) {
+        new_in = to_fpu_stack_top(in);
+      }
+
+      break;
+    }
+
+    case lir_move: {
+      if (in->is_fpu_register() && !in->is_xmm_register()) {
+        if (res->is_xmm_register()) {
+          // move from fpu register to xmm register (necessary for operations that
+          // are not available in the SSE instruction set)
+          insert_exchange(in);
+          new_in = to_fpu_stack_top(in);
+          pop_always(op1, in);
+
+        } else if (res->is_fpu_register() && !res->is_xmm_register()) {
+          // move from fpu-register to fpu-register:
+          // * input and result register equal:
+          //   nothing to do
+          // * input register is last use:
+          //   rename the input register to result register -> input register
+          //   not present on fpu-stack afterwards
+          // * input register not last use:
+          //   duplicate input register to result register to preserve input
+          //
+          // Note: The LIR-Assembler does not produce any code for fpu register moves,
+          //       so input and result stack index must be equal
+
+          if (fpu_num(in) == fpu_num(res)) {
+            // nothing to do
+          } else if (in->is_last_use()) {
+            insert_free_if_dead(res);//, in);
+            do_rename(in, res);
+          } else {
+            insert_free_if_dead(res);
+            insert_copy(in, res);
+          }
+          new_in = to_fpu_stack(res);
+          new_res = new_in;
+
+        } else {
+          // move from fpu-register to memory
+          // input operand must be on top of stack
+
+          insert_exchange(in);
+
+          // create debug information here because afterwards the register may have been popped
+          compute_debug_information(op1);
+
+          new_in = to_fpu_stack_top(in);
+          pop_if_last_use(op1, in);
+        }
+
+      } else if (res->is_fpu_register() && !res->is_xmm_register()) {
+        // move from memory/constant to fpu register
+        // result is pushed on the stack
+
+        insert_free_if_dead(res);
+
+        // create debug information before register is pushed
+        compute_debug_information(op1);
+
+        do_push(res);
+        new_res = to_fpu_stack_top(res);
+      }
+      break;
+    }
+
+    case lir_neg: {
+      if (in->is_fpu_register() && !in->is_xmm_register()) {
+        assert(res->is_fpu_register() && !res->is_xmm_register(), "must be");
+        assert(in->is_last_use(), "old value gets destroyed");
+
+        insert_free_if_dead(res, in);
+        insert_exchange(in);
+        new_in = to_fpu_stack_top(in);
+
+        do_rename(in, res);
+        new_res = to_fpu_stack_top(res);
+      }
+      break;
+    }
+
+    case lir_convert: {
+      Bytecodes::Code bc = op1->as_OpConvert()->bytecode();
+      switch (bc) {
+        case Bytecodes::_d2f:
+        case Bytecodes::_f2d:
+          assert(res->is_fpu_register(), "must be");
+          assert(in->is_fpu_register(), "must be");
+
+          if (!in->is_xmm_register() && !res->is_xmm_register()) {
+            // this is quite the same as a move from fpu-register to fpu-register
+            // Note: input and result operands must have different types
+            if (fpu_num(in) == fpu_num(res)) {
+              // nothing to do
+              new_in = to_fpu_stack(in);
+            } else if (in->is_last_use()) {
+              insert_free_if_dead(res);//, in);
+              new_in = to_fpu_stack(in);
+              do_rename(in, res);
+            } else {
+              insert_free_if_dead(res);
+              insert_copy(in, res);
+              new_in = to_fpu_stack_top(in, true);
+            }
+            new_res = to_fpu_stack(res);
+          }
+
+          break;
+
+        case Bytecodes::_i2f:
+        case Bytecodes::_l2f:
+        case Bytecodes::_i2d:
+        case Bytecodes::_l2d:
+          assert(res->is_fpu_register(), "must be");
+          if (!res->is_xmm_register()) {
+            insert_free_if_dead(res);
+            do_push(res);
+            new_res = to_fpu_stack_top(res);
+          }
+          break;
+
+        case Bytecodes::_f2i:
+        case Bytecodes::_d2i:
+          assert(in->is_fpu_register(), "must be");
+          if (!in->is_xmm_register()) {
+            insert_exchange(in);
+            new_in = to_fpu_stack_top(in);
+
+            // TODO: update registes of stub
+          }
+          break;
+
+        case Bytecodes::_f2l:
+        case Bytecodes::_d2l:
+          assert(in->is_fpu_register(), "must be");
+          if (!in->is_xmm_register()) {
+            insert_exchange(in);
+            new_in = to_fpu_stack_top(in);
+            pop_always(op1, in);
+          }
+          break;
+
+        case Bytecodes::_i2l:
+        case Bytecodes::_l2i:
+        case Bytecodes::_i2b:
+        case Bytecodes::_i2c:
+        case Bytecodes::_i2s:
+          // no fpu operands
+          break;
+
+        default:
+          ShouldNotReachHere();
+      }
+      break;
+    }
+
+    case lir_roundfp: {
+      assert(in->is_fpu_register() && !in->is_xmm_register(), "input must be in register");
+      assert(res->is_stack(), "result must be on stack");
+
+      insert_exchange(in);
+      new_in = to_fpu_stack_top(in);
+      pop_if_last_use(op1, in);
+      break;
+    }
+
+    default: {
+      assert(!in->is_float_kind() && !res->is_float_kind(), "missed a fpu-operation");
+    }
+  }
+
+  op1->set_in_opr(new_in);
+  op1->set_result_opr(new_res);
+}
+
+void GreedyFpuStackAllocator::handle_op2(LIR_Op2* op2) {
+  LIR_Opr left  = op2->in_opr1();
+  if (!left->is_float_kind()) {
+    return;
+  }
+  if (left->is_xmm_register()) {
+    return;
+  }
+
+  LIR_Opr right = op2->in_opr2();
+  LIR_Opr res   = op2->result_opr();
+  LIR_Opr new_left  = left;  // new operands relative to the actual fpu stack top
+  LIR_Opr new_right = right;
+  LIR_Opr new_res   = res;
+
+  assert(!left->is_xmm_register() && !right->is_xmm_register() && !res->is_xmm_register(), "not for xmm registers");
+
+  switch (op2->code()) {
+    case lir_cmp:
+    case lir_cmp_fd2i:
+    case lir_ucmp_fd2i:
+    case lir_assert: {
+      assert(left->is_fpu_register(), "invalid LIR");
+      assert(right->is_fpu_register(), "invalid LIR");
+
+      // the left-hand side must be on top of stack.
+      // the right-hand side is never popped, even if is_last_use is set
+      insert_exchange(left);
+      new_left = to_fpu_stack_top(left);
+      new_right = to_fpu_stack(right);
+      pop_if_last_use(op2, left);
+      break;
+    }
+
+    case lir_mul_strictfp:
+    case lir_div_strictfp: {
+      assert(op2->tmp1_opr()->is_fpu_register(), "strict operations need temporary fpu stack slot");
+      insert_free_if_dead(op2->tmp1_opr());
+      assert(sim()->stack_size() <= 7, "at least one stack slot must be free");
+      // fall-through: continue with the normal handling of lir_mul and lir_div
+    }
+    case lir_add:
+    case lir_sub:
+    case lir_mul:
+    case lir_div: {
+      assert(left->is_fpu_register(), "must be");
+      assert(res->is_fpu_register(), "must be");
+      assert(left->is_equal(res), "must be");
+
+      // either the left-hand or the right-hand side must be on top of stack
+      // (if right is not a register, left must be on top)
+      if (!right->is_fpu_register()) {
+        insert_exchange(left);
+        new_left = to_fpu_stack_top(left);
+      } else {
+        // no exchange necessary if right is alredy on top of stack
+        if (tos_offset(right) == 0) {
+          new_left = to_fpu_stack(left);
+          new_right = to_fpu_stack_top(right);
+        } else {
+          insert_exchange(left);
+          new_left = to_fpu_stack_top(left);
+          new_right = to_fpu_stack(right);
+        }
+
+        if (right->is_last_use()) {
+          op2->set_fpu_pop_count(1);
+
+          if (tos_offset(right) == 0) {
+            sim()->pop();
+          } else {
+            // if left is on top of stack, the result is placed in the stack
+            // slot of right, so a renaming from right to res is necessary
+            assert(tos_offset(left) == 0, "must be");
+            sim()->pop();
+            do_rename(right, res);
+          }
+        }
+      }
+      new_res = to_fpu_stack(res);
+
+      break;
+    }
+
+    case lir_rem: {
+      assert(left->is_fpu_register(), "must be");
+      assert(right->is_fpu_register(), "must be");
+      assert(res->is_fpu_register(), "must be");
+      assert(left->is_equal(res), "must be");
+
+      // Must bring both operands to top of stack with following operand ordering:
+      // * fpu stack before rem: ... right left
+      // * fpu stack after rem:  ... left
+      if (tos_offset(right) != 1) {
+        insert_exchange(right);
+        insert_exchange(1);
+      }
+      insert_exchange(left);
+      assert(tos_offset(right) == 1, "check");
+      assert(tos_offset(left) == 0, "check");
+
+      new_left = to_fpu_stack_top(left);
+      new_right = to_fpu_stack(right);
+
+      op2->set_fpu_pop_count(1);
+      sim()->pop();
+      do_rename(right, res);
+
+      new_res = to_fpu_stack_top(res);
+      break;
+    }
+
+    case lir_abs:
+    case lir_sqrt: {
+      // Right argument appears to be unused
+      assert(right->is_illegal(), "must be");
+      assert(left->is_fpu_register(), "must be");
+      assert(res->is_fpu_register(), "must be");
+      assert(left->is_last_use(), "old value gets destroyed");
+
+      insert_free_if_dead(res, left);
+      insert_exchange(left);
+      do_rename(left, res);
+
+      new_left = to_fpu_stack_top(res);
+      new_res = new_left;
+
+      op2->set_fpu_stack_size(sim()->stack_size());
+      break;
+    }
+
+    case lir_log:
+    case lir_log10: {
+      // log and log10 need one temporary fpu stack slot, so
+      // there is one temporary registers stored in temp of the
+      // operation. the stack allocator must guarantee that the stack
+      // slots are really free, otherwise there might be a stack
+      // overflow.
+      assert(right->is_illegal(), "must be");
+      assert(left->is_fpu_register(), "must be");
+      assert(res->is_fpu_register(), "must be");
+      assert(op2->tmp1_opr()->is_fpu_register(), "must be");
+
+      insert_free_if_dead(op2->tmp1_opr());
+      insert_free_if_dead(res, left);
+      insert_exchange(left);
+      do_rename(left, res);
+
+      new_left = to_fpu_stack_top(res);
+      new_res = new_left;
+
+      op2->set_fpu_stack_size(sim()->stack_size());
+      assert(sim()->stack_size() <= 7, "at least one stack slot must be free");
+      break;
+    }
+
+
+    case lir_tan:
+    case lir_sin:
+    case lir_cos:
+    case lir_exp: {
+      // sin, cos and exp need two temporary fpu stack slots, so there are two temporary
+      // registers (stored in right and temp of the operation).
+      // the stack allocator must guarantee that the stack slots are really free,
+      // otherwise there might be a stack overflow.
+      assert(left->is_fpu_register(), "must be");
+      assert(res->is_fpu_register(), "must be");
+      // assert(left->is_last_use(), "old value gets destroyed");
+      assert(right->is_fpu_register(), "right is used as the first temporary register");
+      assert(op2->tmp1_opr()->is_fpu_register(), "temp is used as the second temporary register");
+      assert(fpu_num(left) != fpu_num(right) && fpu_num(right) != fpu_num(op2->tmp1_opr()) && fpu_num(op2->tmp1_opr()) != fpu_num(res), "need distinct temp registers");
+
+      insert_free_if_dead(right);
+      insert_free_if_dead(op2->tmp1_opr());
+
+      insert_free_if_dead(res, left);
+      insert_exchange(left);
+      do_rename(left, res);
+
+      new_left = to_fpu_stack_top(res);
+      new_res = new_left;
+
+      op2->set_fpu_stack_size(sim()->stack_size());
+      assert(sim()->stack_size() <= 6, "at least two stack slots must be free");
+      break;
+    }
+
+    case lir_pow: {
+      // pow needs two temporary fpu stack slots, so there are two temporary
+      // registers (stored in tmp1 and tmp2 of the operation).
+      // the stack allocator must guarantee that the stack slots are really free,
+      // otherwise there might be a stack overflow.
+      assert(left->is_fpu_register(), "must be");
+      assert(right->is_fpu_register(), "must be");
+      assert(res->is_fpu_register(), "must be");
+
+      assert(op2->tmp1_opr()->is_fpu_register(), "tmp1 is the first temporary register");
+      assert(op2->tmp2_opr()->is_fpu_register(), "tmp2 is the second temporary register");
+      assert(fpu_num(left) != fpu_num(right) && fpu_num(left) != fpu_num(op2->tmp1_opr()) && fpu_num(left) != fpu_num(op2->tmp2_opr()) && fpu_num(left) != fpu_num(res), "need distinct temp registers");
+      assert(fpu_num(right) != fpu_num(op2->tmp1_opr()) && fpu_num(right) != fpu_num(op2->tmp2_opr()) && fpu_num(right) != fpu_num(res), "need distinct temp registers");
+      assert(fpu_num(op2->tmp1_opr()) != fpu_num(op2->tmp2_opr()) && fpu_num(op2->tmp1_opr()) != fpu_num(res), "need distinct temp registers");
+      assert(fpu_num(op2->tmp2_opr()) != fpu_num(res), "need distinct temp registers");
+
+      insert_free_if_dead(op2->tmp1_opr());
+      insert_free_if_dead(op2->tmp2_opr());
+
+      // Must bring both operands to top of stack with following operand ordering:
+      // * fpu stack before pow: ... right left
+      // * fpu stack after pow:  ... left
+
+      insert_free_if_dead(res, right);
+
+      if (tos_offset(right) != 1) {
+        insert_exchange(right);
+        insert_exchange(1);
+      }
+      insert_exchange(left);
+      assert(tos_offset(right) == 1, "check");
+      assert(tos_offset(left) == 0, "check");
+
+      new_left = to_fpu_stack_top(left);
+      new_right = to_fpu_stack(right);
+
+      op2->set_fpu_stack_size(sim()->stack_size());
+      assert(sim()->stack_size() <= 6, "at least two stack slots must be free");
+
+      sim()->pop();
+
+      do_rename(right, res);
+
+      new_res = to_fpu_stack_top(res);
+      break;
+    }
+
+    default: {
+      assert(false, "missed a fpu-operation");
+    }
+  }
+
+  op2->set_in_opr1(new_left);
+  op2->set_in_opr2(new_right);
+  op2->set_result_opr(new_res);
+}
+
+void GreedyFpuStackAllocator::handle_opCall(LIR_OpCall* opCall) {
+  LIR_Opr res = opCall->result_opr();
+
+  // clear fpu-stack before call
+  // it may contain dead values that could not have been remved by previous operations
+  clear_fpu_stack(LIR_OprFact::illegalOpr);
+  assert(sim()->is_empty(), "fpu stack must be empty now");
+
+  // compute debug information before (possible) fpu result is pushed
+  compute_debug_information(opCall);
+
+  if (res->is_fpu_register() && !res->is_xmm_register()) {
+    do_push(res);
+    opCall->set_result_opr(to_fpu_stack_top(res));
+  }
+}
+
+#ifndef PRODUCT
+void GreedyFpuStackAllocator::check_invalid_lir_op(LIR_Op* op) {
+  switch (op->code()) {
+    case lir_24bit_FPU:
+    case lir_reset_FPU:
+    case lir_ffree:
+      assert(false, "operations not allowed in lir. If one of these operations is needed, check if they have fpu operands");
+      break;
+
+    case lir_fpop_raw:
+    case lir_fxch:
+    case lir_fld:
+      assert(false, "operations only inserted by GreedyFpuStackAllocator");
+      break;
+  }
+}
+#endif
+
+
+void GreedyFpuStackAllocator::merge_insert_add(LIR_List* instrs, FpuStackSim* cur_sim, int reg) {
+  LIR_Op1* move = new LIR_Op1(lir_move, LIR_OprFact::doubleConst(0), LIR_OprFact::double_fpu(reg)->make_fpu_stack_offset());
+
+  instrs->instructions_list()->push(move);
+
+  cur_sim->push(reg);
+  move->set_result_opr(to_fpu_stack(move->result_opr()));
+
+  #ifndef PRODUCT
+    if (TraceFPUStack) {
+      tty->print("Added new register: %d         New state: ", reg); cur_sim->print(); tty->cr();
+    }
+  #endif
+}
+
+void GreedyFpuStackAllocator::merge_insert_xchg(LIR_List* instrs, FpuStackSim* cur_sim, int slot) {
+  assert(slot > 0, "no exchange necessary");
+
+  LIR_Op1* fxch = new LIR_Op1(lir_fxch, LIR_OprFact::intConst(slot));
+  instrs->instructions_list()->push(fxch);
+  cur_sim->swap(slot);
+
+  #ifndef PRODUCT
+    if (TraceFPUStack) {
+      tty->print("Exchanged register: %d         New state: ", cur_sim->get_slot(slot)); cur_sim->print(); tty->cr();
+    }
+  #endif
+}
+
+void GreedyFpuStackAllocator::merge_insert_pop(LIR_List* instrs, FpuStackSim* cur_sim) {
+  int reg = cur_sim->get_slot(0);
+
+  LIR_Op* fpop = new LIR_Op0(lir_fpop_raw);
+  instrs->instructions_list()->push(fpop);
+  cur_sim->pop(reg);
+
+  #ifndef PRODUCT
+    if (TraceFPUStack) {
+      tty->print("Removed register: %d           New state: ", reg); cur_sim->print(); tty->cr();
+    }
+  #endif
+}
+
+bool GreedyFpuStackAllocator::merge_rename(FpuStackSim* cur_sim, FpuStackSim* sux_sim, int start_slot, int change_slot) {
+  int reg = cur_sim->get_slot(change_slot);
+
+  for (int slot = start_slot; slot >= 0; slot--) {
+    int new_reg = sux_sim->get_slot(slot);
+
+    if (!cur_sim->contains(new_reg)) {
+      cur_sim->set_slot(change_slot, new_reg);
+
+      #ifndef PRODUCT
+        if (TraceFPUStack) {
+          tty->print("Renamed register %d to %d       New state: ", reg, new_reg); cur_sim->print(); tty->cr();
+        }
+      #endif
+
+      return true;
+    }
+  }
+  return false;
+}
+
+
+void GreedyFpuStackAllocator::merge_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, FpuStackSim* sux_sim) {
+#ifndef PRODUCT
+  if (TraceFPUStack) {
+    tty->cr();
+    tty->print("before merging: pred: "); cur_sim->print(); tty->cr();
+    tty->print("                 sux: "); sux_sim->print(); tty->cr();
+  }
+
+  int slot;
+  for (slot = 0; slot < cur_sim->stack_size(); slot++) {
+    assert(!cur_sim->slot_is_empty(slot), "not handled by algorithm");
+  }
+  for (slot = 0; slot < sux_sim->stack_size(); slot++) {
+    assert(!sux_sim->slot_is_empty(slot), "not handled by algorithm");
+  }
+#endif
+
+  // size difference between cur and sux that must be resolved by adding or removing values form the stack
+  int size_diff = cur_sim->stack_size() - sux_sim->stack_size();
+
+  if (!ComputeExactFPURegisterUsage) {
+    // add slots that are currently free, but used in successor
+    // When the exact FPU register usage is computed, the stack does
+    // not contain dead values at merging -> no values must be added
+
+    int sux_slot = sux_sim->stack_size() - 1;
+    while (size_diff < 0) {
+      assert(sux_slot >= 0, "slot out of bounds -> error in algorithm");
+
+      int reg = sux_sim->get_slot(sux_slot);
+      if (!cur_sim->contains(reg)) {
+        merge_insert_add(instrs, cur_sim, reg);
+        size_diff++;
+
+        if (sux_slot + size_diff != 0) {
+          merge_insert_xchg(instrs, cur_sim, sux_slot + size_diff);
+        }
+      }
+     sux_slot--;
+    }
+  }
+
+  assert(cur_sim->stack_size() >= sux_sim->stack_size(), "stack size must be equal or greater now");
+  assert(size_diff == cur_sim->stack_size() - sux_sim->stack_size(), "must be");
+
+  // stack merge algorithm:
+  // 1) as long as the current stack top is not in the right location (that meens
+  //    it should not be on the stack top), exchange it into the right location
+  // 2) if the stack top is right, but the remaining stack is not ordered correctly,
+  //    the stack top is exchanged away to get another value on top ->
+  //    now step 1) can be continued
+  // the stack can also contain unused items -> these items are removed from stack
+
+  int finished_slot = sux_sim->stack_size() - 1;
+  while (finished_slot >= 0 || size_diff > 0) {
+    while (size_diff > 0 || (cur_sim->stack_size() > 0 && cur_sim->get_slot(0) != sux_sim->get_slot(0))) {
+      int reg = cur_sim->get_slot(0);
+      if (sux_sim->contains(reg)) {
+        int sux_slot = sux_sim->offset_from_tos(reg);
+        merge_insert_xchg(instrs, cur_sim, sux_slot + size_diff);
+
+      } else if (!merge_rename(cur_sim, sux_sim, finished_slot, 0)) {
+        assert(size_diff > 0, "must be");
+
+        merge_insert_pop(instrs, cur_sim);
+        size_diff--;
+      }
+      assert(cur_sim->stack_size() == 0 || cur_sim->get_slot(0) != reg, "register must have been changed");
+    }
+
+    while (finished_slot >= 0 && cur_sim->get_slot(finished_slot) == sux_sim->get_slot(finished_slot)) {
+      finished_slot--;
+    }
+
+    if (finished_slot >= 0) {
+      int reg = cur_sim->get_slot(finished_slot);
+
+      if (sux_sim->contains(reg) || !merge_rename(cur_sim, sux_sim, finished_slot, finished_slot)) {
+        assert(sux_sim->contains(reg) || size_diff > 0, "must be");
+        merge_insert_xchg(instrs, cur_sim, finished_slot);
+      }
+      assert(cur_sim->get_slot(finished_slot) != reg, "register must have been changed");
+    }
+  }
+
+#ifndef PRODUCT
+  if (TraceFPUStack) {
+    tty->print("after merging:  pred: "); cur_sim->print(); tty->cr();
+    tty->print("                 sux: "); sux_sim->print(); tty->cr();
+    tty->cr();
+  }
+#endif
+  assert(cur_sim->stack_size() == sux_sim->stack_size(), "stack size must be equal now");
+}
+
+
+void GreedyFpuStackAllocator::merge_cleanup_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, BitMap& live_fpu_regs) {
+#ifndef PRODUCT
+  if (TraceFPUStack) {
+    tty->cr();
+    tty->print("before cleanup: state: "); cur_sim->print(); tty->cr();
+    tty->print("                live:  "); live_fpu_regs.print_on(tty); tty->cr();
+  }
+#endif
+
+  int slot = 0;
+  while (slot < cur_sim->stack_size()) {
+    int reg = cur_sim->get_slot(slot);
+    if (!live_fpu_regs.at(reg)) {
+      if (slot != 0) {
+        merge_insert_xchg(instrs, cur_sim, slot);
+      }
+      merge_insert_pop(instrs, cur_sim);
+    } else {
+      slot++;
+    }
+  }
+
+#ifndef PRODUCT
+  if (TraceFPUStack) {
+    tty->print("after cleanup:  state: "); cur_sim->print(); tty->cr();
+    tty->print("                live:  "); live_fpu_regs.print_on(tty); tty->cr();
+    tty->cr();
+  }
+
+  // check if fpu stack only contains live registers
+  for (unsigned int i = 0; i < live_fpu_regs.size(); i++) {
+    if (live_fpu_regs.at(i) != cur_sim->contains(i)) {
+      tty->print_cr("mismatch between required and actual stack content");
+      break;
+    }
+  }
+#endif
+}
+
+
+bool GreedyFpuStackAllocator::merge_fpu_stack_with_successors(BlockBegin* block) {
+#ifndef PRODUCT
+  if (TraceFPUStack) {
+    tty->print_cr("Propagating FPU stack state for B%d at LIR_Op position %d to successors:",
+                  block->block_id(), pos());
+    sim()->print();
+    tty->cr();
+  }
+#endif
+
+  bool changed = false;
+  int number_of_sux = block->number_of_sux();
+
+  if (number_of_sux == 1 && block->sux_at(0)->number_of_preds() > 1) {
+    // The successor has at least two incoming edges, so a stack merge will be necessary
+    // If this block is the first predecessor, cleanup the current stack and propagate it
+    // If this block is not the first predecessor, a stack merge will be necessary
+
+    BlockBegin* sux = block->sux_at(0);
+    intArray* state = sux->fpu_stack_state();
+    LIR_List* instrs = new LIR_List(_compilation);
+
+    if (state != NULL) {
+      // Merge with a successors that already has a FPU stack state
+      // the block must only have one successor because critical edges must been split
+      FpuStackSim* cur_sim = sim();
+      FpuStackSim* sux_sim = temp_sim();
+      sux_sim->read_state(state);
+
+      merge_fpu_stack(instrs, cur_sim, sux_sim);
+
+    } else {
+      // propagate current FPU stack state to successor without state
+      // clean up stack first so that there are no dead values on the stack
+      if (ComputeExactFPURegisterUsage) {
+        FpuStackSim* cur_sim = sim();
+        BitMap live_fpu_regs = block->sux_at(0)->fpu_register_usage();
+        assert(live_fpu_regs.size() == FrameMap::nof_fpu_regs, "missing register usage");
+
+        merge_cleanup_fpu_stack(instrs, cur_sim, live_fpu_regs);
+      }
+
+      intArray* state = sim()->write_state();
+      if (TraceFPUStack) {
+        tty->print_cr("Setting FPU stack state of B%d (merge path)", sux->block_id());
+        sim()->print(); tty->cr();
+      }
+      sux->set_fpu_stack_state(state);
+    }
+
+    if (instrs->instructions_list()->length() > 0) {
+      lir()->insert_before(pos(), instrs);
+      set_pos(instrs->instructions_list()->length() + pos());
+      changed = true;
+    }
+
+  } else {
+    // Propagate unmodified Stack to successors where a stack merge is not necessary
+    intArray* state = sim()->write_state();
+    for (int i = 0; i < number_of_sux; i++) {
+      BlockBegin* sux = block->sux_at(i);
+
+#ifdef ASSERT
+      for (int j = 0; j < sux->number_of_preds(); j++) {
+        assert(block == sux->pred_at(j), "all critical edges must be broken");
+      }
+
+      // check if new state is same
+      if (sux->fpu_stack_state() != NULL) {
+        intArray* sux_state = sux->fpu_stack_state();
+        assert(state->length() == sux_state->length(), "overwriting existing stack state");
+        for (int j = 0; j < state->length(); j++) {
+          assert(state->at(j) == sux_state->at(j), "overwriting existing stack state");
+        }
+      }
+#endif
+#ifndef PRODUCT
+      if (TraceFPUStack) {
+        tty->print_cr("Setting FPU stack state of B%d", sux->block_id());
+        sim()->print(); tty->cr();
+      }
+#endif
+
+      sux->set_fpu_stack_state(state);
+    }
+  }
+
+#ifndef PRODUCT
+  // assertions that FPU stack state conforms to all successors' states
+  intArray* cur_state = sim()->write_state();
+  for (int i = 0; i < number_of_sux; i++) {
+    BlockBegin* sux = block->sux_at(i);
+    intArray* sux_state = sux->fpu_stack_state();
+
+    assert(sux_state != NULL, "no fpu state");
+    assert(cur_state->length() == sux_state->length(), "incorrect length");
+    for (int i = 0; i < cur_state->length(); i++) {
+      assert(cur_state->at(i) == sux_state->at(i), "element not equal");
+    }
+  }
+#endif
+
+  return changed;
+}
diff -r 555c45b3456e src/cpu/x86/vm/c1_Greedy_x86.hpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/cpu/x86/vm/c1_Greedy_x86.hpp	Sat Mar 24 11:04:51 2018 +0800
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef CPU_X86_VM_C1_GREEDY_X86_HPP
+#define CPU_X86_VM_C1_GREEDY_X86_HPP
+
+inline bool Greedy::is_processed_reg_num(int reg_num) {
+#ifndef _LP64
+  // rsp and rbp (numbers 6 ancd 7) are ignored
+  assert(FrameMap::rsp_opr->cpu_regnr() == 6, "wrong assumption below");
+  assert(FrameMap::rbp_opr->cpu_regnr() == 7, "wrong assumption below");
+  assert(reg_num >= 0, "invalid reg_num");
+#else
+  // rsp and rbp, r10, r15 (numbers [12,15]) are ignored
+  // r12 (number 11) is conditional on compressed oops.
+  assert(FrameMap::r12_opr->cpu_regnr() == 11, "wrong assumption below");
+  assert(FrameMap::r10_opr->cpu_regnr() == 12, "wrong assumption below");
+  assert(FrameMap::r15_opr->cpu_regnr() == 13, "wrong assumption below");
+  assert(FrameMap::rsp_opr->cpu_regnrLo() == 14, "wrong assumption below");
+  assert(FrameMap::rbp_opr->cpu_regnrLo() == 15, "wrong assumption below");
+  assert(reg_num >= 0, "invalid reg_num");
+#endif // _LP64
+  return reg_num <= FrameMap::last_cpu_reg() || reg_num >= pd_nof_cpu_regs_frame_map;
+}
+
+inline int Greedy::num_physical_regs(BasicType type) {
+  // Intel requires two cpu registers for long,
+  // but requires only one fpu register for double
+  if (LP64_ONLY(false &&) type == T_LONG) {
+    return 2;
+  }
+  return 1;
+}
+
+
+inline bool Greedy::requires_adjacent_regs(BasicType type) {
+  return false;
+}
+
+inline bool Greedy::is_caller_save(int assigned_reg) {
+  assert(assigned_reg >= 0 && assigned_reg < nof_regs, "should call this only for registers");
+  return true; // no callee-saved registers on Intel
+
+}
+
+
+inline void Greedy::pd_add_temps(LIR_Op* op) {
+  switch (op->code()) {
+    case lir_tan:
+    case lir_sin:
+    case lir_cos: {
+      // The slow path for these functions may need to save and
+      // restore all live registers but we don't want to save and
+      // restore everything all the time, so mark the xmms as being
+      // killed.  If the slow path were explicit or we could propagate
+      // live register masks down to the assembly we could do better
+      // but we don't have any easy way to do that right now.  We
+      // could also consider not killing all xmm registers if we
+      // assume that slow paths are uncommon but it's not clear that
+      // would be a good idea.
+      if (UseSSE > 0) {
+#ifndef PRODUCT
+        if (TraceGreedyLevel >= 2) {
+          tty->print_cr("killing XMMs for trig");
+        }
+#endif
+        int op_id = op->id();
+        for (int xmm = 0; xmm < FrameMap::nof_caller_save_xmm_regs; xmm++) {
+          LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(xmm);
+          add_temp(reg_num(opr), op_id, noUse, T_ILLEGAL);
+        }
+      }
+      break;
+    }
+  }
+}
+
+
+// Implementation of GreedyWalker
+
+inline bool GreedyWalker::pd_init_regs_for_alloc(GreedyInterval* cur) {
+  if (allocator()->gen()->is_vreg_flag_set(cur->reg_num(), LIRGenerator::byte_reg)) {
+    assert(cur->type() != T_FLOAT && cur->type() != T_DOUBLE, "cpu regs only");
+    _first_reg = pd_first_byte_reg;
+    _last_reg = FrameMap::last_byte_reg();
+    return true;
+  } else if ((UseSSE >= 1 && cur->type() == T_FLOAT) || (UseSSE >= 2 && cur->type() == T_DOUBLE)) {
+    _first_reg = pd_first_xmm_reg;
+    _last_reg = pd_last_xmm_reg;
+    return true;
+  }
+
+  return false;
+}
+
+
+class GreedyFpuStackAllocator VALUE_OBJ_CLASS_SPEC {
+ private:
+  Compilation* _compilation;
+  Greedy* _allocator;
+
+  LIR_OpVisitState visitor;
+
+  LIR_List* _lir;
+  int _pos;
+  FpuStackSim _sim;
+  FpuStackSim _temp_sim;
+
+  bool _debug_information_computed;
+
+  Greedy*   allocator()                      { return _allocator; }
+  Compilation*  compilation() const              { return _compilation; }
+
+  // unified bailout support
+  void          bailout(const char* msg) const   { compilation()->bailout(msg); }
+  bool          bailed_out() const               { return compilation()->bailed_out(); }
+
+  int pos() { return _pos; }
+  void set_pos(int pos) { _pos = pos; }
+  LIR_Op* cur_op() { return lir()->instructions_list()->at(pos()); }
+  LIR_List* lir() { return _lir; }
+  void set_lir(LIR_List* lir) { _lir = lir; }
+  FpuStackSim* sim() { return &_sim; }
+  FpuStackSim* temp_sim() { return &_temp_sim; }
+
+  int fpu_num(LIR_Opr opr);
+  int tos_offset(LIR_Opr opr);
+  LIR_Opr to_fpu_stack_top(LIR_Opr opr, bool dont_check_offset = false);
+
+  // Helper functions for handling operations
+  void insert_op(LIR_Op* op);
+  void insert_exchange(int offset);
+  void insert_exchange(LIR_Opr opr);
+  void insert_free(int offset);
+  void insert_free_if_dead(LIR_Opr opr);
+  void insert_free_if_dead(LIR_Opr opr, LIR_Opr ignore);
+  void insert_copy(LIR_Opr from, LIR_Opr to);
+  void do_rename(LIR_Opr from, LIR_Opr to);
+  void do_push(LIR_Opr opr);
+  void pop_if_last_use(LIR_Op* op, LIR_Opr opr);
+  void pop_always(LIR_Op* op, LIR_Opr opr);
+  void clear_fpu_stack(LIR_Opr preserve);
+  void handle_op1(LIR_Op1* op1);
+  void handle_op2(LIR_Op2* op2);
+  void handle_opCall(LIR_OpCall* opCall);
+  void compute_debug_information(LIR_Op* op);
+  void allocate_exception_handler(XHandler* xhandler);
+  void allocate_block(BlockBegin* block);
+
+#ifndef PRODUCT
+  void check_invalid_lir_op(LIR_Op* op);
+#endif
+
+  // Helper functions for merging of fpu stacks
+  void merge_insert_add(LIR_List* instrs, FpuStackSim* cur_sim, int reg);
+  void merge_insert_xchg(LIR_List* instrs, FpuStackSim* cur_sim, int slot);
+  void merge_insert_pop(LIR_List* instrs, FpuStackSim* cur_sim);
+  bool merge_rename(FpuStackSim* cur_sim, FpuStackSim* sux_sim, int start_slot, int change_slot);
+  void merge_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, FpuStackSim* sux_sim);
+  void merge_cleanup_fpu_stack(LIR_List* instrs, FpuStackSim* cur_sim, BitMap& live_fpu_regs);
+  bool merge_fpu_stack_with_successors(BlockBegin* block);
+
+ public:
+  LIR_Opr to_fpu_stack(LIR_Opr opr); // used by Greedy for creation of debug information
+
+  GreedyFpuStackAllocator(Compilation* compilation, Greedy* allocator);
+  void allocate();
+};
+
+#endif // CPU_X86_VM_C1_GREEDY_X86_HPP
diff -r 555c45b3456e src/share/vm/c1/c1_CFGPrinter.hpp
--- a/src/share/vm/c1/c1_CFGPrinter.hpp	Sat Mar 24 11:03:39 2018 +0800
+++ b/src/share/vm/c1/c1_CFGPrinter.hpp	Sat Mar 24 11:04:51 2018 +0800
@@ -35,6 +35,7 @@
 
 class CFGPrinterOutput;
 class IntervalList;
+class GreedyIntervalList;
 
 class CFGPrinter : public AllStatic {
 private:
@@ -47,6 +48,7 @@
   static void print_cfg(BlockList* blocks, const char* name, bool do_print_HIR, bool do_print_LIR);
   static void print_cfg(IR* blocks, const char* name, bool do_print_HIR, bool do_print_LIR);
   static void print_intervals(IntervalList* intervals, const char* name);
+  static void print_intervals(GreedyIntervalList* intervals, const char* name);
 };
 
 #endif
diff -r 555c45b3456e src/share/vm/c1/c1_Greedy.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/vm/c1/c1_Greedy.cpp	Sat Mar 24 11:04:51 2018 +0800
@@ -0,0 +1,6724 @@
+/*
+ * Copyright (c) 2005, 2015, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "c1/c1_CFGPrinter.hpp"
+#include "c1/c1_CodeStubs.hpp"
+#include "c1/c1_Compilation.hpp"
+#include "c1/c1_FrameMap.hpp"
+#include "c1/c1_IR.hpp"
+#include "c1/c1_LIRGenerator.hpp"
+#include "c1/c1_Greedy.hpp"
+#include "c1/c1_ValueStack.hpp"
+#include "utilities/bitMap.inline.hpp"
+#ifdef TARGET_ARCH_x86
+# include "vmreg_x86.inline.hpp"
+#endif
+#ifdef TARGET_ARCH_sparc
+# include "vmreg_sparc.inline.hpp"
+#endif
+#ifdef TARGET_ARCH_zero
+# include "vmreg_zero.inline.hpp"
+#endif
+#ifdef TARGET_ARCH_arm
+# include "vmreg_arm.inline.hpp"
+#endif
+#ifdef TARGET_ARCH_ppc
+# include "vmreg_ppc.inline.hpp"
+#endif
+
+
+#ifndef PRODUCT
+
+  static GreedyStatistic _stat_before_alloc;
+  static GreedyStatistic _stat_after_asign;
+  static GreedyStatistic _stat_final;
+
+  static GreedyTimers _total_timer;
+
+  // helper macro for short definition of timer
+  #define TIME_GREEDY(timer_name)  TraceTime _block_timer("", _total_timer.timer(GreedyTimers::timer_name), TimeGreedy || TimeEachGreedy, Verbose);
+
+  // helper macro for short definition of trace-output inside code
+  #define TRACE_GREEDY(level, code)       \
+    if (TraceGreedyLevel >= level) {       \
+      code;                                    \
+    }
+
+#else
+
+  #define TIME_GREEDY(timer_name)
+  #define TRACE_GREEDY(level, code)
+
+#endif
+
+// Map BasicType to spill size in 32-bit words, matching VMReg's notion of words
+#ifdef _LP64
+static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 2, 2, 0, 2,  1, 2, 1, -1};
+#else
+static int type2spill_size[T_CONFLICT+1]={ -1, 0, 0, 0, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 0, 1, -1, 1, 1, -1};
+#endif
+
+
+// Implementation of Greedy
+
+Greedy::Greedy(IR* ir, LIRGenerator* gen, FrameMap* frame_map)
+ : _compilation(ir->compilation())
+ , _ir(ir)
+ , _gen(gen)
+ , _frame_map(frame_map)
+ , _num_virtual_regs(gen->max_virtual_register_number())
+ , _has_fpu_registers(false)
+ , _num_calls(-1)
+ , _max_spills(0)
+ , _unused_spill_slot(-1)
+ , _intervals(0)   // initialized later with correct length
+ , _new_intervals_from_allocation(new GreedyIntervalList())
+ , _sorted_intervals(NULL)
+ , _needs_full_resort(false)
+ , _lir_ops(0)     // initialized later with correct length
+ , _block_of_op(0) // initialized later with correct length
+ , _has_info(0)
+ , _has_call(0)
+ , _scope_value_cache(0) // initialized later with correct length
+ , _interval_in_loop(0, 0) // initialized later with correct length
+ , _cached_blocks(*ir->greedy_order())
+#ifdef X86
+ , _fpu_stack_allocator(NULL)
+#endif
+{
+  assert(this->ir() != NULL,          "check if valid");
+  assert(this->compilation() != NULL, "check if valid");
+  assert(this->gen() != NULL,         "check if valid");
+  assert(this->frame_map() != NULL,   "check if valid");
+}
+
+
+// ********** functions for converting LIR-Operands to register numbers
+//
+// Emulate a flat register file comprising physical integer registers,
+// physical floating-point registers and virtual registers, in that order.
+// Virtual registers already have appropriate numbers, since V0 is
+// the number of physical registers.
+// Returns -1 for hi word if opr is a single word operand.
+//
+// Note: the inverse operation (calculating an operand for register numbers)
+//       is done in calc_operand_for_interval()
+
+int Greedy::reg_num(LIR_Opr opr) {
+  assert(opr->is_register(), "should not call this otherwise");
+
+  if (opr->is_virtual_register()) {
+    assert(opr->vreg_number() >= nof_regs, "found a virtual register with a fixed-register number");
+    return opr->vreg_number();
+  } else if (opr->is_single_cpu()) {
+    return opr->cpu_regnr();
+  } else if (opr->is_double_cpu()) {
+    return opr->cpu_regnrLo();
+#ifdef X86
+  } else if (opr->is_single_xmm()) {
+    return opr->fpu_regnr() + pd_first_xmm_reg;
+  } else if (opr->is_double_xmm()) {
+    return opr->fpu_regnrLo() + pd_first_xmm_reg;
+#endif
+  } else if (opr->is_single_fpu()) {
+    return opr->fpu_regnr() + pd_first_fpu_reg;
+  } else if (opr->is_double_fpu()) {
+    return opr->fpu_regnrLo() + pd_first_fpu_reg;
+  } else {
+    ShouldNotReachHere();
+    return -1;
+  }
+}
+
+int Greedy::reg_numHi(LIR_Opr opr) {
+  assert(opr->is_register(), "should not call this otherwise");
+
+  if (opr->is_virtual_register()) {
+    return -1;
+  } else if (opr->is_single_cpu()) {
+    return -1;
+  } else if (opr->is_double_cpu()) {
+    return opr->cpu_regnrHi();
+#ifdef X86
+  } else if (opr->is_single_xmm()) {
+    return -1;
+  } else if (opr->is_double_xmm()) {
+    return -1;
+#endif
+  } else if (opr->is_single_fpu()) {
+    return -1;
+  } else if (opr->is_double_fpu()) {
+    return opr->fpu_regnrHi() + pd_first_fpu_reg;
+  } else {
+    ShouldNotReachHere();
+    return -1;
+  }
+}
+
+
+// ********** functions for classification of intervals
+
+bool Greedy::is_precolored_interval(const GreedyInterval* i) {
+  return i->reg_num() < Greedy::nof_regs;
+}
+
+bool Greedy::is_virtual_interval(const GreedyInterval* i) {
+  return i->reg_num() >= LIR_OprDesc::vreg_base;
+}
+
+bool Greedy::is_precolored_cpu_interval(const GreedyInterval* i) {
+  return i->reg_num() < Greedy::nof_cpu_regs;
+}
+
+bool Greedy::is_virtual_cpu_interval(const GreedyInterval* i) {
+#if defined(__SOFTFP__) || defined(E500V2)
+  return i->reg_num() >= LIR_OprDesc::vreg_base;
+#else
+  return i->reg_num() >= LIR_OprDesc::vreg_base && (i->type() != T_FLOAT && i->type() != T_DOUBLE);
+#endif // __SOFTFP__ or E500V2
+}
+
+bool Greedy::is_precolored_fpu_interval(const GreedyInterval* i) {
+  return i->reg_num() >= Greedy::nof_cpu_regs && i->reg_num() < Greedy::nof_regs;
+}
+
+bool Greedy::is_virtual_fpu_interval(const GreedyInterval* i) {
+#if defined(__SOFTFP__) || defined(E500V2)
+  return false;
+#else
+  return i->reg_num() >= LIR_OprDesc::vreg_base && (i->type() == T_FLOAT || i->type() == T_DOUBLE);
+#endif // __SOFTFP__ or E500V2
+}
+
+bool Greedy::is_in_fpu_register(const GreedyInterval* i) {
+  // fixed intervals not needed for FPU stack allocation
+  return i->reg_num() >= nof_regs && pd_first_fpu_reg <= i->assigned_reg() && i->assigned_reg() <= pd_last_fpu_reg;
+}
+
+bool Greedy::is_oop_interval(const GreedyInterval* i) {
+  // fixed intervals never contain oops
+  return i->reg_num() >= nof_regs && i->type() == T_OBJECT;
+}
+
+
+// ********** General helper functions
+
+// compute next unused stack index that can be used for spilling
+int Greedy::allocate_spill_slot(bool double_word) {
+  int spill_slot;
+  if (double_word) {
+    if ((_max_spills & 1) == 1) {
+      // alignment of double-word values
+      // the hole because of the alignment is filled with the next single-word value
+      assert(_unused_spill_slot == -1, "wasting a spill slot");
+      _unused_spill_slot = _max_spills;
+      _max_spills++;
+    }
+    spill_slot = _max_spills;
+    _max_spills += 2;
+
+  } else if (_unused_spill_slot != -1) {
+    // re-use hole that was the result of a previous double-word alignment
+    spill_slot = _unused_spill_slot;
+    _unused_spill_slot = -1;
+
+  } else {
+    spill_slot = _max_spills;
+    _max_spills++;
+  }
+
+  int result = spill_slot + Greedy::nof_regs + frame_map()->argcount();
+
+  // the class OopMapValue uses only 11 bits for storing the name of the
+  // oop location. So a stack slot bigger than 2^11 leads to an overflow
+  // that is not reported in product builds. Prevent this by checking the
+  // spill slot here (altough this value and the later used location name
+  // are slightly different)
+  if (result > 2000) {
+    bailout("too many stack slots used");
+  }
+
+  return result;
+}
+
+void Greedy::assign_spill_slot(GreedyInterval* it) {
+  // assign the canonical spill slot of the parent (if a part of the interval
+  // is already spilled) or allocate a new spill slot
+  if (it->canonical_spill_slot() >= 0) {
+    it->assign_reg(it->canonical_spill_slot());
+  } else {
+    int spill = allocate_spill_slot(type2spill_size[it->type()] == 2);
+    it->set_canonical_spill_slot(spill);
+    it->assign_reg(spill);
+  }
+}
+
+void Greedy::propagate_spill_slots() {
+  if (!frame_map()->finalize_frame(max_spills())) {
+    bailout("frame too large");
+  }
+}
+
+// create a new interval with a predefined reg_num
+// (only used for parent intervals that are created during the building phase)
+GreedyInterval* Greedy::create_interval(int reg_num) {
+  assert(_intervals.at(reg_num) == NULL, "overwriting exisiting interval");
+
+  GreedyInterval* interval = new GreedyInterval(reg_num);
+  _intervals.at_put(reg_num, interval);
+
+  // assign register number for precolored intervals
+  if (reg_num < LIR_OprDesc::vreg_base) {
+    interval->assign_reg(reg_num);
+  }
+  return interval;
+}
+
+// assign a new reg_num to the interval and append it to the list of intervals
+// (only used for child intervals that are created during register allocation)
+void Greedy::append_interval(GreedyInterval* it) {
+  it->set_reg_num(_intervals.length());
+  _intervals.append(it);
+  _new_intervals_from_allocation->append(it);
+}
+
+// copy the vreg-flags if an interval is split
+void Greedy::copy_register_flags(GreedyInterval* from, GreedyInterval* to) {
+  if (gen()->is_vreg_flag_set(from->reg_num(), LIRGenerator::byte_reg)) {
+    gen()->set_vreg_flag(to->reg_num(), LIRGenerator::byte_reg);
+  }
+  if (gen()->is_vreg_flag_set(from->reg_num(), LIRGenerator::callee_saved)) {
+    gen()->set_vreg_flag(to->reg_num(), LIRGenerator::callee_saved);
+  }
+
+  // Note: do not copy the must_start_in_memory flag because it is not necessary for child
+  //       intervals (only the very beginning of the interval must be in memory)
+}
+
+
+// ********** spill move optimization
+// eliminate moves from register to stack if stack slot is known to be correct
+
+// called during building of intervals
+void Greedy::change_spill_definition_pos(GreedyInterval* interval, int def_pos) {
+  assert(interval->is_split_parent(), "can only be called for split parents");
+
+  switch (interval->spill_state()) {
+    case noDefinitionFound:
+      assert(interval->spill_definition_pos() == -1, "must no be set before");
+      interval->set_spill_definition_pos(def_pos);
+      interval->set_spill_state(oneDefinitionFound);
+      break;
+
+    case oneDefinitionFound:
+      assert(def_pos <= interval->spill_definition_pos(), "positions are processed in reverse order when intervals are created");
+      if (def_pos < interval->spill_definition_pos() - 2) {
+        // second definition found, so no spill optimization possible for this interval
+        interval->set_spill_state(noOptimization);
+      } else {
+        // two consecutive definitions (because of two-operand LIR form)
+        assert(block_of_op_with_id(def_pos) == block_of_op_with_id(interval->spill_definition_pos()), "block must be equal");
+      }
+      break;
+
+    case noOptimization:
+      // nothing to do
+      break;
+
+    default:
+      assert(false, "other states not allowed at this time");
+  }
+}
+
+// called during register allocation
+void Greedy::change_spill_state(GreedyInterval* interval, int spill_pos) {
+  switch (interval->spill_state()) {
+    case oneDefinitionFound: {
+      int def_loop_depth = block_of_op_with_id(interval->spill_definition_pos())->loop_depth();
+      int spill_loop_depth = block_of_op_with_id(spill_pos)->loop_depth();
+
+      if (def_loop_depth < spill_loop_depth) {
+        // the loop depth of the spilling position is higher then the loop depth
+        // at the definition of the interval -> move write to memory out of loop
+        // by storing at definitin of the interval
+        interval->set_spill_state(storeAtDefinition);
+      } else {
+        // the interval is currently spilled only once, so for now there is no
+        // reason to store the interval at the definition
+        interval->set_spill_state(oneMoveInserted);
+      }
+      break;
+    }
+
+    case oneMoveInserted: {
+      // the interval is spilled more then once, so it is better to store it to
+      // memory at the definition
+      interval->set_spill_state(storeAtDefinition);
+      break;
+    }
+
+    case storeAtDefinition:
+    case startInMemory:
+    case noOptimization:
+    case noDefinitionFound:
+      // nothing to do
+      break;
+
+    default:
+      assert(false, "other states not allowed at this time");
+  }
+}
+
+
+bool Greedy::must_store_at_definition(const GreedyInterval* i) {
+  return i->is_split_parent() && i->spill_state() == storeAtDefinition;
+}
+
+// called once before asignment of register numbers
+void Greedy::eliminate_spill_moves() {
+  TIME_GREEDY(timer_eliminate_spill_moves);
+  TRACE_GREEDY(3, tty->print_cr("***** Eliminating unnecessary spill moves"));
+
+  // collect all intervals that must be stored after their definion.
+  // the list is sorted by GreedyInterval::spill_definition_pos
+  GreedyInterval* interval;
+  GreedyInterval* temp_list;
+  create_unhandled_lists(&interval, &temp_list, must_store_at_definition, NULL);
+
+#ifdef ASSERT
+  GreedyInterval* prev = NULL;
+  GreedyInterval* temp = interval;
+  while (temp != GreedyInterval::end()) {
+    assert(temp->spill_definition_pos() > 0, "invalid spill definition pos");
+    if (prev != NULL) {
+      assert(temp->from() >= prev->from(), "intervals not sorted");
+      assert(temp->spill_definition_pos() >= prev->spill_definition_pos(), "when intervals are sorted by from, then they must also be sorted by spill_definition_pos");
+    }
+
+    assert(temp->canonical_spill_slot() >= Greedy::nof_regs, "interval has no spill slot assigned");
+    assert(temp->spill_definition_pos() >= temp->from(), "invalid order");
+    assert(temp->spill_definition_pos() <= temp->from() + 2, "only intervals defined once at their start-pos can be optimized");
+
+    TRACE_GREEDY(4, tty->print_cr("interval %d (from %d to %d) must be stored at %d", temp->reg_num(), temp->from(), temp->to(), temp->spill_definition_pos()));
+
+    temp = temp->next();
+  }
+#endif
+
+  LIR_InsertionBuffer insertion_buffer;
+  int num_blocks = block_count();
+  for (int i = 0; i < num_blocks; i++) {
+    BlockBegin* block = block_at(i);
+    LIR_OpList* instructions = block->lir()->instructions_list();
+    int         num_inst = instructions->length();
+    bool        has_new = false;
+
+    // iterate all instructions of the block. skip the first because it is always a label
+    for (int j = 1; j < num_inst; j++) {
+      LIR_Op* op = instructions->at(j);
+      int op_id = op->id();
+
+      if (op_id == -1) {
+        // remove move from register to stack if the stack slot is guaranteed to be correct.
+        // only moves that have been inserted by Greedy can be removed.
+        assert(op->code() == lir_move, "only moves can have a op_id of -1");
+        assert(op->as_Op1() != NULL, "move must be LIR_Op1");
+        assert(op->as_Op1()->result_opr()->is_virtual(), "Greedy inserts only moves to virtual registers");
+
+        LIR_Op1* op1 = (LIR_Op1*)op;
+        GreedyInterval* interval = interval_at(op1->result_opr()->vreg_number());
+
+        if (interval->assigned_reg() >= Greedy::nof_regs && interval->always_in_memory()) {
+          // move target is a stack slot that is always correct, so eliminate instruction
+          TRACE_GREEDY(4, tty->print_cr("eliminating move from interval %d to %d", op1->in_opr()->vreg_number(), op1->result_opr()->vreg_number()));
+          instructions->at_put(j, NULL); // NULL-instructions are deleted by assign_reg_num
+        }
+
+      } else {
+        // insert move from register to stack just after the beginning of the interval
+        assert(interval == GreedyInterval::end() || interval->spill_definition_pos() >= op_id, "invalid order");
+        assert(interval == GreedyInterval::end() || (interval->is_split_parent() && interval->spill_state() == storeAtDefinition), "invalid interval");
+
+        while (interval != GreedyInterval::end() && interval->spill_definition_pos() == op_id) {
+          if (!has_new) {
+            // prepare insertion buffer (appended when all instructions of the block are processed)
+            insertion_buffer.init(block->lir());
+            has_new = true;
+          }
+
+          LIR_Opr from_opr = operand_for_interval(interval);
+          LIR_Opr to_opr = canonical_spill_opr(interval);
+          assert(from_opr->is_fixed_cpu() || from_opr->is_fixed_fpu(), "from operand must be a register");
+          assert(to_opr->is_stack(), "to operand must be a stack slot");
+
+          insertion_buffer.move(j, from_opr, to_opr);
+          TRACE_GREEDY(4, tty->print_cr("inserting move after definition of interval %d to stack slot %d at op_id %d", interval->reg_num(), interval->canonical_spill_slot() - Greedy::nof_regs, op_id));
+
+          interval = interval->next();
+        }
+      }
+    } // end of instruction iteration
+
+    if (has_new) {
+      block->lir()->append(&insertion_buffer);
+    }
+  } // end of block iteration
+
+  assert(interval == GreedyInterval::end(), "missed an interval");
+}
+
+
+// ********** Phase 1: number all instructions in all blocks
+// Compute depth-first and greedy block orders, and number LIR_Op nodes for greedy.
+
+void Greedy::number_instructions() {
+  {
+    // dummy-timer to measure the cost of the timer itself
+    // (this time is then subtracted from all other timers to get the real value)
+    TIME_GREEDY(timer_do_nothing);
+  }
+  TIME_GREEDY(timer_number_instructions);
+
+  // Assign IDs to LIR nodes and build a mapping, lir_ops, from ID to LIR_Op node.
+  int num_blocks = block_count();
+  int num_instructions = 0;
+  int i;
+  for (i = 0; i < num_blocks; i++) {
+    num_instructions += block_at(i)->lir()->instructions_list()->length();
+  }
+
+  // initialize with correct length
+  _lir_ops = LIR_OpArray(num_instructions);
+  _block_of_op = BlockBeginArray(num_instructions);
+
+  int op_id = 0;
+  int idx = 0;
+
+  for (i = 0; i < num_blocks; i++) {
+    BlockBegin* block = block_at(i);
+    block->set_first_lir_instruction_id(op_id);
+    LIR_OpList* instructions = block->lir()->instructions_list();
+
+    int num_inst = instructions->length();
+    for (int j = 0; j < num_inst; j++) {
+      LIR_Op* op = instructions->at(j);
+      op->set_id(op_id);
+
+      _lir_ops.at_put(idx, op);
+      _block_of_op.at_put(idx, block);
+      assert(lir_op_with_id(op_id) == op, "must match");
+
+      idx++;
+      op_id += 2; // numbering of lir_ops by two
+    }
+    block->set_last_lir_instruction_id(op_id - 2);
+  }
+  assert(idx == num_instructions, "must match");
+  assert(idx * 2 == op_id, "must match");
+
+  _has_call = BitMap(num_instructions); _has_call.clear();
+  _has_info = BitMap(num_instructions); _has_info.clear();
+}
+
+
+// ********** Phase 2: compute local live sets separately for each block
+// (sets live_gen and live_kill for each block)
+
+void Greedy::set_live_gen_kill(Value value, LIR_Op* op, BitMap& live_gen, BitMap& live_kill) {
+  LIR_Opr opr = value->operand();
+  Constant* con = value->as_Constant();
+
+  // check some asumptions about debug information
+  assert(!value->type()->is_illegal(), "if this local is used by the interpreter it shouldn't be of indeterminate type");
+  assert(con == NULL || opr->is_virtual() || opr->is_constant() || opr->is_illegal(), "asumption: Constant instructions have only constant operands");
+  assert(con != NULL || opr->is_virtual(), "asumption: non-Constant instructions have only virtual operands");
+
+  if ((con == NULL || con->is_pinned()) && opr->is_register()) {
+    assert(reg_num(opr) == opr->vreg_number() && !is_valid_reg_num(reg_numHi(opr)), "invalid optimization below");
+    int reg = opr->vreg_number();
+    if (!live_kill.at(reg)) {
+      live_gen.set_bit(reg);
+      TRACE_GREEDY(4, tty->print_cr("  Setting live_gen for value %c%d, LIR op_id %d, register number %d", value->type()->tchar(), value->id(), op->id(), reg));
+    }
+  }
+}
+
+
+void Greedy::compute_local_live_sets() {
+  TIME_GREEDY(timer_compute_local_live_sets);
+
+  int  num_blocks = block_count();
+  int  live_size = live_set_size();
+  bool local_has_fpu_registers = false;
+  int  local_num_calls = 0;
+  LIR_OpVisitState visitor;
+
+  BitMap2D local_interval_in_loop = BitMap2D(_num_virtual_regs, num_loops());
+  local_interval_in_loop.clear();
+
+  // iterate all blocks
+  for (int i = 0; i < num_blocks; i++) {
+    BlockBegin* block = block_at(i);
+
+    BitMap live_gen(live_size);  live_gen.clear();
+    BitMap live_kill(live_size); live_kill.clear();
+
+    if (block->is_set(BlockBegin::exception_entry_flag)) {
+      // Phi functions at the begin of an exception handler are
+      // implicitly defined (= killed) at the beginning of the block.
+      for_each_phi_fun(block, phi,
+        live_kill.set_bit(phi->operand()->vreg_number())
+      );
+    }
+
+    LIR_OpList* instructions = block->lir()->instructions_list();
+    int num_inst = instructions->length();
+
+    // iterate all instructions of the block. skip the first because it is always a label
+    assert(visitor.no_operands(instructions->at(0)), "first operation must always be a label");
+    for (int j = 1; j < num_inst; j++) {
+      LIR_Op* op = instructions->at(j);
+
+      // visit operation to collect all operands
+      visitor.visit(op);
+
+      if (visitor.has_call()) {
+        _has_call.set_bit(op->id() >> 1);
+        local_num_calls++;
+      }
+      if (visitor.info_count() > 0) {
+        _has_info.set_bit(op->id() >> 1);
+      }
+
+      // iterate input operands of instruction
+      int k, n, reg;
+      n = visitor.opr_count(LIR_OpVisitState::inputMode);
+      for (k = 0; k < n; k++) {
+        LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
+        assert(opr->is_register(), "visitor should only return register operands");
+
+        if (opr->is_virtual_register()) {
+          assert(reg_num(opr) == opr->vreg_number() && !is_valid_reg_num(reg_numHi(opr)), "invalid optimization below");
+          reg = opr->vreg_number();
+          if (!live_kill.at(reg)) {
+            live_gen.set_bit(reg);
+            TRACE_GREEDY(4, tty->print_cr("  Setting live_gen for register %d at instruction %d", reg, op->id()));
+          }
+          if (block->loop_index() >= 0) {
+            local_interval_in_loop.set_bit(reg, block->loop_index());
+          }
+          local_has_fpu_registers = local_has_fpu_registers || opr->is_virtual_fpu();
+        }
+
+#ifdef ASSERT
+        // fixed intervals are never live at block boundaries, so
+        // they need not be processed in live sets.
+        // this is checked by these assertions to be sure about it.
+        // the entry block may have incoming values in registers, which is ok.
+        if (!opr->is_virtual_register() && block != ir()->start()) {
+          reg = reg_num(opr);
+          if (is_processed_reg_num(reg)) {
+            assert(live_kill.at(reg), "using fixed register that is not defined in this block");
+          }
+          reg = reg_numHi(opr);
+          if (is_valid_reg_num(reg) && is_processed_reg_num(reg)) {
+            assert(live_kill.at(reg), "using fixed register that is not defined in this block");
+          }
+        }
+#endif
+      }
+
+      // Add uses of live locals from interpreter's point of view for proper debug information generation
+      n = visitor.info_count();
+      for (k = 0; k < n; k++) {
+        CodeEmitInfo* info = visitor.info_at(k);
+        ValueStack* stack = info->stack();
+        for_each_state_value(stack, value,
+          set_live_gen_kill(value, op, live_gen, live_kill)
+        );
+      }
+
+      // iterate temp operands of instruction
+      n = visitor.opr_count(LIR_OpVisitState::tempMode);
+      for (k = 0; k < n; k++) {
+        LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
+        assert(opr->is_register(), "visitor should only return register operands");
+
+        if (opr->is_virtual_register()) {
+          assert(reg_num(opr) == opr->vreg_number() && !is_valid_reg_num(reg_numHi(opr)), "invalid optimization below");
+          reg = opr->vreg_number();
+          live_kill.set_bit(reg);
+          if (block->loop_index() >= 0) {
+            local_interval_in_loop.set_bit(reg, block->loop_index());
+          }
+          local_has_fpu_registers = local_has_fpu_registers || opr->is_virtual_fpu();
+        }
+
+#ifdef ASSERT
+        // fixed intervals are never live at block boundaries, so
+        // they need not be processed in live sets
+        // process them only in debug mode so that this can be checked
+        if (!opr->is_virtual_register()) {
+          reg = reg_num(opr);
+          if (is_processed_reg_num(reg)) {
+            live_kill.set_bit(reg_num(opr));
+          }
+          reg = reg_numHi(opr);
+          if (is_valid_reg_num(reg) && is_processed_reg_num(reg)) {
+            live_kill.set_bit(reg);
+          }
+        }
+#endif
+      }
+
+      // iterate output operands of instruction
+      n = visitor.opr_count(LIR_OpVisitState::outputMode);
+      for (k = 0; k < n; k++) {
+        LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
+        assert(opr->is_register(), "visitor should only return register operands");
+
+        if (opr->is_virtual_register()) {
+          assert(reg_num(opr) == opr->vreg_number() && !is_valid_reg_num(reg_numHi(opr)), "invalid optimization below");
+          reg = opr->vreg_number();
+          live_kill.set_bit(reg);
+          if (block->loop_index() >= 0) {
+            local_interval_in_loop.set_bit(reg, block->loop_index());
+          }
+          local_has_fpu_registers = local_has_fpu_registers || opr->is_virtual_fpu();
+        }
+
+#ifdef ASSERT
+        // fixed intervals are never live at block boundaries, so
+        // they need not be processed in live sets
+        // process them only in debug mode so that this can be checked
+        if (!opr->is_virtual_register()) {
+          reg = reg_num(opr);
+          if (is_processed_reg_num(reg)) {
+            live_kill.set_bit(reg_num(opr));
+          }
+          reg = reg_numHi(opr);
+          if (is_valid_reg_num(reg) && is_processed_reg_num(reg)) {
+            live_kill.set_bit(reg);
+          }
+        }
+#endif
+      }
+    } // end of instruction iteration
+
+    block->set_live_gen (live_gen);
+    block->set_live_kill(live_kill);
+    block->set_live_in  (BitMap(live_size)); block->live_in().clear();
+    block->set_live_out (BitMap(live_size)); block->live_out().clear();
+
+    TRACE_GREEDY(4, tty->print("live_gen  B%d ", block->block_id()); print_bitmap(block->live_gen()));
+    TRACE_GREEDY(4, tty->print("live_kill B%d ", block->block_id()); print_bitmap(block->live_kill()));
+  } // end of block iteration
+
+  // propagate local calculated information into Greedy object
+  _has_fpu_registers = local_has_fpu_registers;
+  compilation()->set_has_fpu_code(local_has_fpu_registers);
+
+  _num_calls = local_num_calls;
+  _interval_in_loop = local_interval_in_loop;
+}
+
+
+// ********** Phase 3: perform a backward dataflow analysis to compute global live sets
+// (sets live_in and live_out for each block)
+
+void Greedy::compute_global_live_sets() {
+  TIME_GREEDY(timer_compute_global_live_sets);
+
+  int  num_blocks = block_count();
+  bool change_occurred;
+  bool change_occurred_in_block;
+  int  iteration_count = 0;
+  BitMap live_out(live_set_size()); live_out.clear(); // scratch set for calculations
+
+  // Perform a backward dataflow analysis to compute live_out and live_in for each block.
+  // The loop is executed until a fixpoint is reached (no changes in an iteration)
+  // Exception handlers must be processed because not all live values are
+  // present in the state array, e.g. because of global value numbering
+  do {
+    change_occurred = false;
+
+    // iterate all blocks in reverse order
+    for (int i = num_blocks - 1; i >= 0; i--) {
+      BlockBegin* block = block_at(i);
+
+      change_occurred_in_block = false;
+
+      // live_out(block) is the union of live_in(sux), for successors sux of block
+      int n = block->number_of_sux();
+      int e = block->number_of_exception_handlers();
+      if (n + e > 0) {
+        // block has successors
+        if (n > 0) {
+          live_out.set_from(block->sux_at(0)->live_in());
+          for (int j = 1; j < n; j++) {
+            live_out.set_union(block->sux_at(j)->live_in());
+          }
+        } else {
+          live_out.clear();
+        }
+        for (int j = 0; j < e; j++) {
+          live_out.set_union(block->exception_handler_at(j)->live_in());
+        }
+
+        if (!block->live_out().is_same(live_out)) {
+          // A change occurred.  Swap the old and new live out sets to avoid copying.
+          BitMap temp = block->live_out();
+          block->set_live_out(live_out);
+          live_out = temp;
+
+          change_occurred = true;
+          change_occurred_in_block = true;
+        }
+      }
+
+      if (iteration_count == 0 || change_occurred_in_block) {
+        // live_in(block) is the union of live_gen(block) with (live_out(block) & !live_kill(block))
+        // note: live_in has to be computed only in first iteration or if live_out has changed!
+        BitMap live_in = block->live_in();
+        live_in.set_from(block->live_out());
+        live_in.set_difference(block->live_kill());
+        live_in.set_union(block->live_gen());
+      }
+
+#ifndef PRODUCT
+      if (TraceGreedyLevel >= 4) {
+        char c = ' ';
+        if (iteration_count == 0 || change_occurred_in_block) {
+          c = '*';
+        }
+        tty->print("(%d) live_in%c  B%d ", iteration_count, c, block->block_id()); print_bitmap(block->live_in());
+        tty->print("(%d) live_out%c B%d ", iteration_count, c, block->block_id()); print_bitmap(block->live_out());
+      }
+#endif
+    }
+    iteration_count++;
+
+    if (change_occurred && iteration_count > 50) {
+      BAILOUT("too many iterations in compute_global_live_sets");
+    }
+  } while (change_occurred);
+
+
+#ifdef ASSERT
+  // check that fixed intervals are not live at block boundaries
+  // (live set must be empty at fixed intervals)
+  for (int i = 0; i < num_blocks; i++) {
+    BlockBegin* block = block_at(i);
+    for (int j = 0; j < LIR_OprDesc::vreg_base; j++) {
+      assert(block->live_in().at(j)  == false, "live_in  set of fixed register must be empty");
+      assert(block->live_out().at(j) == false, "live_out set of fixed register must be empty");
+      assert(block->live_gen().at(j) == false, "live_gen set of fixed register must be empty");
+    }
+  }
+#endif
+
+  // check that the live_in set of the first block is empty
+  BitMap live_in_args(ir()->start()->live_in().size());
+  live_in_args.clear();
+  if (!ir()->start()->live_in().is_same(live_in_args)) {
+#ifdef ASSERT
+    tty->print_cr("Error: live_in set of first block must be empty (when this fails, virtual registers are used before they are defined)");
+    tty->print_cr("affected registers:");
+    print_bitmap(ir()->start()->live_in());
+
+    // print some additional information to simplify debugging
+    for (unsigned int i = 0; i < ir()->start()->live_in().size(); i++) {
+      if (ir()->start()->live_in().at(i)) {
+        Instruction* instr = gen()->instruction_for_vreg(i);
+        tty->print_cr("* vreg %d (HIR instruction %c%d)", i, instr == NULL ? ' ' : instr->type()->tchar(), instr == NULL ? 0 : instr->id());
+
+        for (int j = 0; j < num_blocks; j++) {
+          BlockBegin* block = block_at(j);
+          if (block->live_gen().at(i)) {
+            tty->print_cr("  used in block B%d", block->block_id());
+          }
+          if (block->live_kill().at(i)) {
+            tty->print_cr("  defined in block B%d", block->block_id());
+          }
+        }
+      }
+    }
+
+#endif
+    // when this fails, virtual registers are used before they are defined.
+    assert(false, "live_in set of first block must be empty");
+    // bailout of if this occurs in product mode.
+    bailout("live_in set of first block not empty");
+  }
+}
+
+
+// ********** Phase 4: build intervals
+// (fills the list _intervals)
+
+void Greedy::add_use(Value value, int from, int to, GreedyIntervalUseKind use_kind) {
+  assert(!value->type()->is_illegal(), "if this value is used by the interpreter it shouldn't be of indeterminate type");
+  LIR_Opr opr = value->operand();
+  Constant* con = value->as_Constant();
+
+  if ((con == NULL || con->is_pinned()) && opr->is_register()) {
+    assert(reg_num(opr) == opr->vreg_number() && !is_valid_reg_num(reg_numHi(opr)), "invalid optimization below");
+    add_use(opr, from, to, use_kind);
+  }
+}
+
+
+void Greedy::add_def(LIR_Opr opr, int def_pos, GreedyIntervalUseKind use_kind) {
+  TRACE_GREEDY(2, tty->print(" def "); opr->print(tty); tty->print_cr(" def_pos %d (%d)", def_pos, use_kind));
+  assert(opr->is_register(), "should not be called otherwise");
+
+  if (opr->is_virtual_register()) {
+    assert(reg_num(opr) == opr->vreg_number() && !is_valid_reg_num(reg_numHi(opr)), "invalid optimization below");
+    add_def(opr->vreg_number(), def_pos, use_kind, opr->type_register());
+
+  } else {
+    int reg = reg_num(opr);
+    if (is_processed_reg_num(reg)) {
+      add_def(reg, def_pos, use_kind, opr->type_register());
+    }
+    reg = reg_numHi(opr);
+    if (is_valid_reg_num(reg) && is_processed_reg_num(reg)) {
+      add_def(reg, def_pos, use_kind, opr->type_register());
+    }
+  }
+}
+
+void Greedy::add_use(LIR_Opr opr, int from, int to, GreedyIntervalUseKind use_kind) {
+  TRACE_GREEDY(2, tty->print(" use "); opr->print(tty); tty->print_cr(" from %d to %d (%d)", from, to, use_kind));
+  assert(opr->is_register(), "should not be called otherwise");
+
+  if (opr->is_virtual_register()) {
+    assert(reg_num(opr) == opr->vreg_number() && !is_valid_reg_num(reg_numHi(opr)), "invalid optimization below");
+    add_use(opr->vreg_number(), from, to, use_kind, opr->type_register());
+
+  } else {
+    int reg = reg_num(opr);
+    if (is_processed_reg_num(reg)) {
+      add_use(reg, from, to, use_kind, opr->type_register());
+    }
+    reg = reg_numHi(opr);
+    if (is_valid_reg_num(reg) && is_processed_reg_num(reg)) {
+      add_use(reg, from, to, use_kind, opr->type_register());
+    }
+  }
+}
+
+void Greedy::add_temp(LIR_Opr opr, int temp_pos, GreedyIntervalUseKind use_kind) {
+  TRACE_GREEDY(2, tty->print(" temp "); opr->print(tty); tty->print_cr(" temp_pos %d (%d)", temp_pos, use_kind));
+  assert(opr->is_register(), "should not be called otherwise");
+
+  if (opr->is_virtual_register()) {
+    assert(reg_num(opr) == opr->vreg_number() && !is_valid_reg_num(reg_numHi(opr)), "invalid optimization below");
+    add_temp(opr->vreg_number(), temp_pos, use_kind, opr->type_register());
+
+  } else {
+    int reg = reg_num(opr);
+    if (is_processed_reg_num(reg)) {
+      add_temp(reg, temp_pos, use_kind, opr->type_register());
+    }
+    reg = reg_numHi(opr);
+    if (is_valid_reg_num(reg) && is_processed_reg_num(reg)) {
+      add_temp(reg, temp_pos, use_kind, opr->type_register());
+    }
+  }
+}
+
+
+void Greedy::add_def(int reg_num, int def_pos, GreedyIntervalUseKind use_kind, BasicType type) {
+  GreedyInterval* interval = interval_at(reg_num);
+  if (interval != NULL) {
+    assert(interval->reg_num() == reg_num, "wrong interval");
+
+    if (type != T_ILLEGAL) {
+      interval->set_type(type);
+    }
+
+    GreedyRange* r = interval->first();
+    if (r->from() <= def_pos) {
+      // Update the starting point (when a range is first created for a use, its
+      // start is the beginning of the current block until a def is encountered.)
+      r->set_from(def_pos);
+      interval->add_use_pos(def_pos, use_kind);
+
+    } else {
+      // Dead value - make vacuous interval
+      // also add use_kind for dead intervals
+      interval->add_range(def_pos, def_pos + 1);
+      interval->add_use_pos(def_pos, use_kind);
+      TRACE_GREEDY(2, tty->print_cr("Warning: def of reg %d at %d occurs without use", reg_num, def_pos));
+    }
+
+  } else {
+    // Dead value - make vacuous interval
+    // also add use_kind for dead intervals
+    interval = create_interval(reg_num);
+    if (type != T_ILLEGAL) {
+      interval->set_type(type);
+    }
+
+    interval->add_range(def_pos, def_pos + 1);
+    interval->add_use_pos(def_pos, use_kind);
+    TRACE_GREEDY(2, tty->print_cr("Warning: dead value %d at %d in live intervals", reg_num, def_pos));
+  }
+
+  change_spill_definition_pos(interval, def_pos);
+  if (use_kind == noUse && interval->spill_state() <= startInMemory) {
+        // detection of method-parameters and roundfp-results
+        // TODO: move this directly to position where use-kind is computed
+    interval->set_spill_state(startInMemory);
+  }
+}
+
+void Greedy::add_use(int reg_num, int from, int to, GreedyIntervalUseKind use_kind, BasicType type) {
+  GreedyInterval* interval = interval_at(reg_num);
+  if (interval == NULL) {
+    interval = create_interval(reg_num);
+  }
+  assert(interval->reg_num() == reg_num, "wrong interval");
+
+  if (type != T_ILLEGAL) {
+    interval->set_type(type);
+  }
+
+  interval->add_range(from, to);
+  interval->add_use_pos(to, use_kind);
+}
+
+void Greedy::add_temp(int reg_num, int temp_pos, GreedyIntervalUseKind use_kind, BasicType type) {
+  GreedyInterval* interval = interval_at(reg_num);
+  if (interval == NULL) {
+    interval = create_interval(reg_num);
+  }
+  assert(interval->reg_num() == reg_num, "wrong interval");
+
+  if (type != T_ILLEGAL) {
+    interval->set_type(type);
+  }
+
+  interval->add_range(temp_pos, temp_pos + 1);
+  interval->add_use_pos(temp_pos, use_kind);
+}
+
+
+// the results of this functions are used for optimizing spilling and reloading
+// if the functions return shouldHaveRegister and the interval is spilled,
+// it is not reloaded to a register.
+GreedyIntervalUseKind Greedy::use_kind_of_output_operand(LIR_Op* op, LIR_Opr opr) {
+  if (op->code() == lir_move) {
+    assert(op->as_Op1() != NULL, "lir_move must be LIR_Op1");
+    LIR_Op1* move = (LIR_Op1*)op;
+    LIR_Opr res = move->result_opr();
+    bool result_in_memory = res->is_virtual() && gen()->is_vreg_flag_set(res->vreg_number(), LIRGenerator::must_start_in_memory);
+
+    if (result_in_memory) {
+      // Begin of an interval with must_start_in_memory set.
+      // This interval will always get a stack slot first, so return noUse.
+      return noUse;
+
+    } else if (move->in_opr()->is_stack()) {
+      // method argument (condition must be equal to handle_method_arguments)
+      return noUse;
+
+    } else if (move->in_opr()->is_register() && move->result_opr()->is_register()) {
+      // Move from register to register
+      if (block_of_op_with_id(op->id())->is_set(BlockBegin::osr_entry_flag)) {
+        // special handling of phi-function moves inside osr-entry blocks
+        // input operand must have a register instead of output operand (leads to better register allocation)
+        return shouldHaveRegister;
+      }
+    }
+  }
+
+  if (opr->is_virtual() &&
+      gen()->is_vreg_flag_set(opr->vreg_number(), LIRGenerator::must_start_in_memory)) {
+    // result is a stack-slot, so prevent immediate reloading
+    return noUse;
+  }
+
+  // all other operands require a register
+  return mustHaveRegister;
+}
+
+GreedyIntervalUseKind Greedy::use_kind_of_input_operand(LIR_Op* op, LIR_Opr opr) {
+  if (op->code() == lir_move) {
+    assert(op->as_Op1() != NULL, "lir_move must be LIR_Op1");
+    LIR_Op1* move = (LIR_Op1*)op;
+    LIR_Opr res = move->result_opr();
+    bool result_in_memory = res->is_virtual() && gen()->is_vreg_flag_set(res->vreg_number(), LIRGenerator::must_start_in_memory);
+
+    if (result_in_memory) {
+      // Move to an interval with must_start_in_memory set.
+      // To avoid moves from stack to stack (not allowed) force the input operand to a register
+      return mustHaveRegister;
+
+    } else if (move->in_opr()->is_register() && move->result_opr()->is_register()) {
+      // Move from register to register
+      if (block_of_op_with_id(op->id())->is_set(BlockBegin::osr_entry_flag)) {
+        // special handling of phi-function moves inside osr-entry blocks
+        // input operand must have a register instead of output operand (leads to better register allocation)
+        return mustHaveRegister;
+      }
+
+      // The input operand is not forced to a register (moves from stack to register are allowed),
+      // but it is faster if the input operand is in a register
+      return shouldHaveRegister;
+    }
+  }
+
+
+#ifdef X86
+  if (op->code() == lir_cmove) {
+    // conditional moves can handle stack operands
+    assert(op->result_opr()->is_register(), "result must always be in a register");
+    return shouldHaveRegister;
+  }
+
+  // optimizations for second input operand of arithmehtic operations on Intel
+  // this operand is allowed to be on the stack in some cases
+  BasicType opr_type = opr->type_register();
+  if (opr_type == T_FLOAT || opr_type == T_DOUBLE) {
+    if ((UseSSE == 1 && opr_type == T_FLOAT) || UseSSE >= 2) {
+      // SSE float instruction (T_DOUBLE only supported with SSE2)
+      switch (op->code()) {
+        case lir_cmp:
+        case lir_add:
+        case lir_sub:
+        case lir_mul:
+        case lir_div:
+        {
+          assert(op->as_Op2() != NULL, "must be LIR_Op2");
+          LIR_Op2* op2 = (LIR_Op2*)op;
+          if (op2->in_opr1() != op2->in_opr2() && op2->in_opr2() == opr) {
+            assert((op2->result_opr()->is_register() || op->code() == lir_cmp) && op2->in_opr1()->is_register(), "cannot mark second operand as stack if others are not in register");
+            return shouldHaveRegister;
+          }
+        }
+      }
+    } else {
+      // FPU stack float instruction
+      switch (op->code()) {
+        case lir_add:
+        case lir_sub:
+        case lir_mul:
+        case lir_div:
+        {
+          assert(op->as_Op2() != NULL, "must be LIR_Op2");
+          LIR_Op2* op2 = (LIR_Op2*)op;
+          if (op2->in_opr1() != op2->in_opr2() && op2->in_opr2() == opr) {
+            assert((op2->result_opr()->is_register() || op->code() == lir_cmp) && op2->in_opr1()->is_register(), "cannot mark second operand as stack if others are not in register");
+            return shouldHaveRegister;
+          }
+        }
+      }
+    }
+    // We want to sometimes use logical operations on pointers, in particular in GC barriers.
+    // Since 64bit logical operations do not current support operands on stack, we have to make sure
+    // T_OBJECT doesn't get spilled along with T_LONG.
+  } else if (opr_type != T_LONG LP64_ONLY(&& opr_type != T_OBJECT)) {
+    // integer instruction (note: long operands must always be in register)
+    switch (op->code()) {
+      case lir_cmp:
+      case lir_add:
+      case lir_sub:
+      case lir_logic_and:
+      case lir_logic_or:
+      case lir_logic_xor:
+      {
+        assert(op->as_Op2() != NULL, "must be LIR_Op2");
+        LIR_Op2* op2 = (LIR_Op2*)op;
+        if (op2->in_opr1() != op2->in_opr2() && op2->in_opr2() == opr) {
+          assert((op2->result_opr()->is_register() || op->code() == lir_cmp) && op2->in_opr1()->is_register(), "cannot mark second operand as stack if others are not in register");
+          return shouldHaveRegister;
+        }
+      }
+    }
+  }
+#endif // X86
+
+  // all other operands require a register
+  return mustHaveRegister;
+}
+
+
+void Greedy::handle_method_arguments(LIR_Op* op) {
+  // special handling for method arguments (moves from stack to virtual register):
+  // the interval gets no register assigned, but the stack slot.
+  // it is split before the first use by the register allocator.
+
+  if (op->code() == lir_move) {
+    assert(op->as_Op1() != NULL, "must be LIR_Op1");
+    LIR_Op1* move = (LIR_Op1*)op;
+
+    if (move->in_opr()->is_stack()) {
+#ifdef ASSERT
+      int arg_size = compilation()->method()->arg_size();
+      LIR_Opr o = move->in_opr();
+      if (o->is_single_stack()) {
+        assert(o->single_stack_ix() >= 0 && o->single_stack_ix() < arg_size, "out of range");
+      } else if (o->is_double_stack()) {
+        assert(o->double_stack_ix() >= 0 && o->double_stack_ix() < arg_size, "out of range");
+      } else {
+        ShouldNotReachHere();
+      }
+
+      assert(move->id() > 0, "invalid id");
+      assert(block_of_op_with_id(move->id())->number_of_preds() == 0, "move from stack must be in first block");
+      assert(move->result_opr()->is_virtual(), "result of move must be a virtual register");
+
+      TRACE_GREEDY(4, tty->print_cr("found move from stack slot %d to vreg %d", o->is_single_stack() ? o->single_stack_ix() : o->double_stack_ix(), reg_num(move->result_opr())));
+#endif
+
+      GreedyInterval* interval = interval_at(reg_num(move->result_opr()));
+
+      int stack_slot = Greedy::nof_regs + (move->in_opr()->is_single_stack() ? move->in_opr()->single_stack_ix() : move->in_opr()->double_stack_ix());
+      interval->set_canonical_spill_slot(stack_slot);
+      interval->assign_reg(stack_slot);
+    }
+  }
+}
+
+void Greedy::handle_doubleword_moves(LIR_Op* op) {
+  // special handling for doubleword move from memory to register:
+  // in this case the registers of the input address and the result
+  // registers must not overlap -> add a temp range for the input registers
+  if (op->code() == lir_move) {
+    assert(op->as_Op1() != NULL, "must be LIR_Op1");
+    LIR_Op1* move = (LIR_Op1*)op;
+
+    if (move->result_opr()->is_double_cpu() && move->in_opr()->is_pointer()) {
+      LIR_Address* address = move->in_opr()->as_address_ptr();
+      if (address != NULL) {
+        if (address->base()->is_valid()) {
+          add_temp(address->base(), op->id(), noUse);
+        }
+        if (address->index()->is_valid()) {
+          add_temp(address->index(), op->id(), noUse);
+        }
+      }
+    }
+  }
+}
+
+void Greedy::add_register_hints(LIR_Op* op) {
+  switch (op->code()) {
+    case lir_move:      // fall through
+    case lir_convert: {
+      assert(op->as_Op1() != NULL, "lir_move, lir_convert must be LIR_Op1");
+      LIR_Op1* move = (LIR_Op1*)op;
+
+      LIR_Opr move_from = move->in_opr();
+      LIR_Opr move_to = move->result_opr();
+
+      if (move_to->is_register() && move_from->is_register()) {
+        GreedyInterval* from = interval_at(reg_num(move_from));
+        GreedyInterval* to = interval_at(reg_num(move_to));
+        if (from != NULL && to != NULL) {
+          to->set_register_hint(from);
+          TRACE_GREEDY(4, tty->print_cr("operation at op_id %d: added hint from interval %d to %d", move->id(), from->reg_num(), to->reg_num()));
+        }
+      }
+      break;
+    }
+    case lir_cmove: {
+      assert(op->as_Op2() != NULL, "lir_cmove must be LIR_Op2");
+      LIR_Op2* cmove = (LIR_Op2*)op;
+
+      LIR_Opr move_from = cmove->in_opr1();
+      LIR_Opr move_to = cmove->result_opr();
+
+      if (move_to->is_register() && move_from->is_register()) {
+        GreedyInterval* from = interval_at(reg_num(move_from));
+        GreedyInterval* to = interval_at(reg_num(move_to));
+        if (from != NULL && to != NULL) {
+          to->set_register_hint(from);
+          TRACE_GREEDY(4, tty->print_cr("operation at op_id %d: added hint from interval %d to %d", cmove->id(), from->reg_num(), to->reg_num()));
+        }
+      }
+      break;
+    }
+  }
+}
+
+
+void Greedy::build_intervals() {
+  TIME_GREEDY(timer_build_intervals);
+
+  // initialize interval list with expected number of intervals
+  // (32 is added to have some space for split children without having to resize the list)
+  _intervals = GreedyIntervalList(num_virtual_regs() + 32);
+  // initialize all slots that are used by build_intervals
+  _intervals.at_put_grow(num_virtual_regs() - 1, NULL, NULL);
+
+  // create a list with all caller-save registers (cpu, fpu, xmm)
+  // when an instruction is a call, a temp range is created for all these registers
+  int num_caller_save_registers = 0;
+  int caller_save_registers[Greedy::nof_regs];
+
+  int i;
+  for (i = 0; i < FrameMap::nof_caller_save_cpu_regs(); i++) {
+    LIR_Opr opr = FrameMap::caller_save_cpu_reg_at(i);
+    assert(opr->is_valid() && opr->is_register(), "FrameMap should not return invalid operands");
+    assert(reg_numHi(opr) == -1, "missing addition of range for hi-register");
+    caller_save_registers[num_caller_save_registers++] = reg_num(opr);
+  }
+
+  // temp ranges for fpu registers are only created when the method has
+  // virtual fpu operands. Otherwise no allocation for fpu registers is
+  // perfomed and so the temp ranges would be useless
+  if (has_fpu_registers()) {
+#ifdef X86
+    if (UseSSE < 2) {
+#endif
+      for (i = 0; i < FrameMap::nof_caller_save_fpu_regs; i++) {
+        LIR_Opr opr = FrameMap::caller_save_fpu_reg_at(i);
+        assert(opr->is_valid() && opr->is_register(), "FrameMap should not return invalid operands");
+        assert(reg_numHi(opr) == -1, "missing addition of range for hi-register");
+        caller_save_registers[num_caller_save_registers++] = reg_num(opr);
+      }
+#ifdef X86
+    }
+    if (UseSSE > 0) {
+      for (i = 0; i < FrameMap::nof_caller_save_xmm_regs; i++) {
+        LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(i);
+        assert(opr->is_valid() && opr->is_register(), "FrameMap should not return invalid operands");
+        assert(reg_numHi(opr) == -1, "missing addition of range for hi-register");
+        caller_save_registers[num_caller_save_registers++] = reg_num(opr);
+      }
+    }
+#endif
+  }
+  assert(num_caller_save_registers <= Greedy::nof_regs, "out of bounds");
+
+
+  LIR_OpVisitState visitor;
+
+  // iterate all blocks in reverse order
+  for (i = block_count() - 1; i >= 0; i--) {
+    BlockBegin* block = block_at(i);
+    LIR_OpList* instructions = block->lir()->instructions_list();
+    int         block_from =   block->first_lir_instruction_id();
+    int         block_to =     block->last_lir_instruction_id();
+
+    assert(block_from == instructions->at(0)->id(), "must be");
+    assert(block_to   == instructions->at(instructions->length() - 1)->id(), "must be");
+
+    // Update intervals for registers live at the end of this block;
+    BitMap live = block->live_out();
+    int size = (int)live.size();
+    for (int number = (int)live.get_next_one_offset(0, size); number < size; number = (int)live.get_next_one_offset(number + 1, size)) {
+      assert(live.at(number), "should not stop here otherwise");
+      assert(number >= LIR_OprDesc::vreg_base, "fixed intervals must not be live on block bounds");
+      TRACE_GREEDY(2, tty->print_cr("live in %d to %d", number, block_to + 2));
+
+      add_use(number, block_from, block_to + 2, noUse, T_ILLEGAL);
+
+      // add special use positions for loop-end blocks when the
+      // interval is used anywhere inside this loop.  It's possible
+      // that the block was part of a non-natural loop, so it might
+      // have an invalid loop index.
+      if (block->is_set(BlockBegin::greedy_loop_end_flag) &&
+          block->loop_index() != -1 &&
+          is_interval_in_loop(number, block->loop_index())) {
+        interval_at(number)->add_use_pos(block_to + 1, loopEndMarker);
+      }
+    }
+
+    // iterate all instructions of the block in reverse order.
+    // skip the first instruction because it is always a label
+    // definitions of intervals are processed before uses
+    assert(visitor.no_operands(instructions->at(0)), "first operation must always be a label");
+    for (int j = instructions->length() - 1; j >= 1; j--) {
+      LIR_Op* op = instructions->at(j);
+      int op_id = op->id();
+
+      // visit operation to collect all operands
+      visitor.visit(op);
+
+      // add a temp range for each register if operation destroys caller-save registers
+      if (visitor.has_call()) {
+        for (int k = 0; k < num_caller_save_registers; k++) {
+          add_temp(caller_save_registers[k], op_id, noUse, T_ILLEGAL);
+        }
+        TRACE_GREEDY(4, tty->print_cr("operation destroys all caller-save registers"));
+      }
+
+      // Add any platform dependent temps
+      pd_add_temps(op);
+
+      // visit definitions (output and temp operands)
+      int k, n;
+      n = visitor.opr_count(LIR_OpVisitState::outputMode);
+      for (k = 0; k < n; k++) {
+        LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, k);
+        assert(opr->is_register(), "visitor should only return register operands");
+        add_def(opr, op_id, use_kind_of_output_operand(op, opr));
+      }
+
+      n = visitor.opr_count(LIR_OpVisitState::tempMode);
+      for (k = 0; k < n; k++) {
+        LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, k);
+        assert(opr->is_register(), "visitor should only return register operands");
+        add_temp(opr, op_id, mustHaveRegister);
+      }
+
+      // visit uses (input operands)
+      n = visitor.opr_count(LIR_OpVisitState::inputMode);
+      for (k = 0; k < n; k++) {
+        LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, k);
+        assert(opr->is_register(), "visitor should only return register operands");
+        add_use(opr, block_from, op_id, use_kind_of_input_operand(op, opr));
+      }
+
+      // Add uses of live locals from interpreter's point of view for proper
+      // debug information generation
+      // Treat these operands as temp values (if the life range is extended
+      // to a call site, the value would be in a register at the call otherwise)
+      n = visitor.info_count();
+      for (k = 0; k < n; k++) {
+        CodeEmitInfo* info = visitor.info_at(k);
+        ValueStack* stack = info->stack();
+        for_each_state_value(stack, value,
+          add_use(value, block_from, op_id + 1, noUse);
+        );
+      }
+
+      // special steps for some instructions (especially moves)
+      handle_method_arguments(op);
+      handle_doubleword_moves(op);
+      add_register_hints(op);
+
+    } // end of instruction iteration
+  } // end of block iteration
+
+
+  // add the range [0, 1[ to all fixed intervals
+  // -> the register allocator need not handle unhandled fixed intervals
+  for (int n = 0; n < Greedy::nof_regs; n++) {
+    GreedyInterval* interval = interval_at(n);
+    if (interval != NULL) {
+      interval->add_range(0, 1);
+    }
+  }
+}
+
+
+// ********** Phase 5: actual register allocation
+
+int Greedy::interval_cmp(GreedyInterval** a, GreedyInterval** b) {
+  if (*a != NULL) {
+    if (*b != NULL) {
+      return (*a)->from() - (*b)->from();
+    } else {
+      return -1;
+    }
+  } else {
+    if (*b != NULL) {
+      return 1;
+    } else {
+      return 0;
+    }
+  }
+}
+
+#ifndef PRODUCT
+bool Greedy::is_sorted(GreedyIntervalArray* intervals) {
+  int from = -1;
+  int i, j;
+  for (i = 0; i < intervals->length(); i ++) {
+    GreedyInterval* it = intervals->at(i);
+    if (it != NULL) {
+      if (from > it->from()) {
+        assert(false, "");
+        return false;
+      }
+      from = it->from();
+    }
+  }
+
+  // check in both directions if sorted list and unsorted list contain same intervals
+  for (i = 0; i < interval_count(); i++) {
+    if (interval_at(i) != NULL) {
+      int num_found = 0;
+      for (j = 0; j < intervals->length(); j++) {
+        if (interval_at(i) == intervals->at(j)) {
+          num_found++;
+        }
+      }
+      assert(num_found == 1, "lists do not contain same intervals");
+    }
+  }
+  for (j = 0; j < intervals->length(); j++) {
+    int num_found = 0;
+    for (i = 0; i < interval_count(); i++) {
+      if (interval_at(i) == intervals->at(j)) {
+        num_found++;
+      }
+    }
+    assert(num_found == 1, "lists do not contain same intervals");
+  }
+
+  return true;
+}
+#endif
+
+void Greedy::add_to_list(GreedyInterval** first, GreedyInterval** prev, GreedyInterval* interval) {
+  if (*prev != NULL) {
+    (*prev)->set_next(interval);
+  } else {
+    *first = interval;
+  }
+  *prev = interval;
+}
+
+void Greedy::create_unhandled_lists(GreedyInterval** list1, GreedyInterval** list2, bool (is_list1)(const GreedyInterval* i), bool (is_list2)(const GreedyInterval* i)) {
+  assert(is_sorted(_sorted_intervals), "interval list is not sorted");
+
+  *list1 = *list2 = GreedyInterval::end();
+
+  GreedyInterval* list1_prev = NULL;
+  GreedyInterval* list2_prev = NULL;
+  GreedyInterval* v;
+
+  const int n = _sorted_intervals->length();
+  for (int i = 0; i < n; i++) {
+    v = _sorted_intervals->at(i);
+    if (v == NULL) continue;
+
+    if (is_list1(v)) {
+      add_to_list(list1, &list1_prev, v);
+    } else if (is_list2 == NULL || is_list2(v)) {
+      add_to_list(list2, &list2_prev, v);
+    }
+  }
+
+  if (list1_prev != NULL) list1_prev->set_next(GreedyInterval::end());
+  if (list2_prev != NULL) list2_prev->set_next(GreedyInterval::end());
+
+  assert(list1_prev == NULL || list1_prev->next() == GreedyInterval::end(), "greedy list ends not with sentinel");
+  assert(list2_prev == NULL || list2_prev->next() == GreedyInterval::end(), "greedy list ends not with sentinel");
+}
+
+
+void Greedy::sort_intervals_before_allocation() {
+  TIME_GREEDY(timer_sort_intervals_before);
+
+  if (_needs_full_resort) {
+    // There is no known reason why this should occur but just in case...
+    assert(false, "should never occur");
+    // Re-sort existing interval list because an GreedyInterval::from() has changed
+    _sorted_intervals->sort(interval_cmp);
+    _needs_full_resort = false;
+  }
+
+  GreedyIntervalList* unsorted_list = &_intervals;
+  int unsorted_len = unsorted_list->length();
+  int sorted_len = 0;
+  int unsorted_idx;
+  int sorted_idx = 0;
+  int sorted_from_max = -1;
+
+  // calc number of items for sorted list (sorted list must not contain NULL values)
+  for (unsorted_idx = 0; unsorted_idx < unsorted_len; unsorted_idx++) {
+    if (unsorted_list->at(unsorted_idx) != NULL) {
+      sorted_len++;
+    }
+  }
+  GreedyIntervalArray* sorted_list = new GreedyIntervalArray(sorted_len);
+
+  // special sorting algorithm: the original interval-list is almost sorted,
+  // only some intervals are swapped. So this is much faster than a complete QuickSort
+  for (unsorted_idx = 0; unsorted_idx < unsorted_len; unsorted_idx++) {
+    GreedyInterval* cur_interval = unsorted_list->at(unsorted_idx);
+
+    if (cur_interval != NULL) {
+      int cur_from = cur_interval->from();
+
+      if (sorted_from_max <= cur_from) {
+        sorted_list->at_put(sorted_idx++, cur_interval);
+        sorted_from_max = cur_interval->from();
+      } else {
+        // the asumption that the intervals are already sorted failed,
+        // so this interval must be sorted in manually
+        int j;
+        for (j = sorted_idx - 1; j >= 0 && cur_from < sorted_list->at(j)->from(); j--) {
+          sorted_list->at_put(j + 1, sorted_list->at(j));
+        }
+        sorted_list->at_put(j + 1, cur_interval);
+        sorted_idx++;
+      }
+    }
+  }
+  _sorted_intervals = sorted_list;
+  assert(is_sorted(_sorted_intervals), "intervals unsorted");
+}
+
+void Greedy::sort_intervals_after_allocation() {
+  TIME_GREEDY(timer_sort_intervals_after);
+
+  if (_needs_full_resort) {
+    // Re-sort existing interval list because an GreedyInterval::from() has changed
+    _sorted_intervals->sort(interval_cmp);
+    _needs_full_resort = false;
+  }
+
+  GreedyIntervalArray* old_list      = _sorted_intervals;
+  GreedyIntervalList*  new_list      = _new_intervals_from_allocation;
+  int old_len = old_list->length();
+  int new_len = new_list->length();
+
+  if (new_len == 0) {
+    // no intervals have been added during allocation, so sorted list is already up to date
+    assert(is_sorted(_sorted_intervals), "intervals unsorted");
+    return;
+  }
+
+  // conventional sort-algorithm for new intervals
+  new_list->sort(interval_cmp);
+
+  // merge old and new list (both already sorted) into one combined list
+  GreedyIntervalArray* combined_list = new GreedyIntervalArray(old_len + new_len);
+  int old_idx = 0;
+  int new_idx = 0;
+
+  while (old_idx + new_idx < old_len + new_len) {
+    if (new_idx >= new_len || (old_idx < old_len && old_list->at(old_idx)->from() <= new_list->at(new_idx)->from())) {
+      combined_list->at_put(old_idx + new_idx, old_list->at(old_idx));
+      old_idx++;
+    } else {
+      combined_list->at_put(old_idx + new_idx, new_list->at(new_idx));
+      new_idx++;
+    }
+  }
+
+  _sorted_intervals = combined_list;
+  assert(is_sorted(_sorted_intervals), "intervals unsorted");
+}
+
+
+void Greedy::allocate_registers() {
+  TIME_GREEDY(timer_allocate_registers);
+
+  GreedyInterval* precolored_cpu_intervals, *not_precolored_cpu_intervals;
+  GreedyInterval* precolored_fpu_intervals, *not_precolored_fpu_intervals;
+
+  // allocate cpu registers
+  create_unhandled_lists(&precolored_cpu_intervals, &not_precolored_cpu_intervals,
+                         is_precolored_cpu_interval, is_virtual_cpu_interval);
+
+  // allocate fpu registers
+  create_unhandled_lists(&precolored_fpu_intervals, &not_precolored_fpu_intervals,
+                         is_precolored_fpu_interval, is_virtual_fpu_interval);
+
+  // the fpu interval allocation cannot be moved down below with the fpu section as
+  // the cpu_lsw.walk() changes interval positions.
+
+  GreedyWalker cpu_lsw(this, precolored_cpu_intervals, not_precolored_cpu_intervals);
+  cpu_lsw.walk();
+  cpu_lsw.finish_allocation();
+
+  if (has_fpu_registers()) {
+    GreedyWalker fpu_lsw(this, precolored_fpu_intervals, not_precolored_fpu_intervals);
+    fpu_lsw.walk();
+    fpu_lsw.finish_allocation();
+  }
+}
+
+
+// ********** Phase 6: resolve data flow
+// (insert moves at edges between blocks if intervals have been split)
+
+// wrapper for GreedyInterval::split_child_at_op_id that performs a bailout in product mode
+// instead of returning NULL
+GreedyInterval* Greedy::split_child_at_op_id(GreedyInterval* interval, int op_id, LIR_OpVisitState::OprMode mode) {
+  GreedyInterval* result = interval->split_child_at_op_id(op_id, mode);
+  if (result != NULL) {
+    return result;
+  }
+
+  assert(false, "must find an interval, but do a clean bailout in product mode");
+  result = new GreedyInterval(LIR_OprDesc::vreg_base);
+  result->assign_reg(0);
+  result->set_type(T_INT);
+  BAILOUT_("Greedy: interval is NULL", result);
+}
+
+
+GreedyInterval* Greedy::interval_at_block_begin(BlockBegin* block, int reg_num) {
+  assert(Greedy::nof_regs <= reg_num && reg_num < num_virtual_regs(), "register number out of bounds");
+  assert(interval_at(reg_num) != NULL, "no interval found");
+
+  return split_child_at_op_id(interval_at(reg_num), block->first_lir_instruction_id(), LIR_OpVisitState::outputMode);
+}
+
+GreedyInterval* Greedy::interval_at_block_end(BlockBegin* block, int reg_num) {
+  assert(Greedy::nof_regs <= reg_num && reg_num < num_virtual_regs(), "register number out of bounds");
+  assert(interval_at(reg_num) != NULL, "no interval found");
+
+  return split_child_at_op_id(interval_at(reg_num), block->last_lir_instruction_id() + 1, LIR_OpVisitState::outputMode);
+}
+
+GreedyInterval* Greedy::interval_at_op_id(int reg_num, int op_id) {
+  assert(Greedy::nof_regs <= reg_num && reg_num < num_virtual_regs(), "register number out of bounds");
+  assert(interval_at(reg_num) != NULL, "no interval found");
+
+  return split_child_at_op_id(interval_at(reg_num), op_id, LIR_OpVisitState::inputMode);
+}
+
+
+void Greedy::resolve_collect_mappings(BlockBegin* from_block, BlockBegin* to_block, GreedyMoveResolver &move_resolver) {
+  DEBUG_ONLY(move_resolver.check_empty());
+
+  const int num_regs = num_virtual_regs();
+  const int size = live_set_size();
+  const BitMap live_at_edge = to_block->live_in();
+
+  // visit all registers where the live_at_edge bit is set
+  for (int r = (int)live_at_edge.get_next_one_offset(0, size); r < size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
+    assert(r < num_regs, "live information set for not exisiting interval");
+    assert(from_block->live_out().at(r) && to_block->live_in().at(r), "interval not live at this edge");
+
+    GreedyInterval* from_interval = interval_at_block_end(from_block, r);
+    GreedyInterval* to_interval = interval_at_block_begin(to_block, r);
+
+    if (from_interval != to_interval && (from_interval->assigned_reg() != to_interval->assigned_reg() || from_interval->assigned_regHi() != to_interval->assigned_regHi())) {
+      // need to insert move instruction
+      move_resolver.add_mapping(from_interval, to_interval);
+    }
+  }
+}
+
+
+void Greedy::resolve_find_insert_pos(BlockBegin* from_block, BlockBegin* to_block, GreedyMoveResolver &move_resolver) {
+  if (from_block->number_of_sux() <= 1) {
+    TRACE_GREEDY(4, tty->print_cr("inserting moves at end of from_block B%d", from_block->block_id()));
+
+    LIR_OpList* instructions = from_block->lir()->instructions_list();
+    LIR_OpBranch* branch = instructions->last()->as_OpBranch();
+    if (branch != NULL) {
+      // insert moves before branch
+      assert(branch->cond() == lir_cond_always, "block does not end with an unconditional jump");
+      move_resolver.set_insert_position(from_block->lir(), instructions->length() - 2);
+    } else {
+      move_resolver.set_insert_position(from_block->lir(), instructions->length() - 1);
+    }
+
+  } else {
+    TRACE_GREEDY(4, tty->print_cr("inserting moves at beginning of to_block B%d", to_block->block_id()));
+#ifdef ASSERT
+    assert(from_block->lir()->instructions_list()->at(0)->as_OpLabel() != NULL, "block does not start with a label");
+
+    // because the number of predecessor edges matches the number of
+    // successor edges, blocks which are reached by switch statements
+    // may have be more than one predecessor but it will be guaranteed
+    // that all predecessors will be the same.
+    for (int i = 0; i < to_block->number_of_preds(); i++) {
+      assert(from_block == to_block->pred_at(i), "all critical edges must be broken");
+    }
+#endif
+
+    move_resolver.set_insert_position(to_block->lir(), 0);
+  }
+}
+
+
+// insert necessary moves (spilling or reloading) at edges between blocks if interval has been split
+void Greedy::resolve_data_flow() {
+  TIME_GREEDY(timer_resolve_data_flow);
+
+  int num_blocks = block_count();
+  GreedyMoveResolver move_resolver(this);
+  BitMap block_completed(num_blocks);  block_completed.clear();
+  BitMap already_resolved(num_blocks); already_resolved.clear();
+
+  int i;
+  for (i = 0; i < num_blocks; i++) {
+    BlockBegin* block = block_at(i);
+
+    // check if block has only one predecessor and only one successor
+    if (block->number_of_preds() == 1 && block->number_of_sux() == 1 && block->number_of_exception_handlers() == 0) {
+      LIR_OpList* instructions = block->lir()->instructions_list();
+      assert(instructions->at(0)->code() == lir_label, "block must start with label");
+      assert(instructions->last()->code() == lir_branch, "block with successors must end with branch");
+      assert(instructions->last()->as_OpBranch()->cond() == lir_cond_always, "block with successor must end with unconditional branch");
+
+      // check if block is empty (only label and branch)
+      if (instructions->length() == 2) {
+        BlockBegin* pred = block->pred_at(0);
+        BlockBegin* sux = block->sux_at(0);
+
+        // prevent optimization of two consecutive blocks
+        if (!block_completed.at(pred->greedy_number()) && !block_completed.at(sux->greedy_number())) {
+          TRACE_GREEDY(3, tty->print_cr("**** optimizing empty block B%d (pred: B%d, sux: B%d)", block->block_id(), pred->block_id(), sux->block_id()));
+          block_completed.set_bit(block->greedy_number());
+
+          // directly resolve between pred and sux (without looking at the empty block between)
+          resolve_collect_mappings(pred, sux, move_resolver);
+          if (move_resolver.has_mappings()) {
+            move_resolver.set_insert_position(block->lir(), 0);
+            move_resolver.resolve_and_append_moves();
+          }
+        }
+      }
+    }
+  }
+
+
+  for (i = 0; i < num_blocks; i++) {
+    if (!block_completed.at(i)) {
+      BlockBegin* from_block = block_at(i);
+      already_resolved.set_from(block_completed);
+
+      int num_sux = from_block->number_of_sux();
+      for (int s = 0; s < num_sux; s++) {
+        BlockBegin* to_block = from_block->sux_at(s);
+
+        // check for duplicate edges between the same blocks (can happen with switch blocks)
+        if (!already_resolved.at(to_block->greedy_number())) {
+          TRACE_GREEDY(3, tty->print_cr("**** processing edge between B%d and B%d", from_block->block_id(), to_block->block_id()));
+          already_resolved.set_bit(to_block->greedy_number());
+
+          // collect all intervals that have been split between from_block and to_block
+          resolve_collect_mappings(from_block, to_block, move_resolver);
+          if (move_resolver.has_mappings()) {
+            resolve_find_insert_pos(from_block, to_block, move_resolver);
+            move_resolver.resolve_and_append_moves();
+          }
+        }
+      }
+    }
+  }
+}
+
+
+void Greedy::resolve_exception_entry(BlockBegin* block, int reg_num, GreedyMoveResolver &move_resolver) {
+  if (interval_at(reg_num) == NULL) {
+    // if a phi function is never used, no interval is created -> ignore this
+    return;
+  }
+
+  GreedyInterval* interval = interval_at_block_begin(block, reg_num);
+  int reg = interval->assigned_reg();
+  int regHi = interval->assigned_regHi();
+
+  if ((reg < nof_regs && interval->always_in_memory()) ||
+      (use_fpu_stack_allocation() && reg >= pd_first_fpu_reg && reg <= pd_last_fpu_reg)) {
+    // the interval is split to get a short range that is located on the stack
+    // in the following two cases:
+    // * the interval started in memory (e.g. method parameter), but is currently in a register
+    //   this is an optimization for exception handling that reduces the number of moves that
+    //   are necessary for resolving the states when an exception uses this exception handler
+    // * the interval would be on the fpu stack at the begin of the exception handler
+    //   this is not allowed because of the complicated fpu stack handling on Intel
+
+    // range that will be spilled to memory
+    int from_op_id = block->first_lir_instruction_id();
+    int to_op_id = from_op_id + 1;  // short live range of length 1
+    assert(interval->from() <= from_op_id && interval->to() >= to_op_id,
+           "no split allowed between exception entry and first instruction");
+
+    if (interval->from() != from_op_id) {
+      // the part before from_op_id is unchanged
+      interval = interval->split(from_op_id);
+      interval->assign_reg(reg, regHi);
+      append_interval(interval);
+    } else {
+      _needs_full_resort = true;
+    }
+    assert(interval->from() == from_op_id, "must be true now");
+
+    GreedyInterval* spilled_part = interval;
+    if (interval->to() != to_op_id) {
+      // the part after to_op_id is unchanged
+      spilled_part = interval->split_from_start(to_op_id);
+      append_interval(spilled_part);
+      move_resolver.add_mapping(spilled_part, interval);
+    }
+    assign_spill_slot(spilled_part);
+
+    assert(spilled_part->from() == from_op_id && spilled_part->to() == to_op_id, "just checking");
+  }
+}
+
+void Greedy::resolve_exception_entry(BlockBegin* block, GreedyMoveResolver &move_resolver) {
+  assert(block->is_set(BlockBegin::exception_entry_flag), "should not call otherwise");
+  DEBUG_ONLY(move_resolver.check_empty());
+
+  // visit all registers where the live_in bit is set
+  int size = live_set_size();
+  for (int r = (int)block->live_in().get_next_one_offset(0, size); r < size; r = (int)block->live_in().get_next_one_offset(r + 1, size)) {
+    resolve_exception_entry(block, r, move_resolver);
+  }
+
+  // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
+  for_each_phi_fun(block, phi,
+    resolve_exception_entry(block, phi->operand()->vreg_number(), move_resolver)
+  );
+
+  if (move_resolver.has_mappings()) {
+    // insert moves after first instruction
+    move_resolver.set_insert_position(block->lir(), 0);
+    move_resolver.resolve_and_append_moves();
+  }
+}
+
+
+void Greedy::resolve_exception_edge(XHandler* handler, int throwing_op_id, int reg_num, Phi* phi, GreedyMoveResolver &move_resolver) {
+  if (interval_at(reg_num) == NULL) {
+    // if a phi function is never used, no interval is created -> ignore this
+    return;
+  }
+
+  // the computation of to_interval is equal to resolve_collect_mappings,
+  // but from_interval is more complicated because of phi functions
+  BlockBegin* to_block = handler->entry_block();
+  GreedyInterval* to_interval = interval_at_block_begin(to_block, reg_num);
+
+  if (phi != NULL) {
+    // phi function of the exception entry block
+    // no moves are created for this phi function in the LIR_Generator, so the
+    // interval at the throwing instruction must be searched using the operands
+    // of the phi function
+    Value from_value = phi->operand_at(handler->phi_operand());
+
+    // with phi functions it can happen that the same from_value is used in
+    // multiple mappings, so notify move-resolver that this is allowed
+    move_resolver.set_multiple_reads_allowed();
+
+    Constant* con = from_value->as_Constant();
+    if (con != NULL && !con->is_pinned()) {
+      // unpinned constants may have no register, so add mapping from constant to interval
+      move_resolver.add_mapping(LIR_OprFact::value_type(con->type()), to_interval);
+    } else {
+      // search split child at the throwing op_id
+      GreedyInterval* from_interval = interval_at_op_id(from_value->operand()->vreg_number(), throwing_op_id);
+      move_resolver.add_mapping(from_interval, to_interval);
+    }
+
+  } else {
+    // no phi function, so use reg_num also for from_interval
+    // search split child at the throwing op_id
+    GreedyInterval* from_interval = interval_at_op_id(reg_num, throwing_op_id);
+    if (from_interval != to_interval) {
+      // optimization to reduce number of moves: when to_interval is on stack and
+      // the stack slot is known to be always correct, then no move is necessary
+      if (!from_interval->always_in_memory() || from_interval->canonical_spill_slot() != to_interval->assigned_reg()) {
+        move_resolver.add_mapping(from_interval, to_interval);
+      }
+    }
+  }
+}
+
+void Greedy::resolve_exception_edge(XHandler* handler, int throwing_op_id, GreedyMoveResolver &move_resolver) {
+  TRACE_GREEDY(4, tty->print_cr("resolving exception handler B%d: throwing_op_id=%d", handler->entry_block()->block_id(), throwing_op_id));
+
+  DEBUG_ONLY(move_resolver.check_empty());
+  assert(handler->lir_op_id() == -1, "already processed this xhandler");
+  DEBUG_ONLY(handler->set_lir_op_id(throwing_op_id));
+  assert(handler->entry_code() == NULL, "code already present");
+
+  // visit all registers where the live_in bit is set
+  BlockBegin* block = handler->entry_block();
+  int size = live_set_size();
+  for (int r = (int)block->live_in().get_next_one_offset(0, size); r < size; r = (int)block->live_in().get_next_one_offset(r + 1, size)) {
+    resolve_exception_edge(handler, throwing_op_id, r, NULL, move_resolver);
+  }
+
+  // the live_in bits are not set for phi functions of the xhandler entry, so iterate them separately
+  for_each_phi_fun(block, phi,
+    resolve_exception_edge(handler, throwing_op_id, phi->operand()->vreg_number(), phi, move_resolver)
+  );
+
+  if (move_resolver.has_mappings()) {
+    LIR_List* entry_code = new LIR_List(compilation());
+    move_resolver.set_insert_position(entry_code, 0);
+    move_resolver.resolve_and_append_moves();
+
+    entry_code->jump(handler->entry_block());
+    handler->set_entry_code(entry_code);
+  }
+}
+
+
+void Greedy::resolve_exception_handlers() {
+  GreedyMoveResolver move_resolver(this);
+  LIR_OpVisitState visitor;
+  int num_blocks = block_count();
+
+  int i;
+  for (i = 0; i < num_blocks; i++) {
+    BlockBegin* block = block_at(i);
+    if (block->is_set(BlockBegin::exception_entry_flag)) {
+      resolve_exception_entry(block, move_resolver);
+    }
+  }
+
+  for (i = 0; i < num_blocks; i++) {
+    BlockBegin* block = block_at(i);
+    LIR_List* ops = block->lir();
+    int num_ops = ops->length();
+
+    // iterate all instructions of the block. skip the first because it is always a label
+    assert(visitor.no_operands(ops->at(0)), "first operation must always be a label");
+    for (int j = 1; j < num_ops; j++) {
+      LIR_Op* op = ops->at(j);
+      int op_id = op->id();
+
+      if (op_id != -1 && has_info(op_id)) {
+        // visit operation to collect all operands
+        visitor.visit(op);
+        assert(visitor.info_count() > 0, "should not visit otherwise");
+
+        XHandlers* xhandlers = visitor.all_xhandler();
+        int n = xhandlers->length();
+        for (int k = 0; k < n; k++) {
+          resolve_exception_edge(xhandlers->handler_at(k), op_id, move_resolver);
+        }
+
+#ifdef ASSERT
+      } else {
+        visitor.visit(op);
+        assert(visitor.all_xhandler()->length() == 0, "missed exception handler");
+#endif
+      }
+    }
+  }
+}
+
+
+// ********** Phase 7: assign register numbers back to LIR
+// (includes computation of debug information and oop maps)
+
+VMReg Greedy::vm_reg_for_interval(GreedyInterval* interval) {
+  VMReg reg = interval->cached_vm_reg();
+  if (!reg->is_valid() ) {
+    reg = vm_reg_for_operand(operand_for_interval(interval));
+    interval->set_cached_vm_reg(reg);
+  }
+  assert(reg == vm_reg_for_operand(operand_for_interval(interval)), "wrong cached value");
+  return reg;
+}
+
+VMReg Greedy::vm_reg_for_operand(LIR_Opr opr) {
+  assert(opr->is_oop(), "currently only implemented for oop operands");
+  return frame_map()->regname(opr);
+}
+
+
+LIR_Opr Greedy::operand_for_interval(GreedyInterval* interval) {
+  LIR_Opr opr = interval->cached_opr();
+  if (opr->is_illegal()) {
+    opr = calc_operand_for_interval(interval);
+    interval->set_cached_opr(opr);
+  }
+
+  assert(opr == calc_operand_for_interval(interval), "wrong cached value");
+  return opr;
+}
+
+LIR_Opr Greedy::calc_operand_for_interval(const GreedyInterval* interval) {
+  int assigned_reg = interval->assigned_reg();
+  BasicType type = interval->type();
+
+  if (assigned_reg >= nof_regs) {
+    // stack slot
+    assert(interval->assigned_regHi() == any_reg, "must not have hi register");
+    return LIR_OprFact::stack(assigned_reg - nof_regs, type);
+
+  } else {
+    // register
+    switch (type) {
+      case T_OBJECT: {
+        assert(assigned_reg >= pd_first_cpu_reg && assigned_reg <= pd_last_cpu_reg, "no cpu register");
+        assert(interval->assigned_regHi() == any_reg, "must not have hi register");
+        return LIR_OprFact::single_cpu_oop(assigned_reg);
+      }
+
+      case T_ADDRESS: {
+        assert(assigned_reg >= pd_first_cpu_reg && assigned_reg <= pd_last_cpu_reg, "no cpu register");
+        assert(interval->assigned_regHi() == any_reg, "must not have hi register");
+        return LIR_OprFact::single_cpu_address(assigned_reg);
+      }
+
+      case T_METADATA: {
+        assert(assigned_reg >= pd_first_cpu_reg && assigned_reg <= pd_last_cpu_reg, "no cpu register");
+        assert(interval->assigned_regHi() == any_reg, "must not have hi register");
+        return LIR_OprFact::single_cpu_metadata(assigned_reg);
+      }
+
+#ifdef __SOFTFP__
+      case T_FLOAT:  // fall through
+#endif // __SOFTFP__
+      case T_INT: {
+        assert(assigned_reg >= pd_first_cpu_reg && assigned_reg <= pd_last_cpu_reg, "no cpu register");
+        assert(interval->assigned_regHi() == any_reg, "must not have hi register");
+        return LIR_OprFact::single_cpu(assigned_reg);
+      }
+
+#ifdef __SOFTFP__
+      case T_DOUBLE:  // fall through
+#endif // __SOFTFP__
+      case T_LONG: {
+        int assigned_regHi = interval->assigned_regHi();
+        assert(assigned_reg >= pd_first_cpu_reg && assigned_reg <= pd_last_cpu_reg, "no cpu register");
+        assert(num_physical_regs(T_LONG) == 1 ||
+               (assigned_regHi >= pd_first_cpu_reg && assigned_regHi <= pd_last_cpu_reg), "no cpu register");
+
+        assert(assigned_reg != assigned_regHi, "invalid allocation");
+        assert(num_physical_regs(T_LONG) == 1 || assigned_reg < assigned_regHi,
+               "register numbers must be sorted (ensure that e.g. a move from eax,ebx to ebx,eax can not occur)");
+        assert((assigned_regHi != any_reg) ^ (num_physical_regs(T_LONG) == 1), "must be match");
+        if (requires_adjacent_regs(T_LONG)) {
+          assert(assigned_reg % 2 == 0 && assigned_reg + 1 == assigned_regHi, "must be sequential and even");
+        }
+
+#ifdef _LP64
+        return LIR_OprFact::double_cpu(assigned_reg, assigned_reg);
+#else
+#if defined(SPARC) || defined(PPC)
+        return LIR_OprFact::double_cpu(assigned_regHi, assigned_reg);
+#else
+        return LIR_OprFact::double_cpu(assigned_reg, assigned_regHi);
+#endif // SPARC
+#endif // LP64
+      }
+
+#ifndef __SOFTFP__
+      case T_FLOAT: {
+#ifdef X86
+        if (UseSSE >= 1) {
+          assert(assigned_reg >= pd_first_xmm_reg && assigned_reg <= pd_last_xmm_reg, "no xmm register");
+          assert(interval->assigned_regHi() == any_reg, "must not have hi register");
+          return LIR_OprFact::single_xmm(assigned_reg - pd_first_xmm_reg);
+        }
+#endif
+
+        assert(assigned_reg >= pd_first_fpu_reg && assigned_reg <= pd_last_fpu_reg, "no fpu register");
+        assert(interval->assigned_regHi() == any_reg, "must not have hi register");
+        return LIR_OprFact::single_fpu(assigned_reg - pd_first_fpu_reg);
+      }
+
+      case T_DOUBLE: {
+#ifdef X86
+        if (UseSSE >= 2) {
+          assert(assigned_reg >= pd_first_xmm_reg && assigned_reg <= pd_last_xmm_reg, "no xmm register");
+          assert(interval->assigned_regHi() == any_reg, "must not have hi register (double xmm values are stored in one register)");
+          return LIR_OprFact::double_xmm(assigned_reg - pd_first_xmm_reg);
+        }
+#endif
+
+#ifdef SPARC
+        assert(assigned_reg >= pd_first_fpu_reg && assigned_reg <= pd_last_fpu_reg, "no fpu register");
+        assert(interval->assigned_regHi() >= pd_first_fpu_reg && interval->assigned_regHi() <= pd_last_fpu_reg, "no fpu register");
+        assert(assigned_reg % 2 == 0 && assigned_reg + 1 == interval->assigned_regHi(), "must be sequential and even");
+        LIR_Opr result = LIR_OprFact::double_fpu(interval->assigned_regHi() - pd_first_fpu_reg, assigned_reg - pd_first_fpu_reg);
+#elif defined(ARM32)
+        assert(assigned_reg >= pd_first_fpu_reg && assigned_reg <= pd_last_fpu_reg, "no fpu register");
+        assert(interval->assigned_regHi() >= pd_first_fpu_reg && interval->assigned_regHi() <= pd_last_fpu_reg, "no fpu register");
+        assert(assigned_reg % 2 == 0 && assigned_reg + 1 == interval->assigned_regHi(), "must be sequential and even");
+        LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg, interval->assigned_regHi() - pd_first_fpu_reg);
+#else
+        assert(assigned_reg >= pd_first_fpu_reg && assigned_reg <= pd_last_fpu_reg, "no fpu register");
+        assert(interval->assigned_regHi() == any_reg, "must not have hi register (double fpu values are stored in one register on Intel)");
+        LIR_Opr result = LIR_OprFact::double_fpu(assigned_reg - pd_first_fpu_reg);
+#endif
+        return result;
+      }
+#endif // __SOFTFP__
+
+      default: {
+        ShouldNotReachHere();
+        return LIR_OprFact::illegalOpr;
+      }
+    }
+  }
+}
+
+LIR_Opr Greedy::canonical_spill_opr(GreedyInterval* interval) {
+  assert(interval->canonical_spill_slot() >= nof_regs, "canonical spill slot not set");
+  return LIR_OprFact::stack(interval->canonical_spill_slot() - nof_regs, interval->type());
+}
+
+LIR_Opr Greedy::color_lir_opr(LIR_Opr opr, int op_id, LIR_OpVisitState::OprMode mode) {
+  assert(opr->is_virtual(), "should not call this otherwise");
+
+  GreedyInterval* interval = interval_at(opr->vreg_number());
+  assert(interval != NULL, "interval must exist");
+
+  if (op_id != -1) {
+#ifdef ASSERT
+    BlockBegin* block = block_of_op_with_id(op_id);
+    if (block->number_of_sux() <= 1 && op_id == block->last_lir_instruction_id()) {
+      // check if spill moves could have been appended at the end of this block, but
+      // before the branch instruction. So the split child information for this branch would
+      // be incorrect.
+      LIR_OpBranch* branch = block->lir()->instructions_list()->last()->as_OpBranch();
+      if (branch != NULL) {
+        if (block->live_out().at(opr->vreg_number())) {
+          assert(branch->cond() == lir_cond_always, "block does not end with an unconditional jump");
+          assert(false, "can't get split child for the last branch of a block because the information would be incorrect (moves are inserted before the branch in resolve_data_flow)");
+        }
+      }
+    }
+#endif
+
+    // operands are not changed when an interval is split during allocation,
+    // so search the right interval here
+    interval = split_child_at_op_id(interval, op_id, mode);
+  }
+
+  LIR_Opr res = operand_for_interval(interval);
+
+#ifdef X86
+  // new semantic for is_last_use: not only set on definite end of interval,
+  // but also before hole
+  // This may still miss some cases (e.g. for dead values), but it is not necessary that the
+  // last use information is completely correct
+  // information is only needed for fpu stack allocation
+  if (res->is_fpu_register()) {
+    if (opr->is_last_use() || op_id == interval->to() || (op_id != -1 && interval->has_hole_between(op_id, op_id + 1))) {
+      assert(op_id == -1 || !is_block_begin(op_id), "holes at begin of block may also result from control flow");
+      res = res->make_last_use();
+    }
+  }
+#endif
+
+  assert(!gen()->is_vreg_flag_set(opr->vreg_number(), LIRGenerator::callee_saved) || !FrameMap::is_caller_save_register(res), "bad allocation");
+
+  return res;
+}
+
+
+#ifdef ASSERT
+// some methods used to check correctness of debug information
+
+void greedy_assert_no_register_values(GrowableArray<ScopeValue*>* values) {
+  if (values == NULL) {
+    return;
+  }
+
+  for (int i = 0; i < values->length(); i++) {
+    ScopeValue* value = values->at(i);
+
+    if (value->is_location()) {
+      Location location = ((LocationValue*)value)->location();
+      assert(location.where() == Location::on_stack, "value is in register");
+    }
+  }
+}
+
+void greedy_assert_no_register_values(GrowableArray<MonitorValue*>* values) {
+  if (values == NULL) {
+    return;
+  }
+
+  for (int i = 0; i < values->length(); i++) {
+    MonitorValue* value = values->at(i);
+
+    if (value->owner()->is_location()) {
+      Location location = ((LocationValue*)value->owner())->location();
+      assert(location.where() == Location::on_stack, "owner is in register");
+    }
+    assert(value->basic_lock().where() == Location::on_stack, "basic_lock is in register");
+  }
+}
+
+void greedy_assert_equal(Location l1, Location l2) {
+  assert(l1.where() == l2.where() && l1.type() == l2.type() && l1.offset() == l2.offset(), "");
+}
+
+void greedy_assert_equal(ScopeValue* v1, ScopeValue* v2) {
+  if (v1->is_location()) {
+    assert(v2->is_location(), "");
+    greedy_assert_equal(((LocationValue*)v1)->location(), ((LocationValue*)v2)->location());
+  } else if (v1->is_constant_int()) {
+    assert(v2->is_constant_int(), "");
+    assert(((ConstantIntValue*)v1)->value() == ((ConstantIntValue*)v2)->value(), "");
+  } else if (v1->is_constant_double()) {
+    assert(v2->is_constant_double(), "");
+    assert(((ConstantDoubleValue*)v1)->value() == ((ConstantDoubleValue*)v2)->value(), "");
+  } else if (v1->is_constant_long()) {
+    assert(v2->is_constant_long(), "");
+    assert(((ConstantLongValue*)v1)->value() == ((ConstantLongValue*)v2)->value(), "");
+  } else if (v1->is_constant_oop()) {
+    assert(v2->is_constant_oop(), "");
+    assert(((ConstantOopWriteValue*)v1)->value() == ((ConstantOopWriteValue*)v2)->value(), "");
+  } else {
+    ShouldNotReachHere();
+  }
+}
+
+void greedy_assert_equal(MonitorValue* m1, MonitorValue* m2) {
+  greedy_assert_equal(m1->owner(), m2->owner());
+  greedy_assert_equal(m1->basic_lock(), m2->basic_lock());
+}
+
+void greedy_assert_equal(IRScopeDebugInfo* d1, IRScopeDebugInfo* d2) {
+  assert(d1->scope() == d2->scope(), "not equal");
+  assert(d1->bci() == d2->bci(), "not equal");
+
+  if (d1->locals() != NULL) {
+    assert(d1->locals() != NULL && d2->locals() != NULL, "not equal");
+    assert(d1->locals()->length() == d2->locals()->length(), "not equal");
+    for (int i = 0; i < d1->locals()->length(); i++) {
+      greedy_assert_equal(d1->locals()->at(i), d2->locals()->at(i));
+    }
+  } else {
+    assert(d1->locals() == NULL && d2->locals() == NULL, "not equal");
+  }
+
+  if (d1->expressions() != NULL) {
+    assert(d1->expressions() != NULL && d2->expressions() != NULL, "not equal");
+    assert(d1->expressions()->length() == d2->expressions()->length(), "not equal");
+    for (int i = 0; i < d1->expressions()->length(); i++) {
+      greedy_assert_equal(d1->expressions()->at(i), d2->expressions()->at(i));
+    }
+  } else {
+    assert(d1->expressions() == NULL && d2->expressions() == NULL, "not equal");
+  }
+
+  if (d1->monitors() != NULL) {
+    assert(d1->monitors() != NULL && d2->monitors() != NULL, "not equal");
+    assert(d1->monitors()->length() == d2->monitors()->length(), "not equal");
+    for (int i = 0; i < d1->monitors()->length(); i++) {
+      greedy_assert_equal(d1->monitors()->at(i), d2->monitors()->at(i));
+    }
+  } else {
+    assert(d1->monitors() == NULL && d2->monitors() == NULL, "not equal");
+  }
+
+  if (d1->caller() != NULL) {
+    assert(d1->caller() != NULL && d2->caller() != NULL, "not equal");
+    greedy_assert_equal(d1->caller(), d2->caller());
+  } else {
+    assert(d1->caller() == NULL && d2->caller() == NULL, "not equal");
+  }
+}
+
+void greedy_check_stack_depth(CodeEmitInfo* info, int stack_end) {
+  if (info->stack()->bci() != SynchronizationEntryBCI && !info->scope()->method()->is_native()) {
+    Bytecodes::Code code = info->scope()->method()->java_code_at_bci(info->stack()->bci());
+    switch (code) {
+      case Bytecodes::_ifnull    : // fall through
+      case Bytecodes::_ifnonnull : // fall through
+      case Bytecodes::_ifeq      : // fall through
+      case Bytecodes::_ifne      : // fall through
+      case Bytecodes::_iflt      : // fall through
+      case Bytecodes::_ifge      : // fall through
+      case Bytecodes::_ifgt      : // fall through
+      case Bytecodes::_ifle      : // fall through
+      case Bytecodes::_if_icmpeq : // fall through
+      case Bytecodes::_if_icmpne : // fall through
+      case Bytecodes::_if_icmplt : // fall through
+      case Bytecodes::_if_icmpge : // fall through
+      case Bytecodes::_if_icmpgt : // fall through
+      case Bytecodes::_if_icmple : // fall through
+      case Bytecodes::_if_acmpeq : // fall through
+      case Bytecodes::_if_acmpne :
+        assert(stack_end >= -Bytecodes::depth(code), "must have non-empty expression stack at if bytecode");
+        break;
+    }
+  }
+}
+
+#endif // ASSERT
+
+
+GreedyIntervalWalker* Greedy::init_compute_oop_maps() {
+  // setup lists of potential oops for walking
+  GreedyInterval* oop_intervals;
+  GreedyInterval* non_oop_intervals;
+
+  create_unhandled_lists(&oop_intervals, &non_oop_intervals, is_oop_interval, NULL);
+
+  // intervals that have no oops inside need not to be processed
+  // to ensure a walking until the last instruction id, add a dummy interval
+  // with a high operation id
+  non_oop_intervals = new GreedyInterval(any_reg);
+  non_oop_intervals->add_range(max_jint - 2, max_jint - 1);
+
+  return new GreedyIntervalWalker(this, oop_intervals, non_oop_intervals);
+}
+
+
+OopMap* Greedy::compute_oop_map(GreedyIntervalWalker* iw, LIR_Op* op, CodeEmitInfo* info, bool is_call_site) {
+  TRACE_GREEDY(3, tty->print_cr("creating oop map at op_id %d", op->id()));
+
+  // walk before the current operation -> intervals that start at
+  // the operation (= output operands of the operation) are not
+  // included in the oop map
+  iw->walk_before(op->id());
+
+  int frame_size = frame_map()->framesize();
+  int arg_count = frame_map()->oop_map_arg_count();
+  OopMap* map = new OopMap(frame_size, arg_count);
+
+  // Iterate through active intervals
+  for (GreedyInterval* interval = iw->active_first(fixedKind); interval != GreedyInterval::end(); interval = interval->next()) {
+    int assigned_reg = interval->assigned_reg();
+
+    assert(interval->current_from() <= op->id() && op->id() <= interval->current_to(), "interval should not be active otherwise");
+    assert(interval->assigned_regHi() == any_reg, "oop must be single word");
+    assert(interval->reg_num() >= LIR_OprDesc::vreg_base, "fixed interval found");
+
+    // Check if this range covers the instruction. GreedyIntervals that
+    // start or end at the current operation are not included in the
+    // oop map, except in the case of patching moves.  For patching
+    // moves, any intervals which end at this instruction are included
+    // in the oop map since we may safepoint while doing the patch
+    // before we've consumed the inputs.
+    if (op->is_patching() || op->id() < interval->current_to()) {
+
+      // caller-save registers must not be included into oop-maps at calls
+      assert(!is_call_site || assigned_reg >= nof_regs || !is_caller_save(assigned_reg), "interval is in a caller-save register at a call -> register will be overwritten");
+
+      VMReg name = vm_reg_for_interval(interval);
+      set_oop(map, name);
+
+      // Spill optimization: when the stack value is guaranteed to be always correct,
+      // then it must be added to the oop map even if the interval is currently in a register
+      if (interval->always_in_memory() &&
+          op->id() > interval->spill_definition_pos() &&
+          interval->assigned_reg() != interval->canonical_spill_slot()) {
+        assert(interval->spill_definition_pos() > 0, "position not set correctly");
+        assert(interval->canonical_spill_slot() >= Greedy::nof_regs, "no spill slot assigned");
+        assert(interval->assigned_reg() < Greedy::nof_regs, "interval is on stack, so stack slot is registered twice");
+
+        set_oop(map, frame_map()->slot_regname(interval->canonical_spill_slot() - Greedy::nof_regs));
+      }
+    }
+  }
+
+  // add oops from lock stack
+  assert(info->stack() != NULL, "CodeEmitInfo must always have a stack");
+  int locks_count = info->stack()->total_locks_size();
+  for (int i = 0; i < locks_count; i++) {
+    set_oop(map, frame_map()->monitor_object_regname(i));
+  }
+
+  return map;
+}
+
+
+void Greedy::compute_oop_map(GreedyIntervalWalker* iw, const LIR_OpVisitState &visitor, LIR_Op* op) {
+  assert(visitor.info_count() > 0, "no oop map needed");
+
+  // compute oop_map only for first CodeEmitInfo
+  // because it is (in most cases) equal for all other infos of the same operation
+  CodeEmitInfo* first_info = visitor.info_at(0);
+  OopMap* first_oop_map = compute_oop_map(iw, op, first_info, visitor.has_call());
+
+  for (int i = 0; i < visitor.info_count(); i++) {
+    CodeEmitInfo* info = visitor.info_at(i);
+    OopMap* oop_map = first_oop_map;
+
+    // compute worst case interpreter size in case of a deoptimization
+    _compilation->update_interpreter_frame_size(info->interpreter_frame_size());
+
+    if (info->stack()->locks_size() != first_info->stack()->locks_size()) {
+      // this info has a different number of locks then the precomputed oop map
+      // (possible for lock and unlock instructions) -> compute oop map with
+      // correct lock information
+      oop_map = compute_oop_map(iw, op, info, visitor.has_call());
+    }
+
+    if (info->_oop_map == NULL) {
+      info->_oop_map = oop_map;
+    } else {
+      // a CodeEmitInfo can not be shared between different LIR-instructions
+      // because interval splitting can occur anywhere between two instructions
+      // and so the oop maps must be different
+      // -> check if the already set oop_map is exactly the one calculated for this operation
+      assert(info->_oop_map == oop_map, "same CodeEmitInfo used for multiple LIR instructions");
+    }
+  }
+}
+
+
+// frequently used constants
+// Allocate them with new so they are never destroyed (otherwise, a
+// forced exit could destroy these objects while they are still in
+// use).
+ConstantOopWriteValue* Greedy::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantOopWriteValue(NULL);
+ConstantIntValue*      Greedy::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(-1);
+ConstantIntValue*      Greedy::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(0);
+ConstantIntValue*      Greedy::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(1);
+ConstantIntValue*      Greedy::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtCompiler) ConstantIntValue(2);
+LocationValue*         _greedy_illegal_value = new (ResourceObj::C_HEAP, mtCompiler) LocationValue(Location());
+
+void Greedy::init_compute_debug_info() {
+  // cache for frequently used scope values
+  // (cpu registers and stack slots)
+  _scope_value_cache = GreedyScopeValueArray((Greedy::nof_cpu_regs + frame_map()->argcount() + max_spills()) * 2, NULL);
+}
+
+MonitorValue* Greedy::location_for_monitor_index(int monitor_index) {
+  Location loc;
+  if (!frame_map()->location_for_monitor_object(monitor_index, &loc)) {
+    bailout("too large frame");
+  }
+  ScopeValue* object_scope_value = new LocationValue(loc);
+
+  if (!frame_map()->location_for_monitor_lock(monitor_index, &loc)) {
+    bailout("too large frame");
+  }
+  return new MonitorValue(object_scope_value, loc);
+}
+
+LocationValue* Greedy::location_for_name(int name, Location::Type loc_type) {
+  Location loc;
+  if (!frame_map()->locations_for_slot(name, loc_type, &loc)) {
+    bailout("too large frame");
+  }
+  return new LocationValue(loc);
+}
+
+
+int Greedy::append_scope_value_for_constant(LIR_Opr opr, GrowableArray<ScopeValue*>* scope_values) {
+  assert(opr->is_constant(), "should not be called otherwise");
+
+  LIR_Const* c = opr->as_constant_ptr();
+  BasicType t = c->type();
+  switch (t) {
+    case T_OBJECT: {
+      jobject value = c->as_jobject();
+      if (value == NULL) {
+        scope_values->append(_oop_null_scope_value);
+      } else {
+        scope_values->append(new ConstantOopWriteValue(c->as_jobject()));
+      }
+      return 1;
+    }
+
+    case T_INT: // fall through
+    case T_FLOAT: {
+      int value = c->as_jint_bits();
+      switch (value) {
+        case -1: scope_values->append(_int_m1_scope_value); break;
+        case 0:  scope_values->append(_int_0_scope_value); break;
+        case 1:  scope_values->append(_int_1_scope_value); break;
+        case 2:  scope_values->append(_int_2_scope_value); break;
+        default: scope_values->append(new ConstantIntValue(c->as_jint_bits())); break;
+      }
+      return 1;
+    }
+
+    case T_LONG: // fall through
+    case T_DOUBLE: {
+#ifdef _LP64
+      scope_values->append(_int_0_scope_value);
+      scope_values->append(new ConstantLongValue(c->as_jlong_bits()));
+#else
+      if (hi_word_offset_in_bytes > lo_word_offset_in_bytes) {
+        scope_values->append(new ConstantIntValue(c->as_jint_hi_bits()));
+        scope_values->append(new ConstantIntValue(c->as_jint_lo_bits()));
+      } else {
+        scope_values->append(new ConstantIntValue(c->as_jint_lo_bits()));
+        scope_values->append(new ConstantIntValue(c->as_jint_hi_bits()));
+      }
+#endif
+      return 2;
+    }
+
+    case T_ADDRESS: {
+#ifdef _LP64
+      scope_values->append(new ConstantLongValue(c->as_jint()));
+#else
+      scope_values->append(new ConstantIntValue(c->as_jint()));
+#endif
+      return 1;
+    }
+
+    default:
+      ShouldNotReachHere();
+      return -1;
+  }
+}
+
+int Greedy::append_scope_value_for_operand(LIR_Opr opr, GrowableArray<ScopeValue*>* scope_values) {
+  if (opr->is_single_stack()) {
+    int stack_idx = opr->single_stack_ix();
+    bool is_oop = opr->is_oop_register();
+    int cache_idx = (stack_idx + Greedy::nof_cpu_regs) * 2 + (is_oop ? 1 : 0);
+
+    ScopeValue* sv = _scope_value_cache.at(cache_idx);
+    if (sv == NULL) {
+      Location::Type loc_type = is_oop ? Location::oop : Location::normal;
+      sv = location_for_name(stack_idx, loc_type);
+      _scope_value_cache.at_put(cache_idx, sv);
+    }
+
+    // check if cached value is correct
+    DEBUG_ONLY(greedy_assert_equal(sv, location_for_name(stack_idx, is_oop ? Location::oop : Location::normal)));
+
+    scope_values->append(sv);
+    return 1;
+
+  } else if (opr->is_single_cpu()) {
+    bool is_oop = opr->is_oop_register();
+    int cache_idx = opr->cpu_regnr() * 2 + (is_oop ? 1 : 0);
+    Location::Type int_loc_type = NOT_LP64(Location::normal) LP64_ONLY(Location::int_in_long);
+
+    ScopeValue* sv = _scope_value_cache.at(cache_idx);
+    if (sv == NULL) {
+      Location::Type loc_type = is_oop ? Location::oop : int_loc_type;
+      VMReg rname = frame_map()->regname(opr);
+      sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
+      _scope_value_cache.at_put(cache_idx, sv);
+    }
+
+    // check if cached value is correct
+    DEBUG_ONLY(greedy_assert_equal(sv, new LocationValue(Location::new_reg_loc(is_oop ? Location::oop : int_loc_type, frame_map()->regname(opr)))));
+
+    scope_values->append(sv);
+    return 1;
+
+#ifdef X86
+  } else if (opr->is_single_xmm()) {
+    VMReg rname = opr->as_xmm_float_reg()->as_VMReg();
+    LocationValue* sv = new LocationValue(Location::new_reg_loc(Location::normal, rname));
+
+    scope_values->append(sv);
+    return 1;
+#endif
+
+  } else if (opr->is_single_fpu()) {
+#ifdef X86
+    // the exact location of fpu stack values is only known
+    // during fpu stack allocation, so the stack allocator object
+    // must be present
+    assert(use_fpu_stack_allocation(), "should not have float stack values without fpu stack allocation (all floats must be SSE2)");
+    assert(_fpu_stack_allocator != NULL, "must be present");
+    opr = _fpu_stack_allocator->to_fpu_stack(opr);
+#endif
+
+    Location::Type loc_type = float_saved_as_double ? Location::float_in_dbl : Location::normal;
+    VMReg rname = frame_map()->fpu_regname(opr->fpu_regnr());
+#ifndef __SOFTFP__
+#ifndef VM_LITTLE_ENDIAN
+    if (! float_saved_as_double) {
+      // On big endian system, we may have an issue if float registers use only
+      // the low half of the (same) double registers.
+      // Both the float and the double could have the same regnr but would correspond
+      // to two different addresses once saved.
+
+      // get next safely (no assertion checks)
+      VMReg next = VMRegImpl::as_VMReg(1+rname->value());
+      if (next->is_reg() &&
+          (next->as_FloatRegister() == rname->as_FloatRegister())) {
+        // the back-end does use the same numbering for the double and the float
+        rname = next; // VMReg for the low bits, e.g. the real VMReg for the float
+      }
+    }
+#endif
+#endif
+    LocationValue* sv = new LocationValue(Location::new_reg_loc(loc_type, rname));
+
+    scope_values->append(sv);
+    return 1;
+
+  } else {
+    // double-size operands
+
+    ScopeValue* first;
+    ScopeValue* second;
+
+    if (opr->is_double_stack()) {
+#ifdef _LP64
+      Location loc1;
+      Location::Type loc_type = opr->type() == T_LONG ? Location::lng : Location::dbl;
+      if (!frame_map()->locations_for_slot(opr->double_stack_ix(), loc_type, &loc1, NULL)) {
+        bailout("too large frame");
+      }
+      // Does this reverse on x86 vs. sparc?
+      first =  new LocationValue(loc1);
+      second = _int_0_scope_value;
+#else
+      Location loc1, loc2;
+      if (!frame_map()->locations_for_slot(opr->double_stack_ix(), Location::normal, &loc1, &loc2)) {
+        bailout("too large frame");
+      }
+      first =  new LocationValue(loc1);
+      second = new LocationValue(loc2);
+#endif // _LP64
+
+    } else if (opr->is_double_cpu()) {
+#ifdef _LP64
+      VMReg rname_first = opr->as_register_lo()->as_VMReg();
+      first = new LocationValue(Location::new_reg_loc(Location::lng, rname_first));
+      second = _int_0_scope_value;
+#else
+      VMReg rname_first = opr->as_register_lo()->as_VMReg();
+      VMReg rname_second = opr->as_register_hi()->as_VMReg();
+
+      if (hi_word_offset_in_bytes < lo_word_offset_in_bytes) {
+        // lo/hi and swapped relative to first and second, so swap them
+        VMReg tmp = rname_first;
+        rname_first = rname_second;
+        rname_second = tmp;
+      }
+
+      first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
+      second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
+#endif //_LP64
+
+
+#ifdef X86
+    } else if (opr->is_double_xmm()) {
+      assert(opr->fpu_regnrLo() == opr->fpu_regnrHi(), "assumed in calculation");
+      VMReg rname_first  = opr->as_xmm_double_reg()->as_VMReg();
+#  ifdef _LP64
+      first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
+      second = _int_0_scope_value;
+#  else
+      first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
+      // %%% This is probably a waste but we'll keep things as they were for now
+      if (true) {
+        VMReg rname_second = rname_first->next();
+        second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
+      }
+#  endif
+#endif
+
+    } else if (opr->is_double_fpu()) {
+      // On SPARC, fpu_regnrLo/fpu_regnrHi represents the two halves of
+      // the double as float registers in the native ordering. On X86,
+      // fpu_regnrLo is a FPU stack slot whose VMReg represents
+      // the low-order word of the double and fpu_regnrLo + 1 is the
+      // name for the other half.  *first and *second must represent the
+      // least and most significant words, respectively.
+
+#ifdef X86
+      // the exact location of fpu stack values is only known
+      // during fpu stack allocation, so the stack allocator object
+      // must be present
+      assert(use_fpu_stack_allocation(), "should not have float stack values without fpu stack allocation (all floats must be SSE2)");
+      assert(_fpu_stack_allocator != NULL, "must be present");
+      opr = _fpu_stack_allocator->to_fpu_stack(opr);
+
+      assert(opr->fpu_regnrLo() == opr->fpu_regnrHi(), "assumed in calculation (only fpu_regnrLo is used)");
+#endif
+#ifdef SPARC
+      assert(opr->fpu_regnrLo() == opr->fpu_regnrHi() + 1, "assumed in calculation (only fpu_regnrHi is used)");
+#endif
+#ifdef ARM32
+      assert(opr->fpu_regnrHi() == opr->fpu_regnrLo() + 1, "assumed in calculation (only fpu_regnrLo is used)");
+#endif
+#ifdef PPC
+      assert(opr->fpu_regnrLo() == opr->fpu_regnrHi(), "assumed in calculation (only fpu_regnrHi is used)");
+#endif
+
+#ifdef VM_LITTLE_ENDIAN
+      VMReg rname_first = frame_map()->fpu_regname(opr->fpu_regnrLo());
+#else
+      VMReg rname_first = frame_map()->fpu_regname(opr->fpu_regnrHi());
+#endif
+
+#ifdef _LP64
+      first = new LocationValue(Location::new_reg_loc(Location::dbl, rname_first));
+      second = _int_0_scope_value;
+#else
+      first = new LocationValue(Location::new_reg_loc(Location::normal, rname_first));
+      // %%% This is probably a waste but we'll keep things as they were for now
+      if (true) {
+        VMReg rname_second = rname_first->next();
+        second = new LocationValue(Location::new_reg_loc(Location::normal, rname_second));
+      }
+#endif
+
+    } else {
+      ShouldNotReachHere();
+      first = NULL;
+      second = NULL;
+    }
+
+    assert(first != NULL && second != NULL, "must be set");
+    // The convention the interpreter uses is that the second local
+    // holds the first raw word of the native double representation.
+    // This is actually reasonable, since locals and stack arrays
+    // grow downwards in all implementations.
+    // (If, on some machine, the interpreter's Java locals or stack
+    // were to grow upwards, the embedded doubles would be word-swapped.)
+    scope_values->append(second);
+    scope_values->append(first);
+    return 2;
+  }
+}
+
+
+int Greedy::append_scope_value(int op_id, Value value, GrowableArray<ScopeValue*>* scope_values) {
+  if (value != NULL) {
+    LIR_Opr opr = value->operand();
+    Constant* con = value->as_Constant();
+
+    assert(con == NULL || opr->is_virtual() || opr->is_constant() || opr->is_illegal(), "asumption: Constant instructions have only constant operands (or illegal if constant is optimized away)");
+    assert(con != NULL || opr->is_virtual(), "asumption: non-Constant instructions have only virtual operands");
+
+    if (con != NULL && !con->is_pinned() && !opr->is_constant()) {
+      // Unpinned constants may have a virtual operand for a part of the lifetime
+      // or may be illegal when it was optimized away,
+      // so always use a constant operand
+      opr = LIR_OprFact::value_type(con->type());
+    }
+    assert(opr->is_virtual() || opr->is_constant(), "other cases not allowed here");
+
+    if (opr->is_virtual()) {
+      LIR_OpVisitState::OprMode mode = LIR_OpVisitState::inputMode;
+
+      BlockBegin* block = block_of_op_with_id(op_id);
+      if (block->number_of_sux() == 1 && op_id == block->last_lir_instruction_id()) {
+        // generating debug information for the last instruction of a block.
+        // if this instruction is a branch, spill moves are inserted before this branch
+        // and so the wrong operand would be returned (spill moves at block boundaries are not
+        // considered in the live ranges of intervals)
+        // Solution: use the first op_id of the branch target block instead.
+        if (block->lir()->instructions_list()->last()->as_OpBranch() != NULL) {
+          if (block->live_out().at(opr->vreg_number())) {
+            op_id = block->sux_at(0)->first_lir_instruction_id();
+            mode = LIR_OpVisitState::outputMode;
+          }
+        }
+      }
+
+      // Get current location of operand
+      // The operand must be live because debug information is considered when building the intervals
+      // if the interval is not live, color_lir_opr will cause an assertion failure
+      opr = color_lir_opr(opr, op_id, mode);
+      assert(!has_call(op_id) || opr->is_stack() || !is_caller_save(reg_num(opr)), "can not have caller-save register operands at calls");
+
+      // Append to ScopeValue array
+      return append_scope_value_for_operand(opr, scope_values);
+
+    } else {
+      assert(value->as_Constant() != NULL, "all other instructions have only virtual operands");
+      assert(opr->is_constant(), "operand must be constant");
+
+      return append_scope_value_for_constant(opr, scope_values);
+    }
+  } else {
+    // append a dummy value because real value not needed
+    scope_values->append(_greedy_illegal_value);
+    return 1;
+  }
+}
+
+
+IRScopeDebugInfo* Greedy::compute_debug_info_for_scope(int op_id, IRScope* cur_scope, ValueStack* cur_state, ValueStack* innermost_state) {
+  IRScopeDebugInfo* caller_debug_info = NULL;
+
+  ValueStack* caller_state = cur_state->caller_state();
+  if (caller_state != NULL) {
+    // process recursively to compute outermost scope first
+    caller_debug_info = compute_debug_info_for_scope(op_id, cur_scope->caller(), caller_state, innermost_state);
+  }
+
+  // initialize these to null.
+  // If we don't need deopt info or there are no locals, expressions or monitors,
+  // then these get recorded as no information and avoids the allocation of 0 length arrays.
+  GrowableArray<ScopeValue*>*   locals      = NULL;
+  GrowableArray<ScopeValue*>*   expressions = NULL;
+  GrowableArray<MonitorValue*>* monitors    = NULL;
+
+  // describe local variable values
+  int nof_locals = cur_state->locals_size();
+  if (nof_locals > 0) {
+    locals = new GrowableArray<ScopeValue*>(nof_locals);
+
+    int pos = 0;
+    while (pos < nof_locals) {
+      assert(pos < cur_state->locals_size(), "why not?");
+
+      Value local = cur_state->local_at(pos);
+      pos += append_scope_value(op_id, local, locals);
+
+      assert(locals->length() == pos, "must match");
+    }
+    assert(locals->length() == cur_scope->method()->max_locals(), "wrong number of locals");
+    assert(locals->length() == cur_state->locals_size(), "wrong number of locals");
+  } else if (cur_scope->method()->max_locals() > 0) {
+    assert(cur_state->kind() == ValueStack::EmptyExceptionState, "should be");
+    nof_locals = cur_scope->method()->max_locals();
+    locals = new GrowableArray<ScopeValue*>(nof_locals);
+    for(int i = 0; i < nof_locals; i++) {
+      locals->append(_greedy_illegal_value);
+    }
+  }
+
+  // describe expression stack
+  int nof_stack = cur_state->stack_size();
+  if (nof_stack > 0) {
+    expressions = new GrowableArray<ScopeValue*>(nof_stack);
+
+    int pos = 0;
+    while (pos < nof_stack) {
+      Value expression = cur_state->stack_at_inc(pos);
+      append_scope_value(op_id, expression, expressions);
+
+      assert(expressions->length() == pos, "must match");
+    }
+    assert(expressions->length() == cur_state->stack_size(), "wrong number of stack entries");
+  }
+
+  // describe monitors
+  int nof_locks = cur_state->locks_size();
+  if (nof_locks > 0) {
+    int lock_offset = cur_state->caller_state() != NULL ? cur_state->caller_state()->total_locks_size() : 0;
+    monitors = new GrowableArray<MonitorValue*>(nof_locks);
+    for (int i = 0; i < nof_locks; i++) {
+      monitors->append(location_for_monitor_index(lock_offset + i));
+    }
+  }
+
+  return new IRScopeDebugInfo(cur_scope, cur_state->bci(), locals, expressions, monitors, caller_debug_info);
+}
+
+
+void Greedy::compute_debug_info(CodeEmitInfo* info, int op_id) {
+  TRACE_GREEDY(3, tty->print_cr("creating debug information at op_id %d", op_id));
+
+  IRScope* innermost_scope = info->scope();
+  ValueStack* innermost_state = info->stack();
+
+  assert(innermost_scope != NULL && innermost_state != NULL, "why is it missing?");
+
+  DEBUG_ONLY(greedy_check_stack_depth(info, innermost_state->stack_size()));
+
+  if (info->_scope_debug_info == NULL) {
+    // compute debug information
+    info->_scope_debug_info = compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state);
+  } else {
+    // debug information already set. Check that it is correct from the current point of view
+    DEBUG_ONLY(greedy_assert_equal(info->_scope_debug_info, compute_debug_info_for_scope(op_id, innermost_scope, innermost_state, innermost_state)));
+  }
+}
+
+
+void Greedy::assign_reg_num(LIR_OpList* instructions, GreedyIntervalWalker* iw) {
+  LIR_OpVisitState visitor;
+  int num_inst = instructions->length();
+  bool has_dead = false;
+
+  for (int j = 0; j < num_inst; j++) {
+    LIR_Op* op = instructions->at(j);
+    if (op == NULL) {  // this can happen when spill-moves are removed in eliminate_spill_moves
+      has_dead = true;
+      continue;
+    }
+    int op_id = op->id();
+
+    // visit instruction to get list of operands
+    visitor.visit(op);
+
+    // iterate all modes of the visitor and process all virtual operands
+    for_each_visitor_mode(mode) {
+      int n = visitor.opr_count(mode);
+      for (int k = 0; k < n; k++) {
+        LIR_Opr opr = visitor.opr_at(mode, k);
+        if (opr->is_virtual_register()) {
+          visitor.set_opr_at(mode, k, color_lir_opr(opr, op_id, mode));
+        }
+      }
+    }
+
+    if (visitor.info_count() > 0) {
+      // exception handling
+      if (compilation()->has_exception_handlers()) {
+        XHandlers* xhandlers = visitor.all_xhandler();
+        int n = xhandlers->length();
+        for (int k = 0; k < n; k++) {
+          XHandler* handler = xhandlers->handler_at(k);
+          if (handler->entry_code() != NULL) {
+            assign_reg_num(handler->entry_code()->instructions_list(), NULL);
+          }
+        }
+      } else {
+        assert(visitor.all_xhandler()->length() == 0, "missed exception handler");
+      }
+
+      // compute oop map
+      assert(iw != NULL, "needed for compute_oop_map");
+      compute_oop_map(iw, visitor, op);
+
+      // compute debug information
+      if (!use_fpu_stack_allocation()) {
+        // compute debug information if fpu stack allocation is not needed.
+        // when fpu stack allocation is needed, the debug information can not
+        // be computed here because the exact location of fpu operands is not known
+        // -> debug information is created inside the fpu stack allocator
+        int n = visitor.info_count();
+        for (int k = 0; k < n; k++) {
+          compute_debug_info(visitor.info_at(k), op_id);
+        }
+      }
+    }
+
+#ifdef ASSERT
+    // make sure we haven't made the op invalid.
+    op->verify();
+#endif
+
+    // remove useless moves
+    if (op->code() == lir_move) {
+      assert(op->as_Op1() != NULL, "move must be LIR_Op1");
+      LIR_Op1* move = (LIR_Op1*)op;
+      LIR_Opr src = move->in_opr();
+      LIR_Opr dst = move->result_opr();
+      if (dst == src ||
+          !dst->is_pointer() && !src->is_pointer() &&
+          src->is_same_register(dst)) {
+        instructions->at_put(j, NULL);
+        has_dead = true;
+      }
+    }
+  }
+
+  if (has_dead) {
+    // iterate all instructions of the block and remove all null-values.
+    int insert_point = 0;
+    for (int j = 0; j < num_inst; j++) {
+      LIR_Op* op = instructions->at(j);
+      if (op != NULL) {
+        if (insert_point != j) {
+          instructions->at_put(insert_point, op);
+        }
+        insert_point++;
+      }
+    }
+    instructions->truncate(insert_point);
+  }
+}
+
+void Greedy::assign_reg_num() {
+  TIME_GREEDY(timer_assign_reg_num);
+
+  init_compute_debug_info();
+  GreedyIntervalWalker* iw = init_compute_oop_maps();
+
+  int num_blocks = block_count();
+  for (int i = 0; i < num_blocks; i++) {
+    BlockBegin* block = block_at(i);
+    assign_reg_num(block->lir()->instructions_list(), iw);
+  }
+}
+
+
+void Greedy::do_greedy() {
+  NOT_PRODUCT(_total_timer.begin_method());
+
+  number_instructions();
+
+  NOT_PRODUCT(print_lir(1, "Before Register Allocation"));
+
+  compute_local_live_sets();
+  compute_global_live_sets();
+  CHECK_BAILOUT();
+
+  build_intervals();
+  CHECK_BAILOUT();
+  sort_intervals_before_allocation();
+
+  NOT_PRODUCT(print_intervals("Before Register Allocation"));
+  NOT_PRODUCT(GreedyStatistic::compute(this, _stat_before_alloc));
+
+  allocate_registers();
+  CHECK_BAILOUT();
+
+  resolve_data_flow();
+  if (compilation()->has_exception_handlers()) {
+    resolve_exception_handlers();
+  }
+  // fill in number of spill slots into frame_map
+  propagate_spill_slots();
+  CHECK_BAILOUT();
+
+  NOT_PRODUCT(print_intervals("After Register Allocation"));
+  NOT_PRODUCT(print_lir(2, "LIR after register allocation:"));
+
+  sort_intervals_after_allocation();
+
+  DEBUG_ONLY(verify());
+
+  eliminate_spill_moves();
+  assign_reg_num();
+  CHECK_BAILOUT();
+
+  NOT_PRODUCT(print_lir(2, "LIR after assignment of register numbers:"));
+  NOT_PRODUCT(GreedyStatistic::compute(this, _stat_after_asign));
+
+  { TIME_GREEDY(timer_allocate_fpu_stack);
+
+    if (use_fpu_stack_allocation()) {
+      allocate_fpu_stack(); // Only has effect on Intel
+      NOT_PRODUCT(print_lir(2, "LIR after FPU stack allocation:"));
+    }
+  }
+
+  { TIME_GREEDY(timer_optimize_lir);
+
+    GreedyEdgeMoveOptimizer::optimize(ir()->code());
+    GreedyControlFlowOptimizer::optimize(ir()->code());
+    // check that cfg is still correct after optimizations
+    ir()->verify();
+  }
+
+  NOT_PRODUCT(print_lir(1, "Before Code Generation", false));
+  NOT_PRODUCT(GreedyStatistic::compute(this, _stat_final));
+  NOT_PRODUCT(_total_timer.end_method(this));
+}
+
+
+// ********** Printing functions
+
+#ifndef PRODUCT
+
+void Greedy::print_timers(double total) {
+  _total_timer.print(total);
+}
+
+void Greedy::print_statistics() {
+  _stat_before_alloc.print("before allocation");
+  _stat_after_asign.print("after assignment of register");
+  _stat_final.print("after optimization");
+}
+
+void Greedy::print_bitmap(BitMap& b) {
+  for (unsigned int i = 0; i < b.size(); i++) {
+    if (b.at(i)) tty->print("%d ", i);
+  }
+  tty->cr();
+}
+
+void Greedy::print_intervals(const char* label) {
+  if (TraceGreedyLevel >= 1) {
+    int i;
+    tty->cr();
+    tty->print_cr("%s", label);
+
+    for (i = 0; i < interval_count(); i++) {
+      GreedyInterval* interval = interval_at(i);
+      if (interval != NULL) {
+        interval->print();
+      }
+    }
+
+    tty->cr();
+    tty->print_cr("--- Basic Blocks ---");
+    for (i = 0; i < block_count(); i++) {
+      BlockBegin* block = block_at(i);
+      tty->print("B%d [%d, %d, %d, %d] ", block->block_id(), block->first_lir_instruction_id(), block->last_lir_instruction_id(), block->loop_index(), block->loop_depth());
+    }
+    tty->cr();
+    tty->cr();
+  }
+
+  if (PrintCFGToFile) {
+    CFGPrinter::print_intervals(&_intervals, label);
+  }
+}
+
+void Greedy::print_lir(int level, const char* label, bool hir_valid) {
+  if (TraceGreedyLevel >= level) {
+    tty->cr();
+    tty->print_cr("%s", label);
+    print_LIR(ir()->greedy_order());
+    tty->cr();
+  }
+
+  if (level == 1 && PrintCFGToFile) {
+    CFGPrinter::print_cfg(ir()->greedy_order(), label, hir_valid, true);
+  }
+}
+
+#endif //PRODUCT
+
+
+// ********** verification functions for allocation
+// (check that all intervals have a correct register and that no registers are overwritten)
+#ifdef ASSERT
+
+void Greedy::verify() {
+  TRACE_GREEDY(2, tty->print_cr("********* verifying intervals ******************************************"));
+  verify_intervals();
+
+  TRACE_GREEDY(2, tty->print_cr("********* verifying that no oops are in fixed intervals ****************"));
+  verify_no_oops_in_fixed_intervals();
+
+  TRACE_GREEDY(2, tty->print_cr("********* verifying that unpinned constants are not alive across block boundaries"));
+  verify_constants();
+
+  TRACE_GREEDY(2, tty->print_cr("********* verifying register allocation ********************************"));
+  verify_registers();
+
+  TRACE_GREEDY(2, tty->print_cr("********* no errors found **********************************************"));
+}
+
+void Greedy::verify_intervals() {
+  int len = interval_count();
+  bool has_error = false;
+
+  for (int i = 0; i < len; i++) {
+    GreedyInterval* i1 = interval_at(i);
+    if (i1 == NULL) continue;
+
+    i1->check_split_children();
+
+    if (i1->reg_num() != i) {
+      tty->print_cr("GreedyInterval %d is on position %d in list", i1->reg_num(), i); i1->print(); tty->cr();
+      has_error = true;
+    }
+
+    if (i1->reg_num() >= LIR_OprDesc::vreg_base && i1->type() == T_ILLEGAL) {
+      tty->print_cr("GreedyInterval %d has no type assigned", i1->reg_num()); i1->print(); tty->cr();
+      has_error = true;
+    }
+
+    if (i1->assigned_reg() == any_reg) {
+      tty->print_cr("GreedyInterval %d has no register assigned", i1->reg_num()); i1->print(); tty->cr();
+      has_error = true;
+    }
+
+    if (i1->assigned_reg() == i1->assigned_regHi()) {
+      tty->print_cr("GreedyInterval %d: low and high register equal", i1->reg_num()); i1->print(); tty->cr();
+      has_error = true;
+    }
+
+    if (!is_processed_reg_num(i1->assigned_reg())) {
+      tty->print_cr("Can not have an GreedyInterval for an ignored register"); i1->print(); tty->cr();
+      has_error = true;
+    }
+
+    if (i1->first() == GreedyRange::end()) {
+      tty->print_cr("GreedyInterval %d has no GreedyRange", i1->reg_num()); i1->print(); tty->cr();
+      has_error = true;
+    }
+
+    for (GreedyRange* r = i1->first(); r != GreedyRange::end(); r = r->next()) {
+      if (r->from() >= r->to()) {
+        tty->print_cr("GreedyInterval %d has zero length range", i1->reg_num()); i1->print(); tty->cr();
+        has_error = true;
+      }
+    }
+
+    for (int j = i + 1; j < len; j++) {
+      GreedyInterval* i2 = interval_at(j);
+      if (i2 == NULL) continue;
+
+      // special intervals that are created in GreedyMoveResolver
+      // -> ignore them because the range information has no meaning there
+      if (i1->from() == 1 && i1->to() == 2) continue;
+      if (i2->from() == 1 && i2->to() == 2) continue;
+
+      int r1 = i1->assigned_reg();
+      int r1Hi = i1->assigned_regHi();
+      int r2 = i2->assigned_reg();
+      int r2Hi = i2->assigned_regHi();
+      if (i1->intersects(i2) && (r1 == r2 || r1 == r2Hi || (r1Hi != any_reg && (r1Hi == r2 || r1Hi == r2Hi)))) {
+        tty->print_cr("GreedyIntervals %d and %d overlap and have the same register assigned", i1->reg_num(), i2->reg_num());
+        i1->print(); tty->cr();
+        i2->print(); tty->cr();
+        has_error = true;
+      }
+    }
+  }
+
+  assert(has_error == false, "register allocation invalid");
+}
+
+
+void Greedy::verify_no_oops_in_fixed_intervals() {
+  GreedyInterval* fixed_intervals;
+  GreedyInterval* other_intervals;
+  create_unhandled_lists(&fixed_intervals, &other_intervals, is_precolored_cpu_interval, NULL);
+
+  // to ensure a walking until the last instruction id, add a dummy interval
+  // with a high operation id
+  other_intervals = new GreedyInterval(any_reg);
+  other_intervals->add_range(max_jint - 2, max_jint - 1);
+  GreedyIntervalWalker* iw = new GreedyIntervalWalker(this, fixed_intervals, other_intervals);
+
+  LIR_OpVisitState visitor;
+  for (int i = 0; i < block_count(); i++) {
+    BlockBegin* block = block_at(i);
+
+    LIR_OpList* instructions = block->lir()->instructions_list();
+
+    for (int j = 0; j < instructions->length(); j++) {
+      LIR_Op* op = instructions->at(j);
+      int op_id = op->id();
+
+      visitor.visit(op);
+
+      if (visitor.info_count() > 0) {
+        iw->walk_before(op->id());
+        bool check_live = true;
+        if (op->code() == lir_move) {
+          LIR_Op1* move = (LIR_Op1*)op;
+          check_live = (move->patch_code() == lir_patch_none);
+        }
+        LIR_OpBranch* branch = op->as_OpBranch();
+        if (branch != NULL && branch->stub() != NULL && branch->stub()->is_exception_throw_stub()) {
+          // Don't bother checking the stub in this case since the
+          // exception stub will never return to normal control flow.
+          check_live = false;
+        }
+
+        // Make sure none of the fixed registers is live across an
+        // oopmap since we can't handle that correctly.
+        if (check_live) {
+          for (GreedyInterval* interval = iw->active_first(fixedKind);
+               interval != GreedyInterval::end();
+               interval = interval->next()) {
+            if (interval->current_to() > op->id() + 1) {
+              // This interval is live out of this op so make sure
+              // that this interval represents some value that's
+              // referenced by this op either as an input or output.
+              bool ok = false;
+              for_each_visitor_mode(mode) {
+                int n = visitor.opr_count(mode);
+                for (int k = 0; k < n; k++) {
+                  LIR_Opr opr = visitor.opr_at(mode, k);
+                  if (opr->is_fixed_cpu()) {
+                    if (interval_at(reg_num(opr)) == interval) {
+                      ok = true;
+                      break;
+                    }
+                    int hi = reg_numHi(opr);
+                    if (hi != -1 && interval_at(hi) == interval) {
+                      ok = true;
+                      break;
+                    }
+                  }
+                }
+              }
+              assert(ok, "fixed intervals should never be live across an oopmap point");
+            }
+          }
+        }
+      }
+
+      // oop-maps at calls do not contain registers, so check is not needed
+      if (!visitor.has_call()) {
+
+        for_each_visitor_mode(mode) {
+          int n = visitor.opr_count(mode);
+          for (int k = 0; k < n; k++) {
+            LIR_Opr opr = visitor.opr_at(mode, k);
+
+            if (opr->is_fixed_cpu() && opr->is_oop()) {
+              // operand is a non-virtual cpu register and contains an oop
+              TRACE_GREEDY(4, op->print_on(tty); tty->print("checking operand "); opr->print(); tty->cr());
+
+              GreedyInterval* interval = interval_at(reg_num(opr));
+              assert(interval != NULL, "no interval");
+
+              if (mode == LIR_OpVisitState::inputMode) {
+                if (interval->to() >= op_id + 1) {
+                  assert(interval->to() < op_id + 2 ||
+                         interval->has_hole_between(op_id, op_id + 2),
+                         "oop input operand live after instruction");
+                }
+              } else if (mode == LIR_OpVisitState::outputMode) {
+                if (interval->from() <= op_id - 1) {
+                  assert(interval->has_hole_between(op_id - 1, op_id),
+                         "oop input operand live after instruction");
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+
+void Greedy::verify_constants() {
+  int num_regs = num_virtual_regs();
+  int size = live_set_size();
+  int num_blocks = block_count();
+
+  for (int i = 0; i < num_blocks; i++) {
+    BlockBegin* block = block_at(i);
+    BitMap live_at_edge = block->live_in();
+
+    // visit all registers where the live_at_edge bit is set
+    for (int r = (int)live_at_edge.get_next_one_offset(0, size); r < size; r = (int)live_at_edge.get_next_one_offset(r + 1, size)) {
+      TRACE_GREEDY(4, tty->print("checking interval %d of block B%d", r, block->block_id()));
+
+      Value value = gen()->instruction_for_vreg(r);
+
+      assert(value != NULL, "all intervals live across block boundaries must have Value");
+      assert(value->operand()->is_register() && value->operand()->is_virtual(), "value must have virtual operand");
+      assert(value->operand()->vreg_number() == r, "register number must match");
+      // TKR assert(value->as_Constant() == NULL || value->is_pinned(), "only pinned constants can be alive accross block boundaries");
+    }
+  }
+}
+
+
+class GreedyRegisterVerifier: public StackObj {
+ private:
+  Greedy*   _allocator;
+  BlockList     _work_list;      // all blocks that must be processed
+  GreedyIntervalsList _saved_states;   // saved information of previous check
+
+  // simplified access to methods of Greedy
+  Compilation*  compilation() const              { return _allocator->compilation(); }
+  GreedyInterval*     interval_at(int reg_num) const   { return _allocator->interval_at(reg_num); }
+  int           reg_num(LIR_Opr opr) const       { return _allocator->reg_num(opr); }
+
+  // currently, only registers are processed
+  int           state_size()                     { return Greedy::nof_regs; }
+
+  // accessors
+  GreedyIntervalList* state_for_block(BlockBegin* block) { return _saved_states.at(block->block_id()); }
+  void          set_state_for_block(BlockBegin* block, GreedyIntervalList* saved_state) { _saved_states.at_put(block->block_id(), saved_state); }
+  void          add_to_work_list(BlockBegin* block) { if (!_work_list.contains(block)) _work_list.append(block); }
+
+  // helper functions
+  GreedyIntervalList* copy(GreedyIntervalList* input_state);
+  void          state_put(GreedyIntervalList* input_state, int reg, GreedyInterval* interval);
+  bool          check_state(GreedyIntervalList* input_state, int reg, GreedyInterval* interval);
+
+  void process_block(BlockBegin* block);
+  void process_xhandler(XHandler* xhandler, GreedyIntervalList* input_state);
+  void process_successor(BlockBegin* block, GreedyIntervalList* input_state);
+  void process_operations(LIR_List* ops, GreedyIntervalList* input_state);
+
+ public:
+  GreedyRegisterVerifier(Greedy* allocator)
+    : _allocator(allocator)
+    , _work_list(16)
+    , _saved_states(BlockBegin::number_of_blocks(), NULL)
+  { }
+
+  void verify(BlockBegin* start);
+};
+
+
+// entry function from Greedy that starts the verification
+void Greedy::verify_registers() {
+  GreedyRegisterVerifier verifier(this);
+  verifier.verify(block_at(0));
+}
+
+
+void GreedyRegisterVerifier::verify(BlockBegin* start) {
+  // setup input registers (method arguments) for first block
+  GreedyIntervalList* input_state = new GreedyIntervalList(state_size(), NULL);
+  CallingConvention* args = compilation()->frame_map()->incoming_arguments();
+  for (int n = 0; n < args->length(); n++) {
+    LIR_Opr opr = args->at(n);
+    if (opr->is_register()) {
+      GreedyInterval* interval = interval_at(reg_num(opr));
+
+      if (interval->assigned_reg() < state_size()) {
+        input_state->at_put(interval->assigned_reg(), interval);
+      }
+      if (interval->assigned_regHi() != Greedy::any_reg && interval->assigned_regHi() < state_size()) {
+        input_state->at_put(interval->assigned_regHi(), interval);
+      }
+    }
+  }
+
+  set_state_for_block(start, input_state);
+  add_to_work_list(start);
+
+  // main loop for verification
+  do {
+    BlockBegin* block = _work_list.at(0);
+    _work_list.remove_at(0);
+
+    process_block(block);
+  } while (!_work_list.is_empty());
+}
+
+void GreedyRegisterVerifier::process_block(BlockBegin* block) {
+  TRACE_GREEDY(2, tty->cr(); tty->print_cr("process_block B%d", block->block_id()));
+
+  // must copy state because it is modified
+  GreedyIntervalList* input_state = copy(state_for_block(block));
+
+  if (TraceGreedyLevel >= 4) {
+    tty->print_cr("Input-State of intervals:");
+    tty->print("    ");
+    for (int i = 0; i < state_size(); i++) {
+      if (input_state->at(i) != NULL) {
+        tty->print(" %4d", input_state->at(i)->reg_num());
+      } else {
+        tty->print("   __");
+      }
+    }
+    tty->cr();
+    tty->cr();
+  }
+
+  // process all operations of the block
+  process_operations(block->lir(), input_state);
+
+  // iterate all successors
+  for (int i = 0; i < block->number_of_sux(); i++) {
+    process_successor(block->sux_at(i), input_state);
+  }
+}
+
+void GreedyRegisterVerifier::process_xhandler(XHandler* xhandler, GreedyIntervalList* input_state) {
+  TRACE_GREEDY(2, tty->print_cr("process_xhandler B%d", xhandler->entry_block()->block_id()));
+
+  // must copy state because it is modified
+  input_state = copy(input_state);
+
+  if (xhandler->entry_code() != NULL) {
+    process_operations(xhandler->entry_code(), input_state);
+  }
+  process_successor(xhandler->entry_block(), input_state);
+}
+
+void GreedyRegisterVerifier::process_successor(BlockBegin* block, GreedyIntervalList* input_state) {
+  GreedyIntervalList* saved_state = state_for_block(block);
+
+  if (saved_state != NULL) {
+    // this block was already processed before.
+    // check if new input_state is consistent with saved_state
+
+    bool saved_state_correct = true;
+    for (int i = 0; i < state_size(); i++) {
+      if (input_state->at(i) != saved_state->at(i)) {
+        // current input_state and previous saved_state assume a different
+        // interval in this register -> assume that this register is invalid
+        if (saved_state->at(i) != NULL) {
+          // invalidate old calculation only if it assumed that
+          // register was valid. when the register was already invalid,
+          // then the old calculation was correct.
+          saved_state_correct = false;
+          saved_state->at_put(i, NULL);
+
+          TRACE_GREEDY(4, tty->print_cr("process_successor B%d: invalidating slot %d", block->block_id(), i));
+        }
+      }
+    }
+
+    if (saved_state_correct) {
+      // already processed block with correct input_state
+      TRACE_GREEDY(2, tty->print_cr("process_successor B%d: previous visit already correct", block->block_id()));
+    } else {
+      // must re-visit this block
+      TRACE_GREEDY(2, tty->print_cr("process_successor B%d: must re-visit because input state changed", block->block_id()));
+      add_to_work_list(block);
+    }
+
+  } else {
+    // block was not processed before, so set initial input_state
+    TRACE_GREEDY(2, tty->print_cr("process_successor B%d: initial visit", block->block_id()));
+
+    set_state_for_block(block, copy(input_state));
+    add_to_work_list(block);
+  }
+}
+
+
+GreedyIntervalList* GreedyRegisterVerifier::copy(GreedyIntervalList* input_state) {
+  GreedyIntervalList* copy_state = new GreedyIntervalList(input_state->length());
+  copy_state->push_all(input_state);
+  return copy_state;
+}
+
+void GreedyRegisterVerifier::state_put(GreedyIntervalList* input_state, int reg, GreedyInterval* interval) {
+  if (reg != Greedy::any_reg && reg < state_size()) {
+    if (interval != NULL) {
+      TRACE_GREEDY(4, tty->print_cr("        reg[%d] = %d", reg, interval->reg_num()));
+    } else if (input_state->at(reg) != NULL) {
+      TRACE_GREEDY(4, tty->print_cr("        reg[%d] = NULL", reg));
+    }
+
+    input_state->at_put(reg, interval);
+  }
+}
+
+bool GreedyRegisterVerifier::check_state(GreedyIntervalList* input_state, int reg, GreedyInterval* interval) {
+  if (reg != Greedy::any_reg && reg < state_size()) {
+    if (input_state->at(reg) != interval) {
+      tty->print_cr("!! Error in register allocation: register %d does not contain interval %d", reg, interval->reg_num());
+      return true;
+    }
+  }
+  return false;
+}
+
+void GreedyRegisterVerifier::process_operations(LIR_List* ops, GreedyIntervalList* input_state) {
+  // visit all instructions of the block
+  LIR_OpVisitState visitor;
+  bool has_error = false;
+
+  for (int i = 0; i < ops->length(); i++) {
+    LIR_Op* op = ops->at(i);
+    visitor.visit(op);
+
+    TRACE_GREEDY(4, op->print_on(tty));
+
+    // check if input operands are correct
+    int j;
+    int n = visitor.opr_count(LIR_OpVisitState::inputMode);
+    for (j = 0; j < n; j++) {
+      LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::inputMode, j);
+      if (opr->is_register() && Greedy::is_processed_reg_num(reg_num(opr))) {
+        GreedyInterval* interval = interval_at(reg_num(opr));
+        if (op->id() != -1) {
+          interval = interval->split_child_at_op_id(op->id(), LIR_OpVisitState::inputMode);
+        }
+
+        has_error |= check_state(input_state, interval->assigned_reg(),   interval->split_parent());
+        has_error |= check_state(input_state, interval->assigned_regHi(), interval->split_parent());
+
+        // When an operand is marked with is_last_use, then the fpu stack allocator
+        // removes the register from the fpu stack -> the register contains no value
+        if (opr->is_last_use()) {
+          state_put(input_state, interval->assigned_reg(),   NULL);
+          state_put(input_state, interval->assigned_regHi(), NULL);
+        }
+      }
+    }
+
+    // invalidate all caller save registers at calls
+    if (visitor.has_call()) {
+      for (j = 0; j < FrameMap::nof_caller_save_cpu_regs(); j++) {
+        state_put(input_state, reg_num(FrameMap::caller_save_cpu_reg_at(j)), NULL);
+      }
+      for (j = 0; j < FrameMap::nof_caller_save_fpu_regs; j++) {
+        state_put(input_state, reg_num(FrameMap::caller_save_fpu_reg_at(j)), NULL);
+      }
+
+#ifdef X86
+      for (j = 0; j < FrameMap::nof_caller_save_xmm_regs; j++) {
+        state_put(input_state, reg_num(FrameMap::caller_save_xmm_reg_at(j)), NULL);
+      }
+#endif
+    }
+
+    // process xhandler before output and temp operands
+    XHandlers* xhandlers = visitor.all_xhandler();
+    n = xhandlers->length();
+    for (int k = 0; k < n; k++) {
+      process_xhandler(xhandlers->handler_at(k), input_state);
+    }
+
+    // set temp operands (some operations use temp operands also as output operands, so can't set them NULL)
+    n = visitor.opr_count(LIR_OpVisitState::tempMode);
+    for (j = 0; j < n; j++) {
+      LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::tempMode, j);
+      if (opr->is_register() && Greedy::is_processed_reg_num(reg_num(opr))) {
+        GreedyInterval* interval = interval_at(reg_num(opr));
+        if (op->id() != -1) {
+          interval = interval->split_child_at_op_id(op->id(), LIR_OpVisitState::tempMode);
+        }
+
+        state_put(input_state, interval->assigned_reg(),   interval->split_parent());
+        state_put(input_state, interval->assigned_regHi(), interval->split_parent());
+      }
+    }
+
+    // set output operands
+    n = visitor.opr_count(LIR_OpVisitState::outputMode);
+    for (j = 0; j < n; j++) {
+      LIR_Opr opr = visitor.opr_at(LIR_OpVisitState::outputMode, j);
+      if (opr->is_register() && Greedy::is_processed_reg_num(reg_num(opr))) {
+        GreedyInterval* interval = interval_at(reg_num(opr));
+        if (op->id() != -1) {
+          interval = interval->split_child_at_op_id(op->id(), LIR_OpVisitState::outputMode);
+        }
+
+        state_put(input_state, interval->assigned_reg(),   interval->split_parent());
+        state_put(input_state, interval->assigned_regHi(), interval->split_parent());
+      }
+    }
+  }
+  assert(has_error == false, "Error in register allocation");
+}
+
+#endif // ASSERT
+
+
+
+// **** Implementation of GreedyMoveResolver ******************************
+
+GreedyMoveResolver::GreedyMoveResolver(Greedy* allocator) :
+  _allocator(allocator),
+  _multiple_reads_allowed(false),
+  _mapping_from(8),
+  _mapping_from_opr(8),
+  _mapping_to(8),
+  _insert_list(NULL),
+  _insert_idx(-1),
+  _insertion_buffer()
+{
+  for (int i = 0; i < Greedy::nof_regs; i++) {
+    _register_blocked[i] = 0;
+  }
+  DEBUG_ONLY(check_empty());
+}
+
+
+#ifdef ASSERT
+
+void GreedyMoveResolver::check_empty() {
+  assert(_mapping_from.length() == 0 && _mapping_from_opr.length() == 0 && _mapping_to.length() == 0, "list must be empty before and after processing");
+  for (int i = 0; i < Greedy::nof_regs; i++) {
+    assert(register_blocked(i) == 0, "register map must be empty before and after processing");
+  }
+  assert(_multiple_reads_allowed == false, "must have default value");
+}
+
+void GreedyMoveResolver::verify_before_resolve() {
+  assert(_mapping_from.length() == _mapping_from_opr.length(), "length must be equal");
+  assert(_mapping_from.length() == _mapping_to.length(), "length must be equal");
+  assert(_insert_list != NULL && _insert_idx != -1, "insert position not set");
+
+  int i, j;
+  if (!_multiple_reads_allowed) {
+    for (i = 0; i < _mapping_from.length(); i++) {
+      for (j = i + 1; j < _mapping_from.length(); j++) {
+        assert(_mapping_from.at(i) == NULL || _mapping_from.at(i) != _mapping_from.at(j), "cannot read from same interval twice");
+      }
+    }
+  }
+
+  for (i = 0; i < _mapping_to.length(); i++) {
+    for (j = i + 1; j < _mapping_to.length(); j++) {
+      assert(_mapping_to.at(i) != _mapping_to.at(j), "cannot write to same interval twice");
+    }
+  }
+
+
+  BitMap used_regs(Greedy::nof_regs + allocator()->frame_map()->argcount() + allocator()->max_spills());
+  used_regs.clear();
+  if (!_multiple_reads_allowed) {
+    for (i = 0; i < _mapping_from.length(); i++) {
+      GreedyInterval* it = _mapping_from.at(i);
+      if (it != NULL) {
+        assert(!used_regs.at(it->assigned_reg()), "cannot read from same register twice");
+        used_regs.set_bit(it->assigned_reg());
+
+        if (it->assigned_regHi() != Greedy::any_reg) {
+          assert(!used_regs.at(it->assigned_regHi()), "cannot read from same register twice");
+          used_regs.set_bit(it->assigned_regHi());
+        }
+      }
+    }
+  }
+
+  used_regs.clear();
+  for (i = 0; i < _mapping_to.length(); i++) {
+    GreedyInterval* it = _mapping_to.at(i);
+    assert(!used_regs.at(it->assigned_reg()), "cannot write to same register twice");
+    used_regs.set_bit(it->assigned_reg());
+
+    if (it->assigned_regHi() != Greedy::any_reg) {
+      assert(!used_regs.at(it->assigned_regHi()), "cannot write to same register twice");
+      used_regs.set_bit(it->assigned_regHi());
+    }
+  }
+
+  used_regs.clear();
+  for (i = 0; i < _mapping_from.length(); i++) {
+    GreedyInterval* it = _mapping_from.at(i);
+    if (it != NULL && it->assigned_reg() >= Greedy::nof_regs) {
+      used_regs.set_bit(it->assigned_reg());
+    }
+  }
+  for (i = 0; i < _mapping_to.length(); i++) {
+    GreedyInterval* it = _mapping_to.at(i);
+    assert(!used_regs.at(it->assigned_reg()) || it->assigned_reg() == _mapping_from.at(i)->assigned_reg(), "stack slots used in _mapping_from must be disjoint to _mapping_to");
+  }
+}
+
+#endif // ASSERT
+
+
+// mark assigned_reg and assigned_regHi of the interval as blocked
+void GreedyMoveResolver::block_registers(GreedyInterval* it) {
+  int reg = it->assigned_reg();
+  if (reg < Greedy::nof_regs) {
+    assert(_multiple_reads_allowed || register_blocked(reg) == 0, "register already marked as used");
+    set_register_blocked(reg, 1);
+  }
+  reg = it->assigned_regHi();
+  if (reg != Greedy::any_reg && reg < Greedy::nof_regs) {
+    assert(_multiple_reads_allowed || register_blocked(reg) == 0, "register already marked as used");
+    set_register_blocked(reg, 1);
+  }
+}
+
+// mark assigned_reg and assigned_regHi of the interval as unblocked
+void GreedyMoveResolver::unblock_registers(GreedyInterval* it) {
+  int reg = it->assigned_reg();
+  if (reg < Greedy::nof_regs) {
+    assert(register_blocked(reg) > 0, "register already marked as unused");
+    set_register_blocked(reg, -1);
+  }
+  reg = it->assigned_regHi();
+  if (reg != Greedy::any_reg && reg < Greedy::nof_regs) {
+    assert(register_blocked(reg) > 0, "register already marked as unused");
+    set_register_blocked(reg, -1);
+  }
+}
+
+// check if assigned_reg and assigned_regHi of the to-interval are not blocked (or only blocked by from)
+bool GreedyMoveResolver::save_to_process_move(GreedyInterval* from, GreedyInterval* to) {
+  int from_reg = -1;
+  int from_regHi = -1;
+  if (from != NULL) {
+    from_reg = from->assigned_reg();
+    from_regHi = from->assigned_regHi();
+  }
+
+  int reg = to->assigned_reg();
+  if (reg < Greedy::nof_regs) {
+    if (register_blocked(reg) > 1 || (register_blocked(reg) == 1 && reg != from_reg && reg != from_regHi)) {
+      return false;
+    }
+  }
+  reg = to->assigned_regHi();
+  if (reg != Greedy::any_reg && reg < Greedy::nof_regs) {
+    if (register_blocked(reg) > 1 || (register_blocked(reg) == 1 && reg != from_reg && reg != from_regHi)) {
+      return false;
+    }
+  }
+
+  return true;
+}
+
+
+void GreedyMoveResolver::create_insertion_buffer(LIR_List* list) {
+  assert(!_insertion_buffer.initialized(), "overwriting existing buffer");
+  _insertion_buffer.init(list);
+}
+
+void GreedyMoveResolver::append_insertion_buffer() {
+  if (_insertion_buffer.initialized()) {
+    _insertion_buffer.lir_list()->append(&_insertion_buffer);
+  }
+  assert(!_insertion_buffer.initialized(), "must be uninitialized now");
+
+  _insert_list = NULL;
+  _insert_idx = -1;
+}
+
+void GreedyMoveResolver::insert_move(GreedyInterval* from_interval, GreedyInterval* to_interval) {
+  assert(from_interval->reg_num() != to_interval->reg_num(), "from and to interval equal");
+  assert(from_interval->type() == to_interval->type(), "move between different types");
+  assert(_insert_list != NULL && _insert_idx != -1, "must setup insert position first");
+  assert(_insertion_buffer.lir_list() == _insert_list, "wrong insertion buffer");
+
+  LIR_Opr from_opr = LIR_OprFact::virtual_register(from_interval->reg_num(), from_interval->type());
+  LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval->reg_num(), to_interval->type());
+
+  if (!_multiple_reads_allowed) {
+    // the last_use flag is an optimization for FPU stack allocation. When the same
+    // input interval is used in more than one move, then it is too difficult to determine
+    // if this move is really the last use.
+    from_opr = from_opr->make_last_use();
+  }
+  _insertion_buffer.move(_insert_idx, from_opr, to_opr);
+
+  TRACE_GREEDY(4, tty->print_cr("GreedyMoveResolver: inserted move from register %d (%d, %d) to %d (%d, %d)", from_interval->reg_num(), from_interval->assigned_reg(), from_interval->assigned_regHi(), to_interval->reg_num(), to_interval->assigned_reg(), to_interval->assigned_regHi()));
+}
+
+void GreedyMoveResolver::insert_move(LIR_Opr from_opr, GreedyInterval* to_interval) {
+  assert(from_opr->type() == to_interval->type(), "move between different types");
+  assert(_insert_list != NULL && _insert_idx != -1, "must setup insert position first");
+  assert(_insertion_buffer.lir_list() == _insert_list, "wrong insertion buffer");
+
+  LIR_Opr to_opr = LIR_OprFact::virtual_register(to_interval->reg_num(), to_interval->type());
+  _insertion_buffer.move(_insert_idx, from_opr, to_opr);
+
+  TRACE_GREEDY(4, tty->print("GreedyMoveResolver: inserted move from constant "); from_opr->print(); tty->print_cr("  to %d (%d, %d)", to_interval->reg_num(), to_interval->assigned_reg(), to_interval->assigned_regHi()));
+}
+
+
+void GreedyMoveResolver::resolve_mappings() {
+  TRACE_GREEDY(4, tty->print_cr("GreedyMoveResolver: resolving mappings for Block B%d, index %d", _insert_list->block() != NULL ? _insert_list->block()->block_id() : -1, _insert_idx));
+  DEBUG_ONLY(verify_before_resolve());
+
+  // Block all registers that are used as input operands of a move.
+  // When a register is blocked, no move to this register is emitted.
+  // This is necessary for detecting cycles in moves.
+  int i;
+  for (i = _mapping_from.length() - 1; i >= 0; i--) {
+    GreedyInterval* from_interval = _mapping_from.at(i);
+    if (from_interval != NULL) {
+      block_registers(from_interval);
+    }
+  }
+
+  int spill_candidate = -1;
+  while (_mapping_from.length() > 0) {
+    bool processed_interval = false;
+
+    for (i = _mapping_from.length() - 1; i >= 0; i--) {
+      GreedyInterval* from_interval = _mapping_from.at(i);
+      GreedyInterval* to_interval = _mapping_to.at(i);
+
+      if (save_to_process_move(from_interval, to_interval)) {
+        // this inverval can be processed because target is free
+        if (from_interval != NULL) {
+          insert_move(from_interval, to_interval);
+          unblock_registers(from_interval);
+        } else {
+          insert_move(_mapping_from_opr.at(i), to_interval);
+        }
+        _mapping_from.remove_at(i);
+        _mapping_from_opr.remove_at(i);
+        _mapping_to.remove_at(i);
+
+        processed_interval = true;
+      } else if (from_interval != NULL && from_interval->assigned_reg() < Greedy::nof_regs) {
+        // this interval cannot be processed now because target is not free
+        // it starts in a register, so it is a possible candidate for spilling
+        spill_candidate = i;
+      }
+    }
+
+    if (!processed_interval) {
+      // no move could be processed because there is a cycle in the move list
+      // (e.g. r1 -> r2, r2 -> r1), so one interval must be spilled to memory
+      assert(spill_candidate != -1, "no interval in register for spilling found");
+
+      // create a new spill interval and assign a stack slot to it
+      GreedyInterval* from_interval = _mapping_from.at(spill_candidate);
+      GreedyInterval* spill_interval = new GreedyInterval(-1);
+      spill_interval->set_type(from_interval->type());
+
+      // add a dummy range because real position is difficult to calculate
+      // Note: this range is a special case when the integrity of the allocation is checked
+      spill_interval->add_range(1, 2);
+
+      //       do not allocate a new spill slot for temporary interval, but
+      //       use spill slot assigned to from_interval. Otherwise moves from
+      //       one stack slot to another can happen (not allowed by LIR_Assembler
+      int spill_slot = from_interval->canonical_spill_slot();
+      if (spill_slot < 0) {
+        spill_slot = allocator()->allocate_spill_slot(type2spill_size[spill_interval->type()] == 2);
+        from_interval->set_canonical_spill_slot(spill_slot);
+      }
+      spill_interval->assign_reg(spill_slot);
+      allocator()->append_interval(spill_interval);
+
+      TRACE_GREEDY(4, tty->print_cr("created new GreedyInterval %d for spilling", spill_interval->reg_num()));
+
+      // insert a move from register to stack and update the mapping
+      insert_move(from_interval, spill_interval);
+      _mapping_from.at_put(spill_candidate, spill_interval);
+      unblock_registers(from_interval);
+    }
+  }
+
+  // reset to default value
+  _multiple_reads_allowed = false;
+
+  // check that all intervals have been processed
+  DEBUG_ONLY(check_empty());
+}
+
+
+void GreedyMoveResolver::set_insert_position(LIR_List* insert_list, int insert_idx) {
+  TRACE_GREEDY(4, tty->print_cr("GreedyMoveResolver: setting insert position to Block B%d, index %d", insert_list->block() != NULL ? insert_list->block()->block_id() : -1, insert_idx));
+  assert(_insert_list == NULL && _insert_idx == -1, "use move_insert_position instead of set_insert_position when data already set");
+
+  create_insertion_buffer(insert_list);
+  _insert_list = insert_list;
+  _insert_idx = insert_idx;
+}
+
+void GreedyMoveResolver::move_insert_position(LIR_List* insert_list, int insert_idx) {
+  TRACE_GREEDY(4, tty->print_cr("GreedyMoveResolver: moving insert position to Block B%d, index %d", insert_list->block() != NULL ? insert_list->block()->block_id() : -1, insert_idx));
+
+  if (_insert_list != NULL && (insert_list != _insert_list || insert_idx != _insert_idx)) {
+    // insert position changed -> resolve current mappings
+    resolve_mappings();
+  }
+
+  if (insert_list != _insert_list) {
+    // block changed -> append insertion_buffer because it is
+    // bound to a specific block and create a new insertion_buffer
+    append_insertion_buffer();
+    create_insertion_buffer(insert_list);
+  }
+
+  _insert_list = insert_list;
+  _insert_idx = insert_idx;
+}
+
+void GreedyMoveResolver::add_mapping(GreedyInterval* from_interval, GreedyInterval* to_interval) {
+  TRACE_GREEDY(4, tty->print_cr("GreedyMoveResolver: adding mapping from %d (%d, %d) to %d (%d, %d)", from_interval->reg_num(), from_interval->assigned_reg(), from_interval->assigned_regHi(), to_interval->reg_num(), to_interval->assigned_reg(), to_interval->assigned_regHi()));
+
+  _mapping_from.append(from_interval);
+  _mapping_from_opr.append(LIR_OprFact::illegalOpr);
+  _mapping_to.append(to_interval);
+}
+
+
+void GreedyMoveResolver::add_mapping(LIR_Opr from_opr, GreedyInterval* to_interval) {
+  TRACE_GREEDY(4, tty->print("GreedyMoveResolver: adding mapping from "); from_opr->print(); tty->print_cr(" to %d (%d, %d)", to_interval->reg_num(), to_interval->assigned_reg(), to_interval->assigned_regHi()));
+  assert(from_opr->is_constant(), "only for constants");
+
+  _mapping_from.append(NULL);
+  _mapping_from_opr.append(from_opr);
+  _mapping_to.append(to_interval);
+}
+
+void GreedyMoveResolver::resolve_and_append_moves() {
+  if (has_mappings()) {
+    resolve_mappings();
+  }
+  append_insertion_buffer();
+}
+
+
+
+// **** Implementation of GreedyRange *************************************
+
+GreedyRange::GreedyRange(int from, int to, GreedyRange* next) :
+  _from(from),
+  _to(to),
+  _next(next)
+{
+}
+
+// initialize sentinel
+GreedyRange* GreedyRange::_end = NULL;
+void GreedyRange::initialize(Arena* arena) {
+  _end = new (arena) GreedyRange(max_jint, max_jint, NULL);
+}
+
+int GreedyRange::intersects_at(GreedyRange* r2) const {
+  const GreedyRange* r1 = this;
+
+  assert(r1 != NULL && r2 != NULL, "null ranges not allowed");
+  assert(r1 != _end && r2 != _end, "empty ranges not allowed");
+
+  do {
+    if (r1->from() < r2->from()) {
+      if (r1->to() <= r2->from()) {
+        r1 = r1->next(); if (r1 == _end) return -1;
+      } else {
+        return r2->from();
+      }
+    } else if (r2->from() < r1->from()) {
+      if (r2->to() <= r1->from()) {
+        r2 = r2->next(); if (r2 == _end) return -1;
+      } else {
+        return r1->from();
+      }
+    } else { // r1->from() == r2->from()
+      if (r1->from() == r1->to()) {
+        r1 = r1->next(); if (r1 == _end) return -1;
+      } else if (r2->from() == r2->to()) {
+        r2 = r2->next(); if (r2 == _end) return -1;
+      } else {
+        return r1->from();
+      }
+    }
+  } while (true);
+}
+
+#ifndef PRODUCT
+void GreedyRange::print(outputStream* out) const {
+  out->print("[%d, %d[ ", _from, _to);
+}
+#endif
+
+
+
+// **** Implementation of GreedyInterval **********************************
+
+// initialize sentinel
+GreedyInterval* GreedyInterval::_end = NULL;
+void GreedyInterval::initialize(Arena* arena) {
+  GreedyRange::initialize(arena);
+  _end = new (arena) GreedyInterval(-1);
+}
+
+GreedyInterval::GreedyInterval(int reg_num) :
+  _reg_num(reg_num),
+  _type(T_ILLEGAL),
+  _first(GreedyRange::end()),
+  _use_pos_and_kinds(12),
+  _current(GreedyRange::end()),
+  _next(_end),
+  _state(invalidState),
+  _assigned_reg(Greedy::any_reg),
+  _assigned_regHi(Greedy::any_reg),
+  _cached_to(-1),
+  _cached_opr(LIR_OprFact::illegalOpr),
+  _cached_vm_reg(VMRegImpl::Bad()),
+  _split_children(0),
+  _canonical_spill_slot(-1),
+  _insert_move_when_activated(false),
+  _register_hint(NULL),
+  _spill_state(noDefinitionFound),
+  _spill_definition_pos(-1)
+{
+  _split_parent = this;
+  _current_split_child = this;
+}
+
+int GreedyInterval::calc_to() {
+  assert(_first != GreedyRange::end(), "interval has no range");
+
+  GreedyRange* r = _first;
+  while (r->next() != GreedyRange::end()) {
+    r = r->next();
+  }
+  return r->to();
+}
+
+
+#ifdef ASSERT
+// consistency check of split-children
+void GreedyInterval::check_split_children() {
+  if (_split_children.length() > 0) {
+    assert(is_split_parent(), "only split parents can have children");
+
+    for (int i = 0; i < _split_children.length(); i++) {
+      GreedyInterval* i1 = _split_children.at(i);
+
+      assert(i1->split_parent() == this, "not a split child of this interval");
+      assert(i1->type() == type(), "must be equal for all split children");
+      assert(i1->canonical_spill_slot() == canonical_spill_slot(), "must be equal for all split children");
+
+      for (int j = i + 1; j < _split_children.length(); j++) {
+        GreedyInterval* i2 = _split_children.at(j);
+
+        assert(i1->reg_num() != i2->reg_num(), "same register number");
+
+        if (i1->from() < i2->from()) {
+          assert(i1->to() <= i2->from() && i1->to() < i2->to(), "intervals overlapping");
+        } else {
+          assert(i2->from() < i1->from(), "intervals start at same op_id");
+          assert(i2->to() <= i1->from() && i2->to() < i1->to(), "intervals overlapping");
+        }
+      }
+    }
+  }
+}
+#endif // ASSERT
+
+GreedyInterval* GreedyInterval::register_hint(bool search_split_child) const {
+  if (!search_split_child) {
+    return _register_hint;
+  }
+
+  if (_register_hint != NULL) {
+    assert(_register_hint->is_split_parent(), "ony split parents are valid hint registers");
+
+    if (_register_hint->assigned_reg() >= 0 && _register_hint->assigned_reg() < Greedy::nof_regs) {
+      return _register_hint;
+
+    } else if (_register_hint->_split_children.length() > 0) {
+      // search the first split child that has a register assigned
+      int len = _register_hint->_split_children.length();
+      for (int i = 0; i < len; i++) {
+        GreedyInterval* cur = _register_hint->_split_children.at(i);
+
+        if (cur->assigned_reg() >= 0 && cur->assigned_reg() < Greedy::nof_regs) {
+          return cur;
+        }
+      }
+    }
+  }
+
+  // no hint interval found that has a register assigned
+  return NULL;
+}
+
+
+GreedyInterval* GreedyInterval::split_child_at_op_id(int op_id, LIR_OpVisitState::OprMode mode) {
+  assert(is_split_parent(), "can only be called for split parents");
+  assert(op_id >= 0, "invalid op_id (method can not be called for spill moves)");
+
+  GreedyInterval* result;
+  if (_split_children.length() == 0) {
+    result = this;
+  } else {
+    result = NULL;
+    int len = _split_children.length();
+
+    // in outputMode, the end of the interval (op_id == cur->to()) is not valid
+    int to_offset = (mode == LIR_OpVisitState::outputMode ? 0 : 1);
+
+    int i;
+    for (i = 0; i < len; i++) {
+      GreedyInterval* cur = _split_children.at(i);
+      if (cur->from() <= op_id && op_id < cur->to() + to_offset) {
+        if (i > 0) {
+          // exchange current split child to start of list (faster access for next call)
+          _split_children.at_put(i, _split_children.at(0));
+          _split_children.at_put(0, cur);
+        }
+
+        // interval found
+        result = cur;
+        break;
+      }
+    }
+
+#ifdef ASSERT
+    for (i = 0; i < len; i++) {
+      GreedyInterval* tmp = _split_children.at(i);
+      if (tmp != result && tmp->from() <= op_id && op_id < tmp->to() + to_offset) {
+        tty->print_cr("two valid result intervals found for op_id %d: %d and %d", op_id, result->reg_num(), tmp->reg_num());
+        result->print();
+        tmp->print();
+        assert(false, "two valid result intervals found");
+      }
+    }
+#endif
+  }
+
+  assert(result != NULL, "no matching interval found");
+  assert(result->covers(op_id, mode), "op_id not covered by interval");
+
+  return result;
+}
+
+
+// returns the last split child that ends before the given op_id
+GreedyInterval* GreedyInterval::split_child_before_op_id(int op_id) {
+  assert(op_id >= 0, "invalid op_id");
+
+  GreedyInterval* parent = split_parent();
+  GreedyInterval* result = NULL;
+
+  int len = parent->_split_children.length();
+  assert(len > 0, "no split children available");
+
+  for (int i = len - 1; i >= 0; i--) {
+    GreedyInterval* cur = parent->_split_children.at(i);
+    if (cur->to() <= op_id && (result == NULL || result->to() < cur->to())) {
+      result = cur;
+    }
+  }
+
+  assert(result != NULL, "no split child found");
+  return result;
+}
+
+
+// checks if op_id is covered by any split child
+bool GreedyInterval::split_child_covers(int op_id, LIR_OpVisitState::OprMode mode) {
+  assert(is_split_parent(), "can only be called for split parents");
+  assert(op_id >= 0, "invalid op_id (method can not be called for spill moves)");
+
+  if (_split_children.length() == 0) {
+    // simple case if interval was not split
+    return covers(op_id, mode);
+
+  } else {
+    // extended case: check all split children
+    int len = _split_children.length();
+    for (int i = 0; i < len; i++) {
+      GreedyInterval* cur = _split_children.at(i);
+      if (cur->covers(op_id, mode)) {
+        return true;
+      }
+    }
+    return false;
+  }
+}
+
+
+// Note: use positions are sorted descending -> first use has highest index
+int GreedyInterval::first_usage(GreedyIntervalUseKind min_use_kind) const {
+  assert(Greedy::is_virtual_interval(this), "cannot access use positions for fixed intervals");
+
+  for (int i = _use_pos_and_kinds.length() - 2; i >= 0; i -= 2) {
+    if (_use_pos_and_kinds.at(i + 1) >= min_use_kind) {
+      return _use_pos_and_kinds.at(i);
+    }
+  }
+  return max_jint;
+}
+
+int GreedyInterval::next_usage(GreedyIntervalUseKind min_use_kind, int from) const {
+  assert(Greedy::is_virtual_interval(this), "cannot access use positions for fixed intervals");
+
+  for (int i = _use_pos_and_kinds.length() - 2; i >= 0; i -= 2) {
+    if (_use_pos_and_kinds.at(i) >= from && _use_pos_and_kinds.at(i + 1) >= min_use_kind) {
+      return _use_pos_and_kinds.at(i);
+    }
+  }
+  return max_jint;
+}
+
+int GreedyInterval::next_usage_exact(GreedyIntervalUseKind exact_use_kind, int from) const {
+  assert(Greedy::is_virtual_interval(this), "cannot access use positions for fixed intervals");
+
+  for (int i = _use_pos_and_kinds.length() - 2; i >= 0; i -= 2) {
+    if (_use_pos_and_kinds.at(i) >= from && _use_pos_and_kinds.at(i + 1) == exact_use_kind) {
+      return _use_pos_and_kinds.at(i);
+    }
+  }
+  return max_jint;
+}
+
+int GreedyInterval::previous_usage(GreedyIntervalUseKind min_use_kind, int from) const {
+  assert(Greedy::is_virtual_interval(this), "cannot access use positions for fixed intervals");
+
+  int prev = 0;
+  for (int i = _use_pos_and_kinds.length() - 2; i >= 0; i -= 2) {
+    if (_use_pos_and_kinds.at(i) > from) {
+      return prev;
+    }
+    if (_use_pos_and_kinds.at(i + 1) >= min_use_kind) {
+      prev = _use_pos_and_kinds.at(i);
+    }
+  }
+  return prev;
+}
+
+void GreedyInterval::add_use_pos(int pos, GreedyIntervalUseKind use_kind) {
+  assert(covers(pos, LIR_OpVisitState::inputMode), "use position not covered by live range");
+
+  // do not add use positions for precolored intervals because
+  // they are never used
+  if (use_kind != noUse && reg_num() >= LIR_OprDesc::vreg_base) {
+#ifdef ASSERT
+    assert(_use_pos_and_kinds.length() % 2 == 0, "must be");
+    for (int i = 0; i < _use_pos_and_kinds.length(); i += 2) {
+      assert(pos <= _use_pos_and_kinds.at(i), "already added a use-position with lower position");
+      assert(_use_pos_and_kinds.at(i + 1) >= firstValidKind && _use_pos_and_kinds.at(i + 1) <= lastValidKind, "invalid use kind");
+      if (i > 0) {
+        assert(_use_pos_and_kinds.at(i) < _use_pos_and_kinds.at(i - 2), "not sorted descending");
+      }
+    }
+#endif
+
+    // Note: add_use is called in descending order, so list gets sorted
+    //       automatically by just appending new use positions
+    int len = _use_pos_and_kinds.length();
+    if (len == 0 || _use_pos_and_kinds.at(len - 2) > pos) {
+      _use_pos_and_kinds.append(pos);
+      _use_pos_and_kinds.append(use_kind);
+    } else if (_use_pos_and_kinds.at(len - 1) < use_kind) {
+      assert(_use_pos_and_kinds.at(len - 2) == pos, "list not sorted correctly");
+      _use_pos_and_kinds.at_put(len - 1, use_kind);
+    }
+  }
+}
+
+void GreedyInterval::add_range(int from, int to) {
+  assert(from < to, "invalid range");
+  assert(first() == GreedyRange::end() || to < first()->next()->from(), "not inserting at begin of interval");
+  assert(from <= first()->to(), "not inserting at begin of interval");
+
+  if (first()->from() <= to) {
+    // join intersecting ranges
+    first()->set_from(MIN2(from, first()->from()));
+    first()->set_to  (MAX2(to,   first()->to()));
+  } else {
+    // insert new range
+    _first = new GreedyRange(from, to, first());
+  }
+}
+
+GreedyInterval* GreedyInterval::new_split_child() {
+  // allocate new interval
+  GreedyInterval* result = new GreedyInterval(-1);
+  result->set_type(type());
+
+  GreedyInterval* parent = split_parent();
+  result->_split_parent = parent;
+  result->set_register_hint(parent);
+
+  // insert new interval in children-list of parent
+  if (parent->_split_children.length() == 0) {
+    assert(is_split_parent(), "list must be initialized at first split");
+
+    parent->_split_children = GreedyIntervalList(4);
+    parent->_split_children.append(this);
+  }
+  parent->_split_children.append(result);
+
+  return result;
+}
+
+// split this interval at the specified position and return
+// the remainder as a new interval.
+//
+// when an interval is split, a bi-directional link is established between the original interval
+// (the split parent) and the intervals that are split off this interval (the split children)
+// When a split child is split again, the new created interval is also a direct child
+// of the original parent (there is no tree of split children stored, but a flat list)
+// All split children are spilled to the same stack slot (stored in _canonical_spill_slot)
+//
+// Note: The new interval has no valid reg_num
+GreedyInterval* GreedyInterval::split(int split_pos) {
+  assert(Greedy::is_virtual_interval(this), "cannot split fixed intervals");
+
+  // allocate new interval
+  GreedyInterval* result = new_split_child();
+
+  // split the ranges
+  GreedyRange* prev = NULL;
+  GreedyRange* cur = _first;
+  while (cur != GreedyRange::end() && cur->to() <= split_pos) {
+    prev = cur;
+    cur = cur->next();
+  }
+  assert(cur != GreedyRange::end(), "split interval after end of last range");
+
+  if (cur->from() < split_pos) {
+    result->_first = new GreedyRange(split_pos, cur->to(), cur->next());
+    cur->set_to(split_pos);
+    cur->set_next(GreedyRange::end());
+
+  } else {
+    assert(prev != NULL, "split before start of first range");
+    result->_first = cur;
+    prev->set_next(GreedyRange::end());
+  }
+  result->_current = result->_first;
+  _cached_to = -1; // clear cached value
+
+  // split list of use positions
+  int total_len = _use_pos_and_kinds.length();
+  int start_idx = total_len - 2;
+  while (start_idx >= 0 && _use_pos_and_kinds.at(start_idx) < split_pos) {
+    start_idx -= 2;
+  }
+
+  intStack new_use_pos_and_kinds(total_len - start_idx);
+  int i;
+  for (i = start_idx + 2; i < total_len; i++) {
+    new_use_pos_and_kinds.append(_use_pos_and_kinds.at(i));
+  }
+
+  _use_pos_and_kinds.truncate(start_idx + 2);
+  result->_use_pos_and_kinds = _use_pos_and_kinds;
+  _use_pos_and_kinds = new_use_pos_and_kinds;
+
+#ifdef ASSERT
+  assert(_use_pos_and_kinds.length() % 2 == 0, "must have use kind for each use pos");
+  assert(result->_use_pos_and_kinds.length() % 2 == 0, "must have use kind for each use pos");
+  assert(_use_pos_and_kinds.length() + result->_use_pos_and_kinds.length() == total_len, "missed some entries");
+
+  for (i = 0; i < _use_pos_and_kinds.length(); i += 2) {
+    assert(_use_pos_and_kinds.at(i) < split_pos, "must be");
+    assert(_use_pos_and_kinds.at(i + 1) >= firstValidKind && _use_pos_and_kinds.at(i + 1) <= lastValidKind, "invalid use kind");
+  }
+  for (i = 0; i < result->_use_pos_and_kinds.length(); i += 2) {
+    assert(result->_use_pos_and_kinds.at(i) >= split_pos, "must be");
+    assert(result->_use_pos_and_kinds.at(i + 1) >= firstValidKind && result->_use_pos_and_kinds.at(i + 1) <= lastValidKind, "invalid use kind");
+  }
+#endif
+
+  return result;
+}
+
+// split this interval at the specified position and return
+// the head as a new interval (the original interval is the tail)
+//
+// Currently, only the first range can be split, and the new interval
+// must not have split positions
+GreedyInterval* GreedyInterval::split_from_start(int split_pos) {
+  assert(Greedy::is_virtual_interval(this), "cannot split fixed intervals");
+  assert(split_pos > from() && split_pos < to(), "can only split inside interval");
+  assert(split_pos > _first->from() && split_pos <= _first->to(), "can only split inside first range");
+  assert(first_usage(noUse) > split_pos, "can not split when use positions are present");
+
+  // allocate new interval
+  GreedyInterval* result = new_split_child();
+
+  // the new created interval has only one range (checked by assertion above),
+  // so the splitting of the ranges is very simple
+  result->add_range(_first->from(), split_pos);
+
+  if (split_pos == _first->to()) {
+    assert(_first->next() != GreedyRange::end(), "must not be at end");
+    _first = _first->next();
+  } else {
+    _first->set_from(split_pos);
+  }
+
+  return result;
+}
+
+
+// returns true if the op_id is inside the interval
+bool GreedyInterval::covers(int op_id, LIR_OpVisitState::OprMode mode) const {
+  GreedyRange* cur  = _first;
+
+  while (cur != GreedyRange::end() && cur->to() < op_id) {
+    cur = cur->next();
+  }
+  if (cur != GreedyRange::end()) {
+    assert(cur->to() != cur->next()->from(), "ranges not separated");
+
+    if (mode == LIR_OpVisitState::outputMode) {
+      return cur->from() <= op_id && op_id < cur->to();
+    } else {
+      return cur->from() <= op_id && op_id <= cur->to();
+    }
+  }
+  return false;
+}
+
+// returns true if the interval has any hole between hole_from and hole_to
+// (even if the hole has only the length 1)
+bool GreedyInterval::has_hole_between(int hole_from, int hole_to) {
+  assert(hole_from < hole_to, "check");
+  assert(from() <= hole_from && hole_to <= to(), "index out of interval");
+
+  GreedyRange* cur  = _first;
+  while (cur != GreedyRange::end()) {
+    assert(cur->to() < cur->next()->from(), "no space between ranges");
+
+    // hole-range starts before this range -> hole
+    if (hole_from < cur->from()) {
+      return true;
+
+    // hole-range completely inside this range -> no hole
+    } else if (hole_to <= cur->to()) {
+      return false;
+
+    // overlapping of hole-range with this range -> hole
+    } else if (hole_from <= cur->to()) {
+      return true;
+    }
+
+    cur = cur->next();
+  }
+
+  return false;
+}
+
+
+#ifndef PRODUCT
+void GreedyInterval::print(outputStream* out) const {
+  const char* SpillState2Name[] = { "no definition", "no spill store", "one spill store", "store at definition", "start in memory", "no optimization" };
+  const char* UseKind2Name[] = { "N", "L", "S", "M" };
+
+  const char* type_name;
+  LIR_Opr opr = LIR_OprFact::illegal();
+  if (reg_num() < LIR_OprDesc::vreg_base) {
+    type_name = "fixed";
+    // need a temporary operand for fixed intervals because type() cannot be called
+    if (assigned_reg() >= pd_first_cpu_reg && assigned_reg() <= pd_last_cpu_reg) {
+      opr = LIR_OprFact::single_cpu(assigned_reg());
+    } else if (assigned_reg() >= pd_first_fpu_reg && assigned_reg() <= pd_last_fpu_reg) {
+      opr = LIR_OprFact::single_fpu(assigned_reg() - pd_first_fpu_reg);
+#ifdef X86
+    } else if (assigned_reg() >= pd_first_xmm_reg && assigned_reg() <= pd_last_xmm_reg) {
+      opr = LIR_OprFact::single_xmm(assigned_reg() - pd_first_xmm_reg);
+#endif
+    } else {
+      ShouldNotReachHere();
+    }
+  } else {
+    type_name = type2name(type());
+    if (assigned_reg() != -1 &&
+        (Greedy::num_physical_regs(type()) == 1 || assigned_regHi() != -1)) {
+      opr = Greedy::calc_operand_for_interval(this);
+    }
+  }
+
+  out->print("%d %s ", reg_num(), type_name);
+  if (opr->is_valid()) {
+    out->print("\"");
+    opr->print(out);
+    out->print("\" ");
+  }
+  out->print("%d %d ", split_parent()->reg_num(), (register_hint(false) != NULL ? register_hint(false)->reg_num() : -1));
+
+  // print ranges
+  GreedyRange* cur = _first;
+  while (cur != GreedyRange::end()) {
+    cur->print(out);
+    cur = cur->next();
+    assert(cur != NULL, "range list not closed with range sentinel");
+  }
+
+  // print use positions
+  int prev = 0;
+  assert(_use_pos_and_kinds.length() % 2 == 0, "must be");
+  for (int i =_use_pos_and_kinds.length() - 2; i >= 0; i -= 2) {
+    assert(_use_pos_and_kinds.at(i + 1) >= firstValidKind && _use_pos_and_kinds.at(i + 1) <= lastValidKind, "invalid use kind");
+    assert(prev < _use_pos_and_kinds.at(i), "use positions not sorted");
+
+    out->print("%d %s ", _use_pos_and_kinds.at(i), UseKind2Name[_use_pos_and_kinds.at(i + 1)]);
+    prev = _use_pos_and_kinds.at(i);
+  }
+
+  out->print(" \"%s\"", SpillState2Name[spill_state()]);
+  out->cr();
+}
+#endif
+
+
+
+// **** Implementation of GreedyIntervalWalker ****************************
+
+GreedyIntervalWalker::GreedyIntervalWalker(Greedy* allocator, GreedyInterval* unhandled_fixed_first, GreedyInterval* unhandled_any_first)
+ : _compilation(allocator->compilation())
+ , _allocator(allocator)
+{
+  _unhandled_first[fixedKind] = unhandled_fixed_first;
+  _unhandled_first[anyKind]   = unhandled_any_first;
+  _active_first[fixedKind]    = GreedyInterval::end();
+  _inactive_first[fixedKind]  = GreedyInterval::end();
+  _active_first[anyKind]      = GreedyInterval::end();
+  _inactive_first[anyKind]    = GreedyInterval::end();
+  _current_position = -1;
+  _current = NULL;
+  next_interval();
+}
+
+
+// append interval at top of list
+void GreedyIntervalWalker::append_unsorted(GreedyInterval** list, GreedyInterval* interval) {
+  interval->set_next(*list); *list = interval;
+}
+
+
+// append interval in order of current range from()
+void GreedyIntervalWalker::append_sorted(GreedyInterval** list, GreedyInterval* interval) {
+  GreedyInterval* prev = NULL;
+  GreedyInterval* cur  = *list;
+  while (cur->current_from() < interval->current_from()) {
+    prev = cur; cur = cur->next();
+  }
+  if (prev == NULL) {
+    *list = interval;
+  } else {
+    prev->set_next(interval);
+  }
+  interval->set_next(cur);
+}
+
+void GreedyIntervalWalker::append_to_unhandled(GreedyInterval** list, GreedyInterval* interval) {
+  assert(interval->from() >= current()->current_from(), "cannot append new interval before current walk position");
+
+  GreedyInterval* prev = NULL;
+  GreedyInterval* cur  = *list;
+  while (cur->from() < interval->from() || (cur->from() == interval->from() && cur->first_usage(noUse) < interval->first_usage(noUse))) {
+    prev = cur; cur = cur->next();
+  }
+  if (prev == NULL) {
+    *list = interval;
+  } else {
+    prev->set_next(interval);
+  }
+  interval->set_next(cur);
+}
+
+
+inline bool GreedyIntervalWalker::remove_from_list(GreedyInterval** list, GreedyInterval* i) {
+  while (*list != GreedyInterval::end() && *list != i) {
+    list = (*list)->next_addr();
+  }
+  if (*list != GreedyInterval::end()) {
+    assert(*list == i, "check");
+    *list = (*list)->next();
+    return true;
+  } else {
+    return false;
+  }
+}
+
+void GreedyIntervalWalker::remove_from_list(GreedyInterval* i) {
+  bool deleted;
+
+  if (i->state() == activeState) {
+    deleted = remove_from_list(active_first_addr(anyKind), i);
+  } else {
+    assert(i->state() == inactiveState, "invalid state");
+    deleted = remove_from_list(inactive_first_addr(anyKind), i);
+  }
+
+  assert(deleted, "interval has not been found in list");
+}
+
+
+void GreedyIntervalWalker::walk_to(GreedyIntervalState state, int from) {
+  assert (state == activeState || state == inactiveState, "wrong state");
+  for_each_interval_kind(kind) {
+    GreedyInterval** prev = state == activeState ? active_first_addr(kind) : inactive_first_addr(kind);
+    GreedyInterval* next   = *prev;
+    while (next->current_from() <= from) {
+      GreedyInterval* cur = next;
+      next = cur->next();
+
+      bool range_has_changed = false;
+      while (cur->current_to() <= from) {
+        cur->next_range();
+        range_has_changed = true;
+      }
+
+      // also handle move from inactive list to active list
+      range_has_changed = range_has_changed || (state == inactiveState && cur->current_from() <= from);
+
+      if (range_has_changed) {
+        // remove cur from list
+        *prev = next;
+        if (cur->current_at_end()) {
+          // move to handled state (not maintained as a list)
+          cur->set_state(handledState);
+          interval_moved(cur, kind, state, handledState);
+        } else if (cur->current_from() <= from){
+          // sort into active list
+          append_sorted(active_first_addr(kind), cur);
+          cur->set_state(activeState);
+          if (*prev == cur) {
+            assert(state == activeState, "check");
+            prev = cur->next_addr();
+          }
+          interval_moved(cur, kind, state, activeState);
+        } else {
+          // sort into inactive list
+          append_sorted(inactive_first_addr(kind), cur);
+          cur->set_state(inactiveState);
+          if (*prev == cur) {
+            assert(state == inactiveState, "check");
+            prev = cur->next_addr();
+          }
+          interval_moved(cur, kind, state, inactiveState);
+        }
+      } else {
+        prev = cur->next_addr();
+        continue;
+      }
+    }
+  }
+}
+
+
+void GreedyIntervalWalker::next_interval() {
+  GreedyIntervalKind kind;
+  GreedyInterval* any   = _unhandled_first[anyKind];
+  GreedyInterval* fixed = _unhandled_first[fixedKind];
+
+  if (any != GreedyInterval::end()) {
+    // intervals may start at same position -> prefer fixed interval
+    kind = fixed != GreedyInterval::end() && fixed->from() <= any->from() ? fixedKind : anyKind;
+
+    assert (kind == fixedKind && fixed->from() <= any->from() ||
+            kind == anyKind   && any->from() <= fixed->from(), "wrong interval!!!");
+    assert(any == GreedyInterval::end() || fixed == GreedyInterval::end() || any->from() != fixed->from() || kind == fixedKind, "if fixed and any-GreedyInterval start at same position, fixed must be processed first");
+
+  } else if (fixed != GreedyInterval::end()) {
+    kind = fixedKind;
+  } else {
+    _current = NULL; return;
+  }
+  _current_kind = kind;
+  _current = _unhandled_first[kind];
+  _unhandled_first[kind] = _current->next();
+  _current->set_next(GreedyInterval::end());
+  _current->rewind_range();
+}
+
+
+void GreedyIntervalWalker::walk_to(int lir_op_id) {
+  assert(_current_position <= lir_op_id, "can not walk backwards");
+  while (current() != NULL) {
+    bool is_active = current()->from() <= lir_op_id;
+    int id = is_active ? current()->from() : lir_op_id;
+
+    TRACE_GREEDY(2, if (_current_position < id) { tty->cr(); tty->print_cr("walk_to(%d) **************************************************************", id); })
+
+    // set _current_position prior to call of walk_to
+    _current_position = id;
+
+    // call walk_to even if _current_position == id
+    walk_to(activeState, id);
+    walk_to(inactiveState, id);
+
+    if (is_active) {
+      current()->set_state(activeState);
+      if (activate_current()) {
+        append_sorted(active_first_addr(current_kind()), current());
+        interval_moved(current(), current_kind(), unhandledState, activeState);
+      }
+
+      next_interval();
+    } else {
+      return;
+    }
+  }
+}
+
+void GreedyIntervalWalker::interval_moved(GreedyInterval* interval, GreedyIntervalKind kind, GreedyIntervalState from, GreedyIntervalState to) {
+#ifndef PRODUCT
+  if (TraceGreedyLevel >= 4) {
+    #define print_state(state) \
+    switch(state) {\
+      case unhandledState: tty->print("unhandled"); break;\
+      case activeState: tty->print("active"); break;\
+      case inactiveState: tty->print("inactive"); break;\
+      case handledState: tty->print("handled"); break;\
+      default: ShouldNotReachHere(); \
+    }
+
+    print_state(from); tty->print(" to "); print_state(to);
+    tty->fill_to(23);
+    interval->print();
+
+    #undef print_state
+  }
+#endif
+}
+
+
+
+// **** Implementation of GreedyWalker **************************
+
+GreedyWalker::GreedyWalker(Greedy* allocator, GreedyInterval* unhandled_fixed_first, GreedyInterval* unhandled_any_first)
+  : GreedyIntervalWalker(allocator, unhandled_fixed_first, unhandled_any_first)
+  , _move_resolver(allocator)
+{
+  for (int i = 0; i < Greedy::nof_regs; i++) {
+    _spill_intervals[i] = new GreedyIntervalList(2);
+  }
+}
+
+
+inline void GreedyWalker::init_use_lists(bool only_process_use_pos) {
+  for (int i = _first_reg; i <= _last_reg; i++) {
+    _use_pos[i] = max_jint;
+
+    if (!only_process_use_pos) {
+      _block_pos[i] = max_jint;
+      _spill_intervals[i]->clear();
+    }
+  }
+}
+
+inline void GreedyWalker::exclude_from_use(int reg) {
+  assert(reg < Greedy::nof_regs, "interval must have a register assigned (stack slots not allowed)");
+  if (reg >= _first_reg && reg <= _last_reg) {
+    _use_pos[reg] = 0;
+  }
+}
+inline void GreedyWalker::exclude_from_use(GreedyInterval* i) {
+  assert(i->assigned_reg() != any_reg, "interval has no register assigned");
+
+  exclude_from_use(i->assigned_reg());
+  exclude_from_use(i->assigned_regHi());
+}
+
+inline void GreedyWalker::set_use_pos(int reg, GreedyInterval* i, int use_pos, bool only_process_use_pos) {
+  assert(use_pos != 0, "must use exclude_from_use to set use_pos to 0");
+
+  if (reg >= _first_reg && reg <= _last_reg) {
+    if (_use_pos[reg] > use_pos) {
+      _use_pos[reg] = use_pos;
+    }
+    if (!only_process_use_pos) {
+      _spill_intervals[reg]->append(i);
+    }
+  }
+}
+inline void GreedyWalker::set_use_pos(GreedyInterval* i, int use_pos, bool only_process_use_pos) {
+  assert(i->assigned_reg() != any_reg, "interval has no register assigned");
+  if (use_pos != -1) {
+    set_use_pos(i->assigned_reg(), i, use_pos, only_process_use_pos);
+    set_use_pos(i->assigned_regHi(), i, use_pos, only_process_use_pos);
+  }
+}
+
+inline void GreedyWalker::set_block_pos(int reg, GreedyInterval* i, int block_pos) {
+  if (reg >= _first_reg && reg <= _last_reg) {
+    if (_block_pos[reg] > block_pos) {
+      _block_pos[reg] = block_pos;
+    }
+    if (_use_pos[reg] > block_pos) {
+      _use_pos[reg] = block_pos;
+    }
+  }
+}
+inline void GreedyWalker::set_block_pos(GreedyInterval* i, int block_pos) {
+  assert(i->assigned_reg() != any_reg, "interval has no register assigned");
+  if (block_pos != -1) {
+    set_block_pos(i->assigned_reg(), i, block_pos);
+    set_block_pos(i->assigned_regHi(), i, block_pos);
+  }
+}
+
+
+void GreedyWalker::free_exclude_active_fixed() {
+  GreedyInterval* list = active_first(fixedKind);
+  while (list != GreedyInterval::end()) {
+    assert(list->assigned_reg() < Greedy::nof_regs, "active interval must have a register assigned");
+    exclude_from_use(list);
+    list = list->next();
+  }
+}
+
+void GreedyWalker::free_exclude_active_any() {
+  GreedyInterval* list = active_first(anyKind);
+  while (list != GreedyInterval::end()) {
+    exclude_from_use(list);
+    list = list->next();
+  }
+}
+
+void GreedyWalker::free_collect_inactive_fixed(GreedyInterval* cur) {
+  GreedyInterval* list = inactive_first(fixedKind);
+  while (list != GreedyInterval::end()) {
+    if (cur->to() <= list->current_from()) {
+      assert(list->current_intersects_at(cur) == -1, "must not intersect");
+      set_use_pos(list, list->current_from(), true);
+    } else {
+      set_use_pos(list, list->current_intersects_at(cur), true);
+    }
+    list = list->next();
+  }
+}
+
+void GreedyWalker::free_collect_inactive_any(GreedyInterval* cur) {
+  GreedyInterval* list = inactive_first(anyKind);
+  while (list != GreedyInterval::end()) {
+    set_use_pos(list, list->current_intersects_at(cur), true);
+    list = list->next();
+  }
+}
+
+void GreedyWalker::free_collect_unhandled(GreedyIntervalKind kind, GreedyInterval* cur) {
+  GreedyInterval* list = unhandled_first(kind);
+  while (list != GreedyInterval::end()) {
+    set_use_pos(list, list->intersects_at(cur), true);
+    if (kind == fixedKind && cur->to() <= list->from()) {
+      set_use_pos(list, list->from(), true);
+    }
+    list = list->next();
+  }
+}
+
+void GreedyWalker::spill_exclude_active_fixed() {
+  GreedyInterval* list = active_first(fixedKind);
+  while (list != GreedyInterval::end()) {
+    exclude_from_use(list);
+    list = list->next();
+  }
+}
+
+void GreedyWalker::spill_block_unhandled_fixed(GreedyInterval* cur) {
+  GreedyInterval* list = unhandled_first(fixedKind);
+  while (list != GreedyInterval::end()) {
+    set_block_pos(list, list->intersects_at(cur));
+    list = list->next();
+  }
+}
+
+void GreedyWalker::spill_block_inactive_fixed(GreedyInterval* cur) {
+  GreedyInterval* list = inactive_first(fixedKind);
+  while (list != GreedyInterval::end()) {
+    if (cur->to() > list->current_from()) {
+      set_block_pos(list, list->current_intersects_at(cur));
+    } else {
+      assert(list->current_intersects_at(cur) == -1, "invalid optimization: intervals intersect");
+    }
+
+    list = list->next();
+  }
+}
+
+void GreedyWalker::spill_collect_active_any() {
+  GreedyInterval* list = active_first(anyKind);
+  while (list != GreedyInterval::end()) {
+    set_use_pos(list, MIN2(list->next_usage(loopEndMarker, _current_position), list->to()), false);
+    list = list->next();
+  }
+}
+
+void GreedyWalker::spill_collect_inactive_any(GreedyInterval* cur) {
+  GreedyInterval* list = inactive_first(anyKind);
+  while (list != GreedyInterval::end()) {
+    if (list->current_intersects(cur)) {
+      set_use_pos(list, MIN2(list->next_usage(loopEndMarker, _current_position), list->to()), false);
+    }
+    list = list->next();
+  }
+}
+
+
+void GreedyWalker::insert_move(int op_id, GreedyInterval* src_it, GreedyInterval* dst_it) {
+  // output all moves here. When source and target are equal, the move is
+  // optimized away later in assign_reg_nums
+
+  op_id = (op_id + 1) & ~1;
+  BlockBegin* op_block = allocator()->block_of_op_with_id(op_id);
+  assert(op_id > 0 && allocator()->block_of_op_with_id(op_id - 2) == op_block, "cannot insert move at block boundary");
+
+  // calculate index of instruction inside instruction list of current block
+  // the minimal index (for a block with no spill moves) can be calculated because the
+  // numbering of instructions is known.
+  // When the block already contains spill moves, the index must be increased until the
+  // correct index is reached.
+  LIR_OpList* list = op_block->lir()->instructions_list();
+  int index = (op_id - list->at(0)->id()) / 2;
+  assert(list->at(index)->id() <= op_id, "error in calculation");
+
+  while (list->at(index)->id() != op_id) {
+    index++;
+    assert(0 <= index && index < list->length(), "index out of bounds");
+  }
+  assert(1 <= index && index < list->length(), "index out of bounds");
+  assert(list->at(index)->id() == op_id, "error in calculation");
+
+  // insert new instruction before instruction at position index
+  _move_resolver.move_insert_position(op_block->lir(), index - 1);
+  _move_resolver.add_mapping(src_it, dst_it);
+}
+
+
+int GreedyWalker::find_optimal_split_pos(BlockBegin* min_block, BlockBegin* max_block, int max_split_pos) {
+  int from_block_nr = min_block->greedy_number();
+  int to_block_nr = max_block->greedy_number();
+
+  assert(0 <= from_block_nr && from_block_nr < block_count(), "out of range");
+  assert(0 <= to_block_nr && to_block_nr < block_count(), "out of range");
+  assert(from_block_nr < to_block_nr, "must cross block boundary");
+
+  // Try to split at end of max_block. If this would be after
+  // max_split_pos, then use the begin of max_block
+  int optimal_split_pos = max_block->last_lir_instruction_id() + 2;
+  if (optimal_split_pos > max_split_pos) {
+    optimal_split_pos = max_block->first_lir_instruction_id();
+  }
+
+  int min_loop_depth = max_block->loop_depth();
+  for (int i = to_block_nr - 1; i >= from_block_nr; i--) {
+    BlockBegin* cur = block_at(i);
+
+    if (cur->loop_depth() < min_loop_depth) {
+      // block with lower loop-depth found -> split at the end of this block
+      min_loop_depth = cur->loop_depth();
+      optimal_split_pos = cur->last_lir_instruction_id() + 2;
+    }
+  }
+  assert(optimal_split_pos > allocator()->max_lir_op_id() || allocator()->is_block_begin(optimal_split_pos), "algorithm must move split pos to block boundary");
+
+  return optimal_split_pos;
+}
+
+
+int GreedyWalker::find_optimal_split_pos(GreedyInterval* it, int min_split_pos, int max_split_pos, bool do_loop_optimization) {
+  int optimal_split_pos = -1;
+  if (min_split_pos == max_split_pos) {
+    // trivial case, no optimization of split position possible
+    TRACE_GREEDY(4, tty->print_cr("      min-pos and max-pos are equal, no optimization possible"));
+    optimal_split_pos = min_split_pos;
+
+  } else {
+    assert(min_split_pos < max_split_pos, "must be true then");
+    assert(min_split_pos > 0, "cannot access min_split_pos - 1 otherwise");
+
+    // reason for using min_split_pos - 1: when the minimal split pos is exactly at the
+    // beginning of a block, then min_split_pos is also a possible split position.
+    // Use the block before as min_block, because then min_block->last_lir_instruction_id() + 2 == min_split_pos
+    BlockBegin* min_block = allocator()->block_of_op_with_id(min_split_pos - 1);
+
+    // reason for using max_split_pos - 1: otherwise there would be an assertion failure
+    // when an interval ends at the end of the last block of the method
+    // (in this case, max_split_pos == allocator()->max_lir_op_id() + 2, and there is no
+    // block at this op_id)
+    BlockBegin* max_block = allocator()->block_of_op_with_id(max_split_pos - 1);
+
+    assert(min_block->greedy_number() <= max_block->greedy_number(), "invalid order");
+    if (min_block == max_block) {
+      // split position cannot be moved to block boundary, so split as late as possible
+      TRACE_GREEDY(4, tty->print_cr("      cannot move split pos to block boundary because min_pos and max_pos are in same block"));
+      optimal_split_pos = max_split_pos;
+
+    } else if (it->has_hole_between(max_split_pos - 1, max_split_pos) && !allocator()->is_block_begin(max_split_pos)) {
+      // Do not move split position if the interval has a hole before max_split_pos.
+      // GreedyIntervals resulting from Phi-Functions have more than one definition (marked
+      // as mustHaveRegister) with a hole before each definition. When the register is needed
+      // for the second definition, an earlier reloading is unnecessary.
+      TRACE_GREEDY(4, tty->print_cr("      interval has hole just before max_split_pos, so splitting at max_split_pos"));
+      optimal_split_pos = max_split_pos;
+
+    } else {
+      // seach optimal block boundary between min_split_pos and max_split_pos
+      TRACE_GREEDY(4, tty->print_cr("      moving split pos to optimal block boundary between block B%d and B%d", min_block->block_id(), max_block->block_id()));
+
+      if (do_loop_optimization) {
+        // Loop optimization: if a loop-end marker is found between min- and max-position,
+        // then split before this loop
+        int loop_end_pos = it->next_usage_exact(loopEndMarker, min_block->last_lir_instruction_id() + 2);
+        TRACE_GREEDY(4, tty->print_cr("      loop optimization: loop end found at pos %d", loop_end_pos));
+
+        assert(loop_end_pos > min_split_pos, "invalid order");
+        if (loop_end_pos < max_split_pos) {
+          // loop-end marker found between min- and max-position
+          // if it is not the end marker for the same loop as the min-position, then move
+          // the max-position to this loop block.
+          // Desired result: uses tagged as shouldHaveRegister inside a loop cause a reloading
+          // of the interval (normally, only mustHaveRegister causes a reloading)
+          BlockBegin* loop_block = allocator()->block_of_op_with_id(loop_end_pos);
+
+          TRACE_GREEDY(4, tty->print_cr("      interval is used in loop that ends in block B%d, so trying to move max_block back from B%d to B%d", loop_block->block_id(), max_block->block_id(), loop_block->block_id()));
+          assert(loop_block != min_block, "loop_block and min_block must be different because block boundary is needed between");
+
+          optimal_split_pos = find_optimal_split_pos(min_block, loop_block, loop_block->last_lir_instruction_id() + 2);
+          if (optimal_split_pos == loop_block->last_lir_instruction_id() + 2) {
+            optimal_split_pos = -1;
+            TRACE_GREEDY(4, tty->print_cr("      loop optimization not necessary"));
+          } else {
+            TRACE_GREEDY(4, tty->print_cr("      loop optimization successful"));
+          }
+        }
+      }
+
+      if (optimal_split_pos == -1) {
+        // not calculated by loop optimization
+        optimal_split_pos = find_optimal_split_pos(min_block, max_block, max_split_pos);
+      }
+    }
+  }
+  TRACE_GREEDY(4, tty->print_cr("      optimal split position: %d", optimal_split_pos));
+
+  return optimal_split_pos;
+}
+
+
+/*
+  split an interval at the optimal position between min_split_pos and
+  max_split_pos in two parts:
+  1) the left part has already a location assigned
+  2) the right part is sorted into to the unhandled-list
+*/
+void GreedyWalker::split_before_usage(GreedyInterval* it, int min_split_pos, int max_split_pos) {
+  TRACE_GREEDY(2, tty->print   ("----- splitting interval: "); it->print());
+  TRACE_GREEDY(2, tty->print_cr("      between %d and %d", min_split_pos, max_split_pos));
+
+  assert(it->from() < min_split_pos,         "cannot split at start of interval");
+  assert(current_position() < min_split_pos, "cannot split before current position");
+  assert(min_split_pos <= max_split_pos,     "invalid order");
+  assert(max_split_pos <= it->to(),          "cannot split after end of interval");
+
+  int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, true);
+
+  assert(min_split_pos <= optimal_split_pos && optimal_split_pos <= max_split_pos, "out of range");
+  assert(optimal_split_pos <= it->to(),  "cannot split after end of interval");
+  assert(optimal_split_pos > it->from(), "cannot split at start of interval");
+
+  if (optimal_split_pos == it->to() && it->next_usage(mustHaveRegister, min_split_pos) == max_jint) {
+    // the split position would be just before the end of the interval
+    // -> no split at all necessary
+    TRACE_GREEDY(4, tty->print_cr("      no split necessary because optimal split position is at end of interval"));
+    return;
+  }
+
+  // must calculate this before the actual split is performed and before split position is moved to odd op_id
+  bool move_necessary = !allocator()->is_block_begin(optimal_split_pos) && !it->has_hole_between(optimal_split_pos - 1, optimal_split_pos);
+
+  if (!allocator()->is_block_begin(optimal_split_pos)) {
+    // move position before actual instruction (odd op_id)
+    optimal_split_pos = (optimal_split_pos - 1) | 1;
+  }
+
+  TRACE_GREEDY(4, tty->print_cr("      splitting at position %d", optimal_split_pos));
+  assert(allocator()->is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 1), "split pos must be odd when not on block boundary");
+  assert(!allocator()->is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), "split pos must be even on block boundary");
+
+  GreedyInterval* split_part = it->split(optimal_split_pos);
+
+  allocator()->append_interval(split_part);
+  allocator()->copy_register_flags(it, split_part);
+  split_part->set_insert_move_when_activated(move_necessary);
+  append_to_unhandled(unhandled_first_addr(anyKind), split_part);
+
+  TRACE_GREEDY(2, tty->print_cr("      split interval in two parts (insert_move_when_activated: %d)", move_necessary));
+  TRACE_GREEDY(2, tty->print   ("      "); it->print());
+  TRACE_GREEDY(2, tty->print   ("      "); split_part->print());
+}
+
+/*
+  split an interval at the optimal position between min_split_pos and
+  max_split_pos in two parts:
+  1) the left part has already a location assigned
+  2) the right part is always on the stack and therefore ignored in further processing
+*/
+void GreedyWalker::split_for_spilling(GreedyInterval* it) {
+  // calculate allowed range of splitting position
+  int max_split_pos = current_position();
+  int min_split_pos = MAX2(it->previous_usage(shouldHaveRegister, max_split_pos) + 1, it->from());
+
+  TRACE_GREEDY(2, tty->print   ("----- splitting and spilling interval: "); it->print());
+  TRACE_GREEDY(2, tty->print_cr("      between %d and %d", min_split_pos, max_split_pos));
+
+  assert(it->state() == activeState,     "why spill interval that is not active?");
+  assert(it->from() <= min_split_pos,    "cannot split before start of interval");
+  assert(min_split_pos <= max_split_pos, "invalid order");
+  assert(max_split_pos < it->to(),       "cannot split at end end of interval");
+  assert(current_position() < it->to(),  "interval must not end before current position");
+
+  if (min_split_pos == it->from()) {
+    // the whole interval is never used, so spill it entirely to memory
+    TRACE_GREEDY(2, tty->print_cr("      spilling entire interval because split pos is at beginning of interval"));
+    assert(it->first_usage(shouldHaveRegister) > current_position(), "interval must not have use position before current_position");
+
+    allocator()->assign_spill_slot(it);
+    allocator()->change_spill_state(it, min_split_pos);
+
+    // Also kick parent intervals out of register to memory when they have no use
+    // position. This avoids short interval in register surrounded by intervals in
+    // memory -> avoid useless moves from memory to register and back
+    GreedyInterval* parent = it;
+    while (parent != NULL && parent->is_split_child()) {
+      parent = parent->split_child_before_op_id(parent->from());
+
+      if (parent->assigned_reg() < Greedy::nof_regs) {
+        if (parent->first_usage(shouldHaveRegister) == max_jint) {
+          // parent is never used, so kick it out of its assigned register
+          TRACE_GREEDY(4, tty->print_cr("      kicking out interval %d out of its register because it is never used", parent->reg_num()));
+          allocator()->assign_spill_slot(parent);
+        } else {
+          // do not go further back because the register is actually used by the interval
+          parent = NULL;
+        }
+      }
+    }
+
+  } else {
+    // search optimal split pos, split interval and spill only the right hand part
+    int optimal_split_pos = find_optimal_split_pos(it, min_split_pos, max_split_pos, false);
+
+    assert(min_split_pos <= optimal_split_pos && optimal_split_pos <= max_split_pos, "out of range");
+    assert(optimal_split_pos < it->to(), "cannot split at end of interval");
+    assert(optimal_split_pos >= it->from(), "cannot split before start of interval");
+
+    if (!allocator()->is_block_begin(optimal_split_pos)) {
+      // move position before actual instruction (odd op_id)
+      optimal_split_pos = (optimal_split_pos - 1) | 1;
+    }
+
+    TRACE_GREEDY(4, tty->print_cr("      splitting at position %d", optimal_split_pos));
+    assert(allocator()->is_block_begin(optimal_split_pos)  || (optimal_split_pos % 2 == 1), "split pos must be odd when not on block boundary");
+    assert(!allocator()->is_block_begin(optimal_split_pos) || (optimal_split_pos % 2 == 0), "split pos must be even on block boundary");
+
+    GreedyInterval* spilled_part = it->split(optimal_split_pos);
+    allocator()->append_interval(spilled_part);
+    allocator()->assign_spill_slot(spilled_part);
+    allocator()->change_spill_state(spilled_part, optimal_split_pos);
+
+    if (!allocator()->is_block_begin(optimal_split_pos)) {
+      TRACE_GREEDY(4, tty->print_cr("      inserting move from interval %d to %d", it->reg_num(), spilled_part->reg_num()));
+      insert_move(optimal_split_pos, it, spilled_part);
+    }
+
+    // the current_split_child is needed later when moves are inserted for reloading
+    assert(spilled_part->current_split_child() == it, "overwriting wrong current_split_child");
+    spilled_part->make_current_split_child();
+
+    TRACE_GREEDY(2, tty->print_cr("      split interval in two parts"));
+    TRACE_GREEDY(2, tty->print   ("      "); it->print());
+    TRACE_GREEDY(2, tty->print   ("      "); spilled_part->print());
+  }
+}
+
+
+void GreedyWalker::split_stack_interval(GreedyInterval* it) {
+  int min_split_pos = current_position() + 1;
+  int max_split_pos = MIN2(it->first_usage(shouldHaveRegister), it->to());
+
+  split_before_usage(it, min_split_pos, max_split_pos);
+}
+
+void GreedyWalker::split_when_partial_register_available(GreedyInterval* it, int register_available_until) {
+  int min_split_pos = MAX2(it->previous_usage(shouldHaveRegister, register_available_until), it->from() + 1);
+  int max_split_pos = register_available_until;
+
+  split_before_usage(it, min_split_pos, max_split_pos);
+}
+
+void GreedyWalker::split_and_spill_interval(GreedyInterval* it) {
+  assert(it->state() == activeState || it->state() == inactiveState, "other states not allowed");
+
+  int current_pos = current_position();
+  if (it->state() == inactiveState) {
+    // the interval is currently inactive, so no spill slot is needed for now.
+    // when the split part is activated, the interval has a new chance to get a register,
+    // so in the best case no stack slot is necessary
+    assert(it->has_hole_between(current_pos - 1, current_pos + 1), "interval can not be inactive otherwise");
+    split_before_usage(it, current_pos + 1, current_pos + 1);
+
+  } else {
+    // search the position where the interval must have a register and split
+    // at the optimal position before.
+    // The new created part is added to the unhandled list and will get a register
+    // when it is activated
+    int min_split_pos = current_pos + 1;
+    int max_split_pos = MIN2(it->next_usage(mustHaveRegister, min_split_pos), it->to());
+
+    split_before_usage(it, min_split_pos, max_split_pos);
+
+    assert(it->next_usage(mustHaveRegister, current_pos) == max_jint, "the remaining part is spilled to stack and therefore has no register");
+    split_for_spilling(it);
+  }
+}
+
+
+int GreedyWalker::find_free_reg(int reg_needed_until, int interval_to, int hint_reg, int ignore_reg, bool* need_split) {
+  int min_full_reg = any_reg;
+  int max_partial_reg = any_reg;
+
+  for (int i = _first_reg; i <= _last_reg; i++) {
+    if (i == ignore_reg) {
+      // this register must be ignored
+
+    } else if (_use_pos[i] >= interval_to) {
+      // this register is free for the full interval
+      if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] < _use_pos[min_full_reg] && min_full_reg != hint_reg)) {
+        min_full_reg = i;
+      }
+    } else if (_use_pos[i] > reg_needed_until) {
+      // this register is at least free until reg_needed_until
+      if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] > _use_pos[max_partial_reg] && max_partial_reg != hint_reg)) {
+        max_partial_reg = i;
+      }
+    }
+  }
+
+  if (min_full_reg != any_reg) {
+    return min_full_reg;
+  } else if (max_partial_reg != any_reg) {
+    *need_split = true;
+    return max_partial_reg;
+  } else {
+    return any_reg;
+  }
+}
+
+int GreedyWalker::find_free_double_reg(int reg_needed_until, int interval_to, int hint_reg, bool* need_split) {
+  assert((_last_reg - _first_reg + 1) % 2 == 0, "adjust algorithm");
+
+  int min_full_reg = any_reg;
+  int max_partial_reg = any_reg;
+
+  for (int i = _first_reg; i < _last_reg; i+=2) {
+    if (_use_pos[i] >= interval_to && _use_pos[i + 1] >= interval_to) {
+      // this register is free for the full interval
+      if (min_full_reg == any_reg || i == hint_reg || (_use_pos[i] < _use_pos[min_full_reg] && min_full_reg != hint_reg)) {
+        min_full_reg = i;
+      }
+    } else if (_use_pos[i] > reg_needed_until && _use_pos[i + 1] > reg_needed_until) {
+      // this register is at least free until reg_needed_until
+      if (max_partial_reg == any_reg || i == hint_reg || (_use_pos[i] > _use_pos[max_partial_reg] && max_partial_reg != hint_reg)) {
+        max_partial_reg = i;
+      }
+    }
+  }
+
+  if (min_full_reg != any_reg) {
+    return min_full_reg;
+  } else if (max_partial_reg != any_reg) {
+    *need_split = true;
+    return max_partial_reg;
+  } else {
+    return any_reg;
+  }
+}
+
+
+bool GreedyWalker::alloc_free_reg(GreedyInterval* cur) {
+  TRACE_GREEDY(2, tty->print("trying to find free register for "); cur->print());
+
+  init_use_lists(true);
+  free_exclude_active_fixed();
+  free_exclude_active_any();
+  free_collect_inactive_fixed(cur);
+  free_collect_inactive_any(cur);
+//  free_collect_unhandled(fixedKind, cur);
+  assert(unhandled_first(fixedKind) == GreedyInterval::end(), "must not have unhandled fixed intervals because all fixed intervals have a use at position 0");
+
+  // _use_pos contains the start of the next interval that has this register assigned
+  // (either as a fixed register or a normal allocated register in the past)
+  // only intervals overlapping with cur are processed, non-overlapping invervals can be ignored safely
+  TRACE_GREEDY(4, tty->print_cr("      state of registers:"));
+  TRACE_GREEDY(4, for (int i = _first_reg; i <= _last_reg; i++) tty->print_cr("      reg %d: use_pos: %d", i, _use_pos[i]));
+
+  int hint_reg, hint_regHi;
+  GreedyInterval* register_hint = cur->register_hint();
+  if (register_hint != NULL) {
+    hint_reg = register_hint->assigned_reg();
+    hint_regHi = register_hint->assigned_regHi();
+
+    if (allocator()->is_precolored_cpu_interval(register_hint)) {
+      assert(hint_reg != any_reg && hint_regHi == any_reg, "must be for fixed intervals");
+      hint_regHi = hint_reg + 1;  // connect e.g. eax-edx
+    }
+    TRACE_GREEDY(4, tty->print("      hint registers %d, %d from interval ", hint_reg, hint_regHi); register_hint->print());
+
+  } else {
+    hint_reg = any_reg;
+    hint_regHi = any_reg;
+  }
+  assert(hint_reg == any_reg || hint_reg != hint_regHi, "hint reg and regHi equal");
+  assert(cur->assigned_reg() == any_reg && cur->assigned_regHi() == any_reg, "register already assigned to interval");
+
+  // the register must be free at least until this position
+  int reg_needed_until = cur->from() + 1;
+  int interval_to = cur->to();
+
+  bool need_split = false;
+  int split_pos = -1;
+  int reg = any_reg;
+  int regHi = any_reg;
+
+  if (_adjacent_regs) {
+    reg = find_free_double_reg(reg_needed_until, interval_to, hint_reg, &need_split);
+    regHi = reg + 1;
+    if (reg == any_reg) {
+      return false;
+    }
+    split_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
+
+  } else {
+    reg = find_free_reg(reg_needed_until, interval_to, hint_reg, any_reg, &need_split);
+    if (reg == any_reg) {
+      return false;
+    }
+    split_pos = _use_pos[reg];
+
+    if (_num_phys_regs == 2) {
+      regHi = find_free_reg(reg_needed_until, interval_to, hint_regHi, reg, &need_split);
+
+      if (_use_pos[reg] < interval_to && regHi == any_reg) {
+        // do not split interval if only one register can be assigned until the split pos
+        // (when one register is found for the whole interval, split&spill is only
+        // performed for the hi register)
+        return false;
+
+      } else if (regHi != any_reg) {
+        split_pos = MIN2(split_pos, _use_pos[regHi]);
+
+        // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
+        if (reg > regHi) {
+          int temp = reg;
+          reg = regHi;
+          regHi = temp;
+        }
+      }
+    }
+  }
+
+  cur->assign_reg(reg, regHi);
+  TRACE_GREEDY(2, tty->print_cr("selected register %d, %d", reg, regHi));
+
+  assert(split_pos > 0, "invalid split_pos");
+  if (need_split) {
+    // register not available for full interval, so split it
+    split_when_partial_register_available(cur, split_pos);
+  }
+
+  // only return true if interval is completely assigned
+  return _num_phys_regs == 1 || regHi != any_reg;
+}
+
+
+int GreedyWalker::find_locked_reg(int reg_needed_until, int interval_to, int hint_reg, int ignore_reg, bool* need_split) {
+  int max_reg = any_reg;
+
+  for (int i = _first_reg; i <= _last_reg; i++) {
+    if (i == ignore_reg) {
+      // this register must be ignored
+
+    } else if (_use_pos[i] > reg_needed_until) {
+      if (max_reg == any_reg || i == hint_reg || (_use_pos[i] > _use_pos[max_reg] && max_reg != hint_reg)) {
+        max_reg = i;
+      }
+    }
+  }
+
+  if (max_reg != any_reg && _block_pos[max_reg] <= interval_to) {
+    *need_split = true;
+  }
+
+  return max_reg;
+}
+
+int GreedyWalker::find_locked_double_reg(int reg_needed_until, int interval_to, int hint_reg, bool* need_split) {
+  assert((_last_reg - _first_reg + 1) % 2 == 0, "adjust algorithm");
+
+  int max_reg = any_reg;
+
+  for (int i = _first_reg; i < _last_reg; i+=2) {
+    if (_use_pos[i] > reg_needed_until && _use_pos[i + 1] > reg_needed_until) {
+      if (max_reg == any_reg || _use_pos[i] > _use_pos[max_reg]) {
+        max_reg = i;
+      }
+    }
+  }
+
+  if (_block_pos[max_reg] <= interval_to || _block_pos[max_reg + 1] <= interval_to) {
+    *need_split = true;
+  }
+
+  return max_reg;
+}
+
+void GreedyWalker::split_and_spill_intersecting_intervals(int reg, int regHi) {
+  assert(reg != any_reg, "no register assigned");
+
+  for (int i = 0; i < _spill_intervals[reg]->length(); i++) {
+    GreedyInterval* it = _spill_intervals[reg]->at(i);
+    remove_from_list(it);
+    split_and_spill_interval(it);
+  }
+
+  if (regHi != any_reg) {
+    GreedyIntervalList* processed = _spill_intervals[reg];
+    for (int i = 0; i < _spill_intervals[regHi]->length(); i++) {
+      GreedyInterval* it = _spill_intervals[regHi]->at(i);
+      if (processed->index_of(it) == -1) {
+        remove_from_list(it);
+        split_and_spill_interval(it);
+      }
+    }
+  }
+}
+
+
+// Split an GreedyInterval and spill it to memory so that cur can be placed in a register
+void GreedyWalker::alloc_locked_reg(GreedyInterval* cur) {
+  TRACE_GREEDY(2, tty->print("need to split and spill to get register for "); cur->print());
+
+  // collect current usage of registers
+  init_use_lists(false);
+  spill_exclude_active_fixed();
+//  spill_block_unhandled_fixed(cur);
+  assert(unhandled_first(fixedKind) == GreedyInterval::end(), "must not have unhandled fixed intervals because all fixed intervals have a use at position 0");
+  spill_block_inactive_fixed(cur);
+  spill_collect_active_any();
+  spill_collect_inactive_any(cur);
+
+#ifndef PRODUCT
+  if (TraceGreedyLevel >= 4) {
+    tty->print_cr("      state of registers:");
+    for (int i = _first_reg; i <= _last_reg; i++) {
+      tty->print("      reg %d: use_pos: %d, block_pos: %d, intervals: ", i, _use_pos[i], _block_pos[i]);
+      for (int j = 0; j < _spill_intervals[i]->length(); j++) {
+        tty->print("%d ", _spill_intervals[i]->at(j)->reg_num());
+      }
+      tty->cr();
+    }
+  }
+#endif
+
+  // the register must be free at least until this position
+  int reg_needed_until = MIN2(cur->first_usage(mustHaveRegister), cur->from() + 1);
+  int interval_to = cur->to();
+  assert (reg_needed_until > 0 && reg_needed_until < max_jint, "interval has no use");
+
+  int split_pos = 0;
+  int use_pos = 0;
+  bool need_split = false;
+  int reg, regHi;
+
+  if (_adjacent_regs) {
+    reg = find_locked_double_reg(reg_needed_until, interval_to, any_reg, &need_split);
+    regHi = reg + 1;
+
+    if (reg != any_reg) {
+      use_pos = MIN2(_use_pos[reg], _use_pos[regHi]);
+      split_pos = MIN2(_block_pos[reg], _block_pos[regHi]);
+    }
+  } else {
+    reg = find_locked_reg(reg_needed_until, interval_to, any_reg, cur->assigned_reg(), &need_split);
+    regHi = any_reg;
+
+    if (reg != any_reg) {
+      use_pos = _use_pos[reg];
+      split_pos = _block_pos[reg];
+
+      if (_num_phys_regs == 2) {
+        if (cur->assigned_reg() != any_reg) {
+          regHi = reg;
+          reg = cur->assigned_reg();
+        } else {
+          regHi = find_locked_reg(reg_needed_until, interval_to, any_reg, reg, &need_split);
+          if (regHi != any_reg) {
+            use_pos = MIN2(use_pos, _use_pos[regHi]);
+            split_pos = MIN2(split_pos, _block_pos[regHi]);
+          }
+        }
+
+        if (regHi != any_reg && reg > regHi) {
+          // sort register numbers to prevent e.g. a move from eax,ebx to ebx,eax
+          int temp = reg;
+          reg = regHi;
+          regHi = temp;
+        }
+      }
+    }
+  }
+
+  if (reg == any_reg || (_num_phys_regs == 2 && regHi == any_reg) || use_pos <= cur->first_usage(mustHaveRegister)) {
+    // the first use of cur is later than the spilling position -> spill cur
+    TRACE_GREEDY(4, tty->print_cr("able to spill current interval. first_usage(register): %d, use_pos: %d", cur->first_usage(mustHaveRegister), use_pos));
+
+    if (cur->first_usage(mustHaveRegister) <= cur->from() + 1) {
+      assert(false, "cannot spill interval that is used in first instruction (possible reason: no register found)");
+      // assign a reasonable register and do a bailout in product mode to avoid errors
+      allocator()->assign_spill_slot(cur);
+      BAILOUT("Greedy: no register found");
+    }
+
+    split_and_spill_interval(cur);
+  } else {
+    TRACE_GREEDY(4, tty->print_cr("decided to use register %d, %d", reg, regHi));
+    assert(reg != any_reg && (_num_phys_regs == 1 || regHi != any_reg), "no register found");
+    assert(split_pos > 0, "invalid split_pos");
+    assert(need_split == false || split_pos > cur->from(), "splitting interval at from");
+
+    cur->assign_reg(reg, regHi);
+    if (need_split) {
+      // register not available for full interval, so split it
+      split_when_partial_register_available(cur, split_pos);
+    }
+
+    // perform splitting and spilling for all affected intervalls
+    split_and_spill_intersecting_intervals(reg, regHi);
+  }
+}
+
+bool GreedyWalker::no_allocation_possible(GreedyInterval* cur) {
+#ifdef X86
+  // fast calculation of intervals that can never get a register because the
+  // the next instruction is a call that blocks all registers
+  // Note: this does not work if callee-saved registers are available (e.g. on Sparc)
+
+  // check if this interval is the result of a split operation
+  // (an interval got a register until this position)
+  int pos = cur->from();
+  if ((pos & 1) == 1) {
+    // the current instruction is a call that blocks all registers
+    if (pos < allocator()->max_lir_op_id() && allocator()->has_call(pos + 1)) {
+      TRACE_GREEDY(4, tty->print_cr("      free register cannot be available because all registers blocked by following call"));
+
+      // safety check that there is really no register available
+      assert(alloc_free_reg(cur) == false, "found a register for this interval");
+      return true;
+    }
+
+  }
+#endif
+  return false;
+}
+
+void GreedyWalker::init_vars_for_alloc(GreedyInterval* cur) {
+  BasicType type = cur->type();
+  _num_phys_regs = Greedy::num_physical_regs(type);
+  _adjacent_regs = Greedy::requires_adjacent_regs(type);
+
+  if (pd_init_regs_for_alloc(cur)) {
+    // the appropriate register range was selected.
+  } else if (type == T_FLOAT || type == T_DOUBLE) {
+    _first_reg = pd_first_fpu_reg;
+    _last_reg = pd_last_fpu_reg;
+  } else {
+    _first_reg = pd_first_cpu_reg;
+    _last_reg = FrameMap::last_cpu_reg();
+  }
+
+  assert(0 <= _first_reg && _first_reg < Greedy::nof_regs, "out of range");
+  assert(0 <= _last_reg && _last_reg < Greedy::nof_regs, "out of range");
+}
+
+
+bool GreedyWalker::is_move(LIR_Op* op, GreedyInterval* from, GreedyInterval* to) {
+  if (op->code() != lir_move) {
+    return false;
+  }
+  assert(op->as_Op1() != NULL, "move must be LIR_Op1");
+
+  LIR_Opr in = ((LIR_Op1*)op)->in_opr();
+  LIR_Opr res = ((LIR_Op1*)op)->result_opr();
+  return in->is_virtual() && res->is_virtual() && in->vreg_number() == from->reg_num() && res->vreg_number() == to->reg_num();
+}
+
+// optimization (especially for phi functions of nested loops):
+// assign same spill slot to non-intersecting intervals
+void GreedyWalker::combine_spilled_intervals(GreedyInterval* cur) {
+  if (cur->is_split_child()) {
+    // optimization is only suitable for split parents
+    return;
+  }
+
+  GreedyInterval* register_hint = cur->register_hint(false);
+  if (register_hint == NULL) {
+    // cur is not the target of a move, otherwise register_hint would be set
+    return;
+  }
+  assert(register_hint->is_split_parent(), "register hint must be split parent");
+
+  if (cur->spill_state() != noOptimization || register_hint->spill_state() != noOptimization) {
+    // combining the stack slots for intervals where spill move optimization is applied
+    // is not benefitial and would cause problems
+    return;
+  }
+
+  int begin_pos = cur->from();
+  int end_pos = cur->to();
+  if (end_pos > allocator()->max_lir_op_id() || (begin_pos & 1) != 0 || (end_pos & 1) != 0) {
+    // safety check that lir_op_with_id is allowed
+    return;
+  }
+
+  if (!is_move(allocator()->lir_op_with_id(begin_pos), register_hint, cur) || !is_move(allocator()->lir_op_with_id(end_pos), cur, register_hint)) {
+    // cur and register_hint are not connected with two moves
+    return;
+  }
+
+  GreedyInterval* begin_hint = register_hint->split_child_at_op_id(begin_pos, LIR_OpVisitState::inputMode);
+  GreedyInterval* end_hint = register_hint->split_child_at_op_id(end_pos, LIR_OpVisitState::outputMode);
+  if (begin_hint == end_hint || begin_hint->to() != begin_pos || end_hint->from() != end_pos) {
+    // register_hint must be split, otherwise the re-writing of use positions does not work
+    return;
+  }
+
+  assert(begin_hint->assigned_reg() != any_reg, "must have register assigned");
+  assert(end_hint->assigned_reg() == any_reg, "must not have register assigned");
+  assert(cur->first_usage(mustHaveRegister) == begin_pos, "must have use position at begin of interval because of move");
+  assert(end_hint->first_usage(mustHaveRegister) == end_pos, "must have use position at begin of interval because of move");
+
+  if (begin_hint->assigned_reg() < Greedy::nof_regs) {
+    // register_hint is not spilled at begin_pos, so it would not be benefitial to immediately spill cur
+    return;
+  }
+  assert(register_hint->canonical_spill_slot() != -1, "must be set when part of interval was spilled");
+
+  // modify intervals such that cur gets the same stack slot as register_hint
+  // delete use positions to prevent the intervals to get a register at beginning
+  cur->set_canonical_spill_slot(register_hint->canonical_spill_slot());
+  cur->remove_first_use_pos();
+  end_hint->remove_first_use_pos();
+}
+
+
+// allocate a physical register or memory location to an interval
+bool GreedyWalker::activate_current() {
+  GreedyInterval* cur = current();
+  bool result = true;
+
+  TRACE_GREEDY(2, tty->print   ("+++++ activating interval "); cur->print());
+  TRACE_GREEDY(4, tty->print_cr("      split_parent: %d, insert_move_when_activated: %d", cur->split_parent()->reg_num(), cur->insert_move_when_activated()));
+
+  if (cur->assigned_reg() >= Greedy::nof_regs) {
+    // activating an interval that has a stack slot assigned -> split it at first use position
+    // used for method parameters
+    TRACE_GREEDY(4, tty->print_cr("      interval has spill slot assigned (method parameter) -> split it before first use"));
+
+    split_stack_interval(cur);
+    result = false;
+
+  } else if (allocator()->gen()->is_vreg_flag_set(cur->reg_num(), LIRGenerator::must_start_in_memory)) {
+    // activating an interval that must start in a stack slot, but may get a register later
+    // used for lir_roundfp: rounding is done by store to stack and reload later
+    TRACE_GREEDY(4, tty->print_cr("      interval must start in stack slot -> split it before first use"));
+    assert(cur->assigned_reg() == any_reg && cur->assigned_regHi() == any_reg, "register already assigned");
+
+    allocator()->assign_spill_slot(cur);
+    split_stack_interval(cur);
+    result = false;
+
+  } else if (cur->assigned_reg() == any_reg) {
+    // interval has not assigned register -> normal allocation
+    // (this is the normal case for most intervals)
+    TRACE_GREEDY(4, tty->print_cr("      normal allocation of register"));
+
+    // assign same spill slot to non-intersecting intervals
+    combine_spilled_intervals(cur);
+
+    init_vars_for_alloc(cur);
+    if (no_allocation_possible(cur) || !alloc_free_reg(cur)) {
+      // no empty register available.
+      // split and spill another interval so that this interval gets a register
+      alloc_locked_reg(cur);
+    }
+
+    // spilled intervals need not be move to active-list
+    if (cur->assigned_reg() >= Greedy::nof_regs) {
+      result = false;
+    }
+  }
+
+  // load spilled values that become active from stack slot to register
+  if (cur->insert_move_when_activated()) {
+    assert(cur->is_split_child(), "must be");
+    assert(cur->current_split_child() != NULL, "must be");
+    assert(cur->current_split_child()->reg_num() != cur->reg_num(), "cannot insert move between same interval");
+    TRACE_GREEDY(4, tty->print_cr("Inserting move from interval %d to %d because insert_move_when_activated is set", cur->current_split_child()->reg_num(), cur->reg_num()));
+
+    insert_move(cur->from(), cur->current_split_child(), cur);
+  }
+  cur->make_current_split_child();
+
+  return result; // true = interval is moved to active list
+}
+
+
+// Implementation of GreedyEdgeMoveOptimizer
+
+GreedyEdgeMoveOptimizer::GreedyEdgeMoveOptimizer() :
+  _edge_instructions(4),
+  _edge_instructions_idx(4)
+{
+}
+
+void GreedyEdgeMoveOptimizer::optimize(BlockList* code) {
+  GreedyEdgeMoveOptimizer optimizer = GreedyEdgeMoveOptimizer();
+
+  // ignore the first block in the list (index 0 is not processed)
+  for (int i = code->length() - 1; i >= 1; i--) {
+    BlockBegin* block = code->at(i);
+
+    if (block->number_of_preds() > 1 && !block->is_set(BlockBegin::exception_entry_flag)) {
+      optimizer.optimize_moves_at_block_end(block);
+    }
+    if (block->number_of_sux() == 2) {
+      optimizer.optimize_moves_at_block_begin(block);
+    }
+  }
+}
+
+
+// clear all internal data structures
+void GreedyEdgeMoveOptimizer::init_instructions() {
+  _edge_instructions.clear();
+  _edge_instructions_idx.clear();
+}
+
+// append a lir-instruction-list and the index of the current operation in to the list
+void GreedyEdgeMoveOptimizer::append_instructions(LIR_OpList* instructions, int instructions_idx) {
+  _edge_instructions.append(instructions);
+  _edge_instructions_idx.append(instructions_idx);
+}
+
+// return the current operation of the given edge (predecessor or successor)
+LIR_Op* GreedyEdgeMoveOptimizer::instruction_at(int edge) {
+  LIR_OpList* instructions = _edge_instructions.at(edge);
+  int idx = _edge_instructions_idx.at(edge);
+
+  if (idx < instructions->length()) {
+    return instructions->at(idx);
+  } else {
+    return NULL;
+  }
+}
+
+// removes the current operation of the given edge (predecessor or successor)
+void GreedyEdgeMoveOptimizer::remove_cur_instruction(int edge, bool decrement_index) {
+  LIR_OpList* instructions = _edge_instructions.at(edge);
+  int idx = _edge_instructions_idx.at(edge);
+  instructions->remove_at(idx);
+
+  if (decrement_index) {
+    _edge_instructions_idx.at_put(edge, idx - 1);
+  }
+}
+
+
+bool GreedyEdgeMoveOptimizer::operations_different(LIR_Op* op1, LIR_Op* op2) {
+  if (op1 == NULL || op2 == NULL) {
+    // at least one block is already empty -> no optimization possible
+    return true;
+  }
+
+  if (op1->code() == lir_move && op2->code() == lir_move) {
+    assert(op1->as_Op1() != NULL, "move must be LIR_Op1");
+    assert(op2->as_Op1() != NULL, "move must be LIR_Op1");
+    LIR_Op1* move1 = (LIR_Op1*)op1;
+    LIR_Op1* move2 = (LIR_Op1*)op2;
+    if (move1->info() == move2->info() && move1->in_opr() == move2->in_opr() && move1->result_opr() == move2->result_opr()) {
+      // these moves are exactly equal and can be optimized
+      return false;
+    }
+
+  } else if (op1->code() == lir_fxch && op2->code() == lir_fxch) {
+    assert(op1->as_Op1() != NULL, "fxch must be LIR_Op1");
+    assert(op2->as_Op1() != NULL, "fxch must be LIR_Op1");
+    LIR_Op1* fxch1 = (LIR_Op1*)op1;
+    LIR_Op1* fxch2 = (LIR_Op1*)op2;
+    if (fxch1->in_opr()->as_jint() == fxch2->in_opr()->as_jint()) {
+      // equal FPU stack operations can be optimized
+      return false;
+    }
+
+  } else if (op1->code() == lir_fpop_raw && op2->code() == lir_fpop_raw) {
+    // equal FPU stack operations can be optimized
+    return false;
+  }
+
+  // no optimization possible
+  return true;
+}
+
+void GreedyEdgeMoveOptimizer::optimize_moves_at_block_end(BlockBegin* block) {
+  TRACE_GREEDY(4, tty->print_cr("optimizing moves at end of block B%d", block->block_id()));
+
+  if (block->is_predecessor(block)) {
+    // currently we can't handle this correctly.
+    return;
+  }
+
+  init_instructions();
+  int num_preds = block->number_of_preds();
+  assert(num_preds > 1, "do not call otherwise");
+  assert(!block->is_set(BlockBegin::exception_entry_flag), "exception handlers not allowed");
+
+  // setup a list with the lir-instructions of all predecessors
+  int i;
+  for (i = 0; i < num_preds; i++) {
+    BlockBegin* pred = block->pred_at(i);
+    LIR_OpList* pred_instructions = pred->lir()->instructions_list();
+
+    if (pred->number_of_sux() != 1) {
+      // this can happen with switch-statements where multiple edges are between
+      // the same blocks.
+      return;
+    }
+
+    assert(pred->number_of_sux() == 1, "can handle only one successor");
+    assert(pred->sux_at(0) == block, "invalid control flow");
+    assert(pred_instructions->last()->code() == lir_branch, "block with successor must end with branch");
+    assert(pred_instructions->last()->as_OpBranch() != NULL, "branch must be LIR_OpBranch");
+    assert(pred_instructions->last()->as_OpBranch()->cond() == lir_cond_always, "block must end with unconditional branch");
+
+    if (pred_instructions->last()->info() != NULL) {
+      // can not optimize instructions when debug info is needed
+      return;
+    }
+
+    // ignore the unconditional branch at the end of the block
+    append_instructions(pred_instructions, pred_instructions->length() - 2);
+  }
+
+
+  // process lir-instructions while all predecessors end with the same instruction
+  while (true) {
+    LIR_Op* op = instruction_at(0);
+    for (i = 1; i < num_preds; i++) {
+      if (operations_different(op, instruction_at(i))) {
+        // these instructions are different and cannot be optimized ->
+        // no further optimization possible
+        return;
+      }
+    }
+
+    TRACE_GREEDY(4, tty->print("found instruction that is equal in all %d predecessors: ", num_preds); op->print());
+
+    // insert the instruction at the beginning of the current block
+    block->lir()->insert_before(1, op);
+
+    // delete the instruction at the end of all predecessors
+    for (i = 0; i < num_preds; i++) {
+      remove_cur_instruction(i, true);
+    }
+  }
+}
+
+
+void GreedyEdgeMoveOptimizer::optimize_moves_at_block_begin(BlockBegin* block) {
+  TRACE_GREEDY(4, tty->print_cr("optimization moves at begin of block B%d", block->block_id()));
+
+  init_instructions();
+  int num_sux = block->number_of_sux();
+
+  LIR_OpList* cur_instructions = block->lir()->instructions_list();
+
+  assert(num_sux == 2, "method should not be called otherwise");
+  assert(cur_instructions->last()->code() == lir_branch, "block with successor must end with branch");
+  assert(cur_instructions->last()->as_OpBranch() != NULL, "branch must be LIR_OpBranch");
+  assert(cur_instructions->last()->as_OpBranch()->cond() == lir_cond_always, "block must end with unconditional branch");
+
+  if (cur_instructions->last()->info() != NULL) {
+    // can no optimize instructions when debug info is needed
+    return;
+  }
+
+  LIR_Op* branch = cur_instructions->at(cur_instructions->length() - 2);
+  if (branch->info() != NULL || (branch->code() != lir_branch && branch->code() != lir_cond_float_branch)) {
+    // not a valid case for optimization
+    // currently, only blocks that end with two branches (conditional branch followed
+    // by unconditional branch) are optimized
+    return;
+  }
+
+  // now it is guaranteed that the block ends with two branch instructions.
+  // the instructions are inserted at the end of the block before these two branches
+  int insert_idx = cur_instructions->length() - 2;
+
+  int i;
+#ifdef ASSERT
+  for (i = insert_idx - 1; i >= 0; i--) {
+    LIR_Op* op = cur_instructions->at(i);
+    if ((op->code() == lir_branch || op->code() == lir_cond_float_branch) && ((LIR_OpBranch*)op)->block() != NULL) {
+      assert(false, "block with two successors can have only two branch instructions");
+    }
+  }
+#endif
+
+  // setup a list with the lir-instructions of all successors
+  for (i = 0; i < num_sux; i++) {
+    BlockBegin* sux = block->sux_at(i);
+    LIR_OpList* sux_instructions = sux->lir()->instructions_list();
+
+    assert(sux_instructions->at(0)->code() == lir_label, "block must start with label");
+
+    if (sux->number_of_preds() != 1) {
+      // this can happen with switch-statements where multiple edges are between
+      // the same blocks.
+      return;
+    }
+    assert(sux->pred_at(0) == block, "invalid control flow");
+    assert(!sux->is_set(BlockBegin::exception_entry_flag), "exception handlers not allowed");
+
+    // ignore the label at the beginning of the block
+    append_instructions(sux_instructions, 1);
+  }
+
+  // process lir-instructions while all successors begin with the same instruction
+  while (true) {
+    LIR_Op* op = instruction_at(0);
+    for (i = 1; i < num_sux; i++) {
+      if (operations_different(op, instruction_at(i))) {
+        // these instructions are different and cannot be optimized ->
+        // no further optimization possible
+        return;
+      }
+    }
+
+    TRACE_GREEDY(4, tty->print("----- found instruction that is equal in all %d successors: ", num_sux); op->print());
+
+    // insert instruction at end of current block
+    block->lir()->insert_before(insert_idx, op);
+    insert_idx++;
+
+    // delete the instructions at the beginning of all successors
+    for (i = 0; i < num_sux; i++) {
+      remove_cur_instruction(i, false);
+    }
+  }
+}
+
+
+// Implementation of GreedyControlFlowOptimizer
+
+GreedyControlFlowOptimizer::GreedyControlFlowOptimizer() :
+  _original_preds(4)
+{
+}
+
+void GreedyControlFlowOptimizer::optimize(BlockList* code) {
+  GreedyControlFlowOptimizer optimizer = GreedyControlFlowOptimizer();
+
+  // push the OSR entry block to the end so that we're not jumping over it.
+  BlockBegin* osr_entry = code->at(0)->end()->as_Base()->osr_entry();
+  if (osr_entry) {
+    int index = osr_entry->greedy_number();
+    assert(code->at(index) == osr_entry, "wrong index");
+    code->remove_at(index);
+    code->append(osr_entry);
+  }
+
+  optimizer.reorder_short_loops(code);
+  optimizer.delete_empty_blocks(code);
+  optimizer.delete_unnecessary_jumps(code);
+  optimizer.delete_jumps_to_return(code);
+}
+
+void GreedyControlFlowOptimizer::reorder_short_loop(BlockList* code, BlockBegin* header_block, int header_idx) {
+  int i = header_idx + 1;
+  int max_end = MIN2(header_idx + ShortLoopSize, code->length());
+  while (i < max_end && code->at(i)->loop_depth() >= header_block->loop_depth()) {
+    i++;
+  }
+
+  if (i == code->length() || code->at(i)->loop_depth() < header_block->loop_depth()) {
+    int end_idx = i - 1;
+    BlockBegin* end_block = code->at(end_idx);
+
+    if (end_block->number_of_sux() == 1 && end_block->sux_at(0) == header_block) {
+      // short loop from header_idx to end_idx found -> reorder blocks such that
+      // the header_block is the last block instead of the first block of the loop
+      TRACE_GREEDY(1, tty->print_cr("Reordering short loop: length %d, header B%d, end B%d",
+                                         end_idx - header_idx + 1,
+                                         header_block->block_id(), end_block->block_id()));
+
+      for (int j = header_idx; j < end_idx; j++) {
+        code->at_put(j, code->at(j + 1));
+      }
+      code->at_put(end_idx, header_block);
+
+      // correct the flags so that any loop alignment occurs in the right place.
+      assert(code->at(end_idx)->is_set(BlockBegin::backward_branch_target_flag), "must be backward branch target");
+      code->at(end_idx)->clear(BlockBegin::backward_branch_target_flag);
+      code->at(header_idx)->set(BlockBegin::backward_branch_target_flag);
+    }
+  }
+}
+
+void GreedyControlFlowOptimizer::reorder_short_loops(BlockList* code) {
+  for (int i = code->length() - 1; i >= 0; i--) {
+    BlockBegin* block = code->at(i);
+
+    if (block->is_set(BlockBegin::greedy_loop_header_flag)) {
+      reorder_short_loop(code, block, i);
+    }
+  }
+
+  DEBUG_ONLY(verify(code));
+}
+
+// only blocks with exactly one successor can be deleted. Such blocks
+// must always end with an unconditional branch to this successor
+bool GreedyControlFlowOptimizer::can_delete_block(BlockBegin* block) {
+  if (block->number_of_sux() != 1 || block->number_of_exception_handlers() != 0 || block->is_entry_block()) {
+    return false;
+  }
+
+  LIR_OpList* instructions = block->lir()->instructions_list();
+
+  assert(instructions->length() >= 2, "block must have label and branch");
+  assert(instructions->at(0)->code() == lir_label, "first instruction must always be a label");
+  assert(instructions->last()->as_OpBranch() != NULL, "last instrcution must always be a branch");
+  assert(instructions->last()->as_OpBranch()->cond() == lir_cond_always, "branch must be unconditional");
+  assert(instructions->last()->as_OpBranch()->block() == block->sux_at(0), "branch target must be the successor");
+
+  // block must have exactly one successor
+
+  if (instructions->length() == 2 && instructions->last()->info() == NULL) {
+    return true;
+  }
+  return false;
+}
+
+// substitute branch targets in all branch-instructions of this blocks
+void GreedyControlFlowOptimizer::substitute_branch_target(BlockBegin* block, BlockBegin* target_from, BlockBegin* target_to) {
+  TRACE_GREEDY(3, tty->print_cr("Deleting empty block: substituting from B%d to B%d inside B%d", target_from->block_id(), target_to->block_id(), block->block_id()));
+
+  LIR_OpList* instructions = block->lir()->instructions_list();
+
+  assert(instructions->at(0)->code() == lir_label, "first instruction must always be a label");
+  for (int i = instructions->length() - 1; i >= 1; i--) {
+    LIR_Op* op = instructions->at(i);
+
+    if (op->code() == lir_branch || op->code() == lir_cond_float_branch) {
+      assert(op->as_OpBranch() != NULL, "branch must be of type LIR_OpBranch");
+      LIR_OpBranch* branch = (LIR_OpBranch*)op;
+
+      if (branch->block() == target_from) {
+        branch->change_block(target_to);
+      }
+      if (branch->ublock() == target_from) {
+        branch->change_ublock(target_to);
+      }
+    }
+  }
+}
+
+void GreedyControlFlowOptimizer::delete_empty_blocks(BlockList* code) {
+  int old_pos = 0;
+  int new_pos = 0;
+  int num_blocks = code->length();
+
+  while (old_pos < num_blocks) {
+    BlockBegin* block = code->at(old_pos);
+
+    if (can_delete_block(block)) {
+      BlockBegin* new_target = block->sux_at(0);
+
+      // propagate backward branch target flag for correct code alignment
+      if (block->is_set(BlockBegin::backward_branch_target_flag)) {
+        new_target->set(BlockBegin::backward_branch_target_flag);
+      }
+
+      // collect a list with all predecessors that contains each predecessor only once
+      // the predecessors of cur are changed during the substitution, so a copy of the
+      // predecessor list is necessary
+      int j;
+      _original_preds.clear();
+      for (j = block->number_of_preds() - 1; j >= 0; j--) {
+        BlockBegin* pred = block->pred_at(j);
+        if (_original_preds.index_of(pred) == -1) {
+          _original_preds.append(pred);
+        }
+      }
+
+      for (j = _original_preds.length() - 1; j >= 0; j--) {
+        BlockBegin* pred = _original_preds.at(j);
+        substitute_branch_target(pred, block, new_target);
+        pred->substitute_sux(block, new_target);
+      }
+    } else {
+      // adjust position of this block in the block list if blocks before
+      // have been deleted
+      if (new_pos != old_pos) {
+        code->at_put(new_pos, code->at(old_pos));
+      }
+      new_pos++;
+    }
+    old_pos++;
+  }
+  code->truncate(new_pos);
+
+  DEBUG_ONLY(verify(code));
+}
+
+void GreedyControlFlowOptimizer::delete_unnecessary_jumps(BlockList* code) {
+  // skip the last block because there a branch is always necessary
+  for (int i = code->length() - 2; i >= 0; i--) {
+    BlockBegin* block = code->at(i);
+    LIR_OpList* instructions = block->lir()->instructions_list();
+
+    LIR_Op* last_op = instructions->last();
+    if (last_op->code() == lir_branch) {
+      assert(last_op->as_OpBranch() != NULL, "branch must be of type LIR_OpBranch");
+      LIR_OpBranch* last_branch = (LIR_OpBranch*)last_op;
+
+      assert(last_branch->block() != NULL, "last branch must always have a block as target");
+      assert(last_branch->label() == last_branch->block()->label(), "must be equal");
+
+      if (last_branch->info() == NULL) {
+        if (last_branch->block() == code->at(i + 1)) {
+
+          TRACE_GREEDY(3, tty->print_cr("Deleting unconditional branch at end of block B%d", block->block_id()));
+
+          // delete last branch instruction
+          instructions->truncate(instructions->length() - 1);
+
+        } else {
+          LIR_Op* prev_op = instructions->at(instructions->length() - 2);
+          if (prev_op->code() == lir_branch || prev_op->code() == lir_cond_float_branch) {
+            assert(prev_op->as_OpBranch() != NULL, "branch must be of type LIR_OpBranch");
+            LIR_OpBranch* prev_branch = (LIR_OpBranch*)prev_op;
+
+            if (prev_branch->stub() == NULL) {
+
+              LIR_Op2* prev_cmp = NULL;
+
+              for(int j = instructions->length() - 3; j >= 0 && prev_cmp == NULL; j--) {
+                prev_op = instructions->at(j);
+                if (prev_op->code() == lir_cmp) {
+                  assert(prev_op->as_Op2() != NULL, "branch must be of type LIR_Op2");
+                  prev_cmp = (LIR_Op2*)prev_op;
+                  assert(prev_branch->cond() == prev_cmp->condition(), "should be the same");
+                }
+              }
+              assert(prev_cmp != NULL, "should have found comp instruction for branch");
+              if (prev_branch->block() == code->at(i + 1) && prev_branch->info() == NULL) {
+
+                TRACE_GREEDY(3, tty->print_cr("Negating conditional branch and deleting unconditional branch at end of block B%d", block->block_id()));
+
+                // eliminate a conditional branch to the immediate successor
+                prev_branch->change_block(last_branch->block());
+                prev_branch->negate_cond();
+                prev_cmp->set_condition(prev_branch->cond());
+                instructions->truncate(instructions->length() - 1);
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
+  DEBUG_ONLY(verify(code));
+}
+
+void GreedyControlFlowOptimizer::delete_jumps_to_return(BlockList* code) {
+#ifdef ASSERT
+  BitMap return_converted(BlockBegin::number_of_blocks());
+  return_converted.clear();
+#endif
+
+  for (int i = code->length() - 1; i >= 0; i--) {
+    BlockBegin* block = code->at(i);
+    LIR_OpList* cur_instructions = block->lir()->instructions_list();
+    LIR_Op*     cur_last_op = cur_instructions->last();
+
+    assert(cur_instructions->at(0)->code() == lir_label, "first instruction must always be a label");
+    if (cur_instructions->length() == 2 && cur_last_op->code() == lir_return) {
+      // the block contains only a label and a return
+      // if a predecessor ends with an unconditional jump to this block, then the jump
+      // can be replaced with a return instruction
+      //
+      // Note: the original block with only a return statement cannot be deleted completely
+      //       because the predecessors might have other (conditional) jumps to this block
+      //       -> this may lead to unnecesary return instructions in the final code
+
+      assert(cur_last_op->info() == NULL, "return instructions do not have debug information");
+      assert(block->number_of_sux() == 0 ||
+             (return_converted.at(block->block_id()) && block->number_of_sux() == 1),
+             "blocks that end with return must not have successors");
+
+      assert(cur_last_op->as_Op1() != NULL, "return must be LIR_Op1");
+      LIR_Opr return_opr = ((LIR_Op1*)cur_last_op)->in_opr();
+
+      for (int j = block->number_of_preds() - 1; j >= 0; j--) {
+        BlockBegin* pred = block->pred_at(j);
+        LIR_OpList* pred_instructions = pred->lir()->instructions_list();
+        LIR_Op*     pred_last_op = pred_instructions->last();
+
+        if (pred_last_op->code() == lir_branch) {
+          assert(pred_last_op->as_OpBranch() != NULL, "branch must be LIR_OpBranch");
+          LIR_OpBranch* pred_last_branch = (LIR_OpBranch*)pred_last_op;
+
+          if (pred_last_branch->block() == block && pred_last_branch->cond() == lir_cond_always && pred_last_branch->info() == NULL) {
+            // replace the jump to a return with a direct return
+            // Note: currently the edge between the blocks is not deleted
+            pred_instructions->at_put(pred_instructions->length() - 1, new LIR_Op1(lir_return, return_opr));
+#ifdef ASSERT
+            return_converted.set_bit(pred->block_id());
+#endif
+          }
+        }
+      }
+    }
+  }
+}
+
+
+#ifdef ASSERT
+void GreedyControlFlowOptimizer::verify(BlockList* code) {
+  for (int i = 0; i < code->length(); i++) {
+    BlockBegin* block = code->at(i);
+    LIR_OpList* instructions = block->lir()->instructions_list();
+
+    int j;
+    for (j = 0; j < instructions->length(); j++) {
+      LIR_OpBranch* op_branch = instructions->at(j)->as_OpBranch();
+
+      if (op_branch != NULL) {
+        assert(op_branch->block() == NULL || code->index_of(op_branch->block()) != -1, "branch target not valid");
+        assert(op_branch->ublock() == NULL || code->index_of(op_branch->ublock()) != -1, "branch target not valid");
+      }
+    }
+
+    for (j = 0; j < block->number_of_sux() - 1; j++) {
+      BlockBegin* sux = block->sux_at(j);
+      assert(code->index_of(sux) != -1, "successor not valid");
+    }
+
+    for (j = 0; j < block->number_of_preds() - 1; j++) {
+      BlockBegin* pred = block->pred_at(j);
+      assert(code->index_of(pred) != -1, "successor not valid");
+    }
+  }
+}
+#endif
+
+
+#ifndef PRODUCT
+
+// Implementation of GreedyStatistic
+
+const char* GreedyStatistic::counter_name(int counter_idx) {
+  switch (counter_idx) {
+    case counter_method:          return "compiled methods";
+    case counter_fpu_method:      return "methods using fpu";
+    case counter_loop_method:     return "methods with loops";
+    case counter_exception_method:return "methods with xhandler";
+
+    case counter_loop:            return "loops";
+    case counter_block:           return "blocks";
+    case counter_loop_block:      return "blocks inside loop";
+    case counter_exception_block: return "exception handler entries";
+    case counter_interval:        return "intervals";
+    case counter_fixed_interval:  return "fixed intervals";
+    case counter_range:           return "ranges";
+    case counter_fixed_range:     return "fixed ranges";
+    case counter_use_pos:         return "use positions";
+    case counter_fixed_use_pos:   return "fixed use positions";
+    case counter_spill_slots:     return "spill slots";
+
+    // counter for classes of lir instructions
+    case counter_instruction:     return "total instructions";
+    case counter_label:           return "labels";
+    case counter_entry:           return "method entries";
+    case counter_return:          return "method returns";
+    case counter_call:            return "method calls";
+    case counter_move:            return "moves";
+    case counter_cmp:             return "compare";
+    case counter_cond_branch:     return "conditional branches";
+    case counter_uncond_branch:   return "unconditional branches";
+    case counter_stub_branch:     return "branches to stub";
+    case counter_alu:             return "artithmetic + logic";
+    case counter_alloc:           return "allocations";
+    case counter_sync:            return "synchronisation";
+    case counter_throw:           return "throw";
+    case counter_unwind:          return "unwind";
+    case counter_typecheck:       return "type+null-checks";
+    case counter_fpu_stack:       return "fpu-stack";
+    case counter_misc_inst:       return "other instructions";
+    case counter_other_inst:      return "misc. instructions";
+
+    // counter for different types of moves
+    case counter_move_total:      return "total moves";
+    case counter_move_reg_reg:    return "register->register";
+    case counter_move_reg_stack:  return "register->stack";
+    case counter_move_stack_reg:  return "stack->register";
+    case counter_move_stack_stack:return "stack->stack";
+    case counter_move_reg_mem:    return "register->memory";
+    case counter_move_mem_reg:    return "memory->register";
+    case counter_move_const_any:  return "constant->any";
+
+    case blank_line_1:            return "";
+    case blank_line_2:            return "";
+
+    default: ShouldNotReachHere(); return "";
+  }
+}
+
+GreedyStatistic::Counter GreedyStatistic::base_counter(int counter_idx) {
+  if (counter_idx == counter_fpu_method || counter_idx == counter_loop_method || counter_idx == counter_exception_method) {
+    return counter_method;
+  } else if (counter_idx == counter_loop_block || counter_idx == counter_exception_block) {
+    return counter_block;
+  } else if (counter_idx >= counter_instruction && counter_idx <= counter_other_inst) {
+    return counter_instruction;
+  } else if (counter_idx >= counter_move_total && counter_idx <= counter_move_const_any) {
+    return counter_move_total;
+  }
+  return invalid_counter;
+}
+
+GreedyStatistic::GreedyStatistic() {
+  for (int i = 0; i < number_of_counters; i++) {
+    _counters_sum[i] = 0;
+    _counters_max[i] = -1;
+  }
+
+}
+
+// add the method-local numbers to the total sum
+void GreedyStatistic::sum_up(GreedyStatistic &method_statistic) {
+  for (int i = 0; i < number_of_counters; i++) {
+    _counters_sum[i] += method_statistic._counters_sum[i];
+    _counters_max[i] = MAX2(_counters_max[i], method_statistic._counters_sum[i]);
+  }
+}
+
+void GreedyStatistic::print(const char* title) {
+  if (CountGreedy || TraceGreedyLevel > 0) {
+    tty->cr();
+    tty->print_cr("***** Greedy statistic - %s *****", title);
+
+    for (int i = 0; i < number_of_counters; i++) {
+      if (_counters_sum[i] > 0 || _counters_max[i] >= 0) {
+        tty->print("%25s: %8d", counter_name(i), _counters_sum[i]);
+
+        if (base_counter(i) != invalid_counter) {
+          tty->print("  (%5.1f%%) ", _counters_sum[i] * 100.0 / _counters_sum[base_counter(i)]);
+        } else {
+          tty->print("           ");
+        }
+
+        if (_counters_max[i] >= 0) {
+          tty->print("%8d", _counters_max[i]);
+        }
+      }
+      tty->cr();
+    }
+  }
+}
+
+void GreedyStatistic::collect(Greedy* allocator) {
+  inc_counter(counter_method);
+  if (allocator->has_fpu_registers()) {
+    inc_counter(counter_fpu_method);
+  }
+  if (allocator->num_loops() > 0) {
+    inc_counter(counter_loop_method);
+  }
+  inc_counter(counter_loop, allocator->num_loops());
+  inc_counter(counter_spill_slots, allocator->max_spills());
+
+  int i;
+  for (i = 0; i < allocator->interval_count(); i++) {
+    GreedyInterval* cur = allocator->interval_at(i);
+
+    if (cur != NULL) {
+      inc_counter(counter_interval);
+      inc_counter(counter_use_pos, cur->num_use_positions());
+      if (Greedy::is_precolored_interval(cur)) {
+        inc_counter(counter_fixed_interval);
+        inc_counter(counter_fixed_use_pos, cur->num_use_positions());
+      }
+
+      GreedyRange* range = cur->first();
+      while (range != GreedyRange::end()) {
+        inc_counter(counter_range);
+        if (Greedy::is_precolored_interval(cur)) {
+          inc_counter(counter_fixed_range);
+        }
+        range = range->next();
+      }
+    }
+  }
+
+  bool has_xhandlers = false;
+  // Note: only count blocks that are in code-emit order
+  for (i = 0; i < allocator->ir()->code()->length(); i++) {
+    BlockBegin* cur = allocator->ir()->code()->at(i);
+
+    inc_counter(counter_block);
+    if (cur->loop_depth() > 0) {
+      inc_counter(counter_loop_block);
+    }
+    if (cur->is_set(BlockBegin::exception_entry_flag)) {
+      inc_counter(counter_exception_block);
+      has_xhandlers = true;
+    }
+
+    LIR_OpList* instructions = cur->lir()->instructions_list();
+    for (int j = 0; j < instructions->length(); j++) {
+      LIR_Op* op = instructions->at(j);
+
+      inc_counter(counter_instruction);
+
+      switch (op->code()) {
+        case lir_label:           inc_counter(counter_label); break;
+        case lir_std_entry:
+        case lir_osr_entry:       inc_counter(counter_entry); break;
+        case lir_return:          inc_counter(counter_return); break;
+
+        case lir_rtcall:
+        case lir_static_call:
+        case lir_optvirtual_call:
+        case lir_virtual_call:    inc_counter(counter_call); break;
+
+        case lir_move: {
+          inc_counter(counter_move);
+          inc_counter(counter_move_total);
+
+          LIR_Opr in = op->as_Op1()->in_opr();
+          LIR_Opr res = op->as_Op1()->result_opr();
+          if (in->is_register()) {
+            if (res->is_register()) {
+              inc_counter(counter_move_reg_reg);
+            } else if (res->is_stack()) {
+              inc_counter(counter_move_reg_stack);
+            } else if (res->is_address()) {
+              inc_counter(counter_move_reg_mem);
+            } else {
+              ShouldNotReachHere();
+            }
+          } else if (in->is_stack()) {
+            if (res->is_register()) {
+              inc_counter(counter_move_stack_reg);
+            } else {
+              inc_counter(counter_move_stack_stack);
+            }
+          } else if (in->is_address()) {
+            assert(res->is_register(), "must be");
+            inc_counter(counter_move_mem_reg);
+          } else if (in->is_constant()) {
+            inc_counter(counter_move_const_any);
+          } else {
+            ShouldNotReachHere();
+          }
+          break;
+        }
+
+        case lir_cmp:             inc_counter(counter_cmp); break;
+
+        case lir_branch:
+        case lir_cond_float_branch: {
+          LIR_OpBranch* branch = op->as_OpBranch();
+          if (branch->block() == NULL) {
+            inc_counter(counter_stub_branch);
+          } else if (branch->cond() == lir_cond_always) {
+            inc_counter(counter_uncond_branch);
+          } else {
+            inc_counter(counter_cond_branch);
+          }
+          break;
+        }
+
+        case lir_neg:
+        case lir_add:
+        case lir_sub:
+        case lir_mul:
+        case lir_mul_strictfp:
+        case lir_div:
+        case lir_div_strictfp:
+        case lir_rem:
+        case lir_sqrt:
+        case lir_sin:
+        case lir_cos:
+        case lir_abs:
+        case lir_log10:
+        case lir_log:
+        case lir_pow:
+        case lir_exp:
+        case lir_logic_and:
+        case lir_logic_or:
+        case lir_logic_xor:
+        case lir_shl:
+        case lir_shr:
+        case lir_ushr:            inc_counter(counter_alu); break;
+
+        case lir_alloc_object:
+        case lir_alloc_array:     inc_counter(counter_alloc); break;
+
+        case lir_monaddr:
+        case lir_lock:
+        case lir_unlock:          inc_counter(counter_sync); break;
+
+        case lir_throw:           inc_counter(counter_throw); break;
+
+        case lir_unwind:          inc_counter(counter_unwind); break;
+
+        case lir_null_check:
+        case lir_leal:
+        case lir_instanceof:
+        case lir_checkcast:
+        case lir_store_check:     inc_counter(counter_typecheck); break;
+
+        case lir_fpop_raw:
+        case lir_fxch:
+        case lir_fld:             inc_counter(counter_fpu_stack); break;
+
+        case lir_nop:
+        case lir_push:
+        case lir_pop:
+        case lir_convert:
+        case lir_roundfp:
+        case lir_cmove:           inc_counter(counter_misc_inst); break;
+
+        default:                  inc_counter(counter_other_inst); break;
+      }
+    }
+  }
+
+  if (has_xhandlers) {
+    inc_counter(counter_exception_method);
+  }
+}
+
+void GreedyStatistic::compute(Greedy* allocator, GreedyStatistic &global_statistic) {
+  if (CountGreedy || TraceGreedyLevel > 0) {
+
+    GreedyStatistic local_statistic = GreedyStatistic();
+
+    local_statistic.collect(allocator);
+    global_statistic.sum_up(local_statistic);
+
+    if (TraceGreedyLevel > 2) {
+      local_statistic.print("current local statistic");
+    }
+  }
+}
+
+
+// Implementation of GreedyTimers
+
+GreedyTimers::GreedyTimers() {
+  for (int i = 0; i < number_of_timers; i++) {
+    timer(i)->reset();
+  }
+}
+
+const char* GreedyTimers::timer_name(int idx) {
+  switch (idx) {
+    case timer_do_nothing:               return "Nothing (Time Check)";
+    case timer_number_instructions:      return "Number Instructions";
+    case timer_compute_local_live_sets:  return "Local Live Sets";
+    case timer_compute_global_live_sets: return "Global Live Sets";
+    case timer_build_intervals:          return "Build GreedyIntervals";
+    case timer_sort_intervals_before:    return "Sort GreedyIntervals Before";
+    case timer_allocate_registers:       return "Allocate Registers";
+    case timer_resolve_data_flow:        return "Resolve Data Flow";
+    case timer_sort_intervals_after:     return "Sort GreedyIntervals After";
+    case timer_eliminate_spill_moves:    return "Spill optimization";
+    case timer_assign_reg_num:           return "Assign Reg Num";
+    case timer_allocate_fpu_stack:       return "Allocate FPU Stack";
+    case timer_optimize_lir:             return "Optimize LIR";
+    default: ShouldNotReachHere();       return "";
+  }
+}
+
+void GreedyTimers::begin_method() {
+  if (TimeEachGreedy) {
+    // reset all timers to measure only current method
+    for (int i = 0; i < number_of_timers; i++) {
+      timer(i)->reset();
+    }
+  }
+}
+
+void GreedyTimers::end_method(Greedy* allocator) {
+  if (TimeEachGreedy) {
+
+    double c = timer(timer_do_nothing)->seconds();
+    double total = 0;
+    for (int i = 1; i < number_of_timers; i++) {
+      total += timer(i)->seconds() - c;
+    }
+
+    if (total >= 0.0005) {
+      // print all information in one line for automatic processing
+      tty->print("@"); allocator->compilation()->method()->print_name();
+
+      tty->print("@ %d ", allocator->compilation()->method()->code_size());
+      tty->print("@ %d ", allocator->block_at(allocator->block_count() - 1)->last_lir_instruction_id() / 2);
+      tty->print("@ %d ", allocator->block_count());
+      tty->print("@ %d ", allocator->num_virtual_regs());
+      tty->print("@ %d ", allocator->interval_count());
+      tty->print("@ %d ", allocator->_num_calls);
+      tty->print("@ %d ", allocator->num_loops());
+
+      tty->print("@ %6.6f ", total);
+      for (int i = 1; i < number_of_timers; i++) {
+        tty->print("@ %4.1f ", ((timer(i)->seconds() - c) / total) * 100);
+      }
+      tty->cr();
+    }
+  }
+}
+
+void GreedyTimers::print(double total_time) {
+  if (TimeGreedy) {
+    // correction value: sum of dummy-timer that only measures the time that
+    // is necesary to start and stop itself
+    double c = timer(timer_do_nothing)->seconds();
+
+    for (int i = 0; i < number_of_timers; i++) {
+      double t = timer(i)->seconds();
+      tty->print_cr("    %25s: %6.3f s (%4.1f%%)  corrected: %6.3f s (%4.1f%%)", timer_name(i), t, (t / total_time) * 100.0, t - c, (t - c) / (total_time - 2 * number_of_timers * c) * 100);
+    }
+  }
+}
+
+#endif // #ifndef PRODUCT
diff -r 555c45b3456e src/share/vm/c1/c1_Greedy.hpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/share/vm/c1/c1_Greedy.hpp	Sat Mar 24 11:04:51 2018 +0800
@@ -0,0 +1,990 @@
+/*
+ * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_C1_C1_GREEDY_HPP
+#define SHARE_VM_C1_C1_GREEDY_HPP
+
+#include "c1/c1_FpuStackSim.hpp"
+#include "c1/c1_FrameMap.hpp"
+#include "c1/c1_IR.hpp"
+#include "c1/c1_Instruction.hpp"
+#include "c1/c1_LIR.hpp"
+#include "c1/c1_LIRGenerator.hpp"
+
+class DebugInfoCache;
+class GreedyFpuStackAllocator;
+class IRScopeDebugInfo;
+class GreedyInterval;
+class GreedyIntervalWalker;
+class LIRGenerator;
+class Greedy;
+class GreedyMoveResolver;
+class GreedyRange;
+
+define_array(GreedyIntervalArray, GreedyInterval*)
+define_stack(GreedyIntervalList, GreedyIntervalArray)
+
+define_array(GreedyIntervalsArray, GreedyIntervalList*)
+define_stack(GreedyIntervalsList, GreedyIntervalsArray)
+
+define_array(GreedyOopMapArray, OopMap*)
+define_stack(GreedyOopMapList, GreedyOopMapArray)
+
+define_array(GreedyScopeValueArray, ScopeValue*)
+
+define_array(GreedyLIR_OpListArray, LIR_OpList*);
+define_stack(GreedyLIR_OpListStack, GreedyLIR_OpListArray);
+
+
+enum GreedyIntervalUseKind {
+  // priority of use kinds must be ascending
+  noUse = 0,
+  loopEndMarker = 1,
+  shouldHaveRegister = 2,
+  mustHaveRegister = 3,
+
+  firstValidKind = 1,
+  lastValidKind = 3
+};
+define_array(UseKindArray, GreedyIntervalUseKind)
+define_stack(UseKindStack, UseKindArray)
+
+
+enum GreedyIntervalKind {
+  fixedKind = 0,  // interval pre-colored by LIR_Generator
+  anyKind   = 1,  // no register/memory allocated by LIR_Generator
+  nofKinds,
+  firstKind = fixedKind
+};
+
+
+// during greedy an interval is in one of four states in
+enum GreedyIntervalState {
+  unhandledState = 0, // unhandled state (not processed yet)
+  activeState   = 1,  // life and is in a physical register
+  inactiveState = 2,  // in a life time hole and is in a physical register
+  handledState  = 3,  // spilled or not life again
+  invalidState = -1
+};
+
+
+enum GreedyIntervalSpillState {
+  noDefinitionFound,  // starting state of calculation: no definition found yet
+  oneDefinitionFound, // one definition has already been found.
+                      // Note: two consecutive definitions are treated as one (e.g. consecutive move and add because of two-operand LIR form)
+                      // the position of this definition is stored in _definition_pos
+  oneMoveInserted,    // one spill move has already been inserted.
+  storeAtDefinition,  // the interval should be stored immediately after its definition because otherwise
+                      // there would be multiple redundant stores
+  startInMemory,      // the interval starts in memory (e.g. method parameter), so a store is never necessary
+  noOptimization      // the interval has more then one definition (e.g. resulting from phi moves), so stores to memory are not optimized
+};
+
+
+#define for_each_interval_kind(kind) \
+  for (GreedyIntervalKind kind = firstKind; kind < nofKinds; kind = (GreedyIntervalKind)(kind + 1))
+
+#define for_each_visitor_mode(mode) \
+  for (LIR_OpVisitState::OprMode mode = LIR_OpVisitState::firstMode; mode < LIR_OpVisitState::numModes; mode = (LIR_OpVisitState::OprMode)(mode + 1))
+
+
+class Greedy : public CompilationResourceObj {
+  // declare classes used by Greedy as friends because they
+  // need a wide variety of functions declared here
+  //
+  // Only the small interface to the rest of the compiler is public
+  friend class GreedyInterval;
+  friend class GreedyIntervalWalker;
+  friend class GreedyWalker;
+  friend class GreedyFpuStackAllocator;
+  friend class GreedyMoveResolver;
+  friend class GreedyStatistic;
+  friend class GreedyTimers;
+  friend class GreedyRegisterVerifier;
+
+ public:
+  enum {
+    any_reg = -1,
+    nof_cpu_regs = pd_nof_cpu_regs_greedy,
+    nof_fpu_regs = pd_nof_fpu_regs_greedy,
+    nof_xmm_regs = pd_nof_xmm_regs_greedy,
+    nof_regs = nof_cpu_regs + nof_fpu_regs + nof_xmm_regs
+  };
+
+ private:
+  Compilation*              _compilation;
+  IR*                       _ir;
+  LIRGenerator*             _gen;
+  FrameMap*                 _frame_map;
+
+  BlockList                 _cached_blocks;     // cached list with all blocks in greedy order (only correct if original list keeps unchanged)
+  int                       _num_virtual_regs;  // number of virtual registers (without new registers introduced because of splitting intervals)
+  bool                      _has_fpu_registers; // true if this method uses any floating point registers (and so fpu stack allocation is necessary)
+  int                       _num_calls;         // total number of calls in this method
+  int                       _max_spills;        // number of stack slots used for intervals allocated to memory
+  int                       _unused_spill_slot; // unused spill slot for a single-word value because of alignment of a double-word value
+
+  GreedyIntervalList              _intervals;         // mapping from register number to interval
+  GreedyIntervalList*             _new_intervals_from_allocation; // list with all intervals created during allocation when an existing interval is split
+  GreedyIntervalArray*            _sorted_intervals;  // intervals sorted by GreedyInterval::from()
+  bool                      _needs_full_resort; // set to true if an GreedyInterval::from() is changed and _sorted_intervals must be resorted
+
+  LIR_OpArray               _lir_ops;           // mapping from LIR_Op id to LIR_Op node
+  BlockBeginArray           _block_of_op;       // mapping from LIR_Op id to the BlockBegin containing this instruction
+  BitMap                    _has_info;          // bit set for each LIR_Op id that has a CodeEmitInfo
+  BitMap                    _has_call;          // bit set for each LIR_Op id that destroys all caller save registers
+  BitMap2D                  _interval_in_loop;  // bit set for each virtual register that is contained in each loop
+
+  // cached debug info to prevent multiple creation of same object
+  // TODO: cached scope values for registers could be static
+  GreedyScopeValueArray           _scope_value_cache;
+
+  static ConstantOopWriteValue* _oop_null_scope_value;
+  static ConstantIntValue*    _int_m1_scope_value;
+  static ConstantIntValue*    _int_0_scope_value;
+  static ConstantIntValue*    _int_1_scope_value;
+  static ConstantIntValue*    _int_2_scope_value;
+
+  // accessors
+  IR*           ir() const                       { return _ir; }
+  Compilation*  compilation() const              { return _compilation; }
+  LIRGenerator* gen() const                      { return _gen; }
+  FrameMap*     frame_map() const                { return _frame_map; }
+
+  // unified bailout support
+  void          bailout(const char* msg) const   { compilation()->bailout(msg); }
+  bool          bailed_out() const               { return compilation()->bailed_out(); }
+
+  // access to block list (sorted in greedy order)
+  int           block_count() const              { assert(_cached_blocks.length() == ir()->greedy_order()->length(), "invalid cached block list"); return _cached_blocks.length(); }
+  BlockBegin*   block_at(int idx) const          { assert(_cached_blocks.at(idx) == ir()->greedy_order()->at(idx), "invalid cached block list");   return _cached_blocks.at(idx); }
+
+  int           num_virtual_regs() const         { return _num_virtual_regs; }
+  // size of live_in and live_out sets of BasicBlocks (BitMap needs rounded size for iteration)
+  int           live_set_size() const            { return round_to(_num_virtual_regs, BitsPerWord); }
+  bool          has_fpu_registers() const        { return _has_fpu_registers; }
+  int           num_loops() const                { return ir()->num_loops(); }
+  bool          is_interval_in_loop(int interval, int loop) const { return _interval_in_loop.at(interval, loop); }
+
+  // handling of fpu stack allocation (platform dependent, needed for debug information generation)
+#ifdef X86
+  GreedyFpuStackAllocator* _fpu_stack_allocator;
+  bool use_fpu_stack_allocation() const          { return UseSSE < 2 && has_fpu_registers(); }
+#else
+  bool use_fpu_stack_allocation() const          { return false; }
+#endif
+
+
+  // access to interval list
+  int           interval_count() const           { return _intervals.length(); }
+  GreedyInterval*     interval_at(int reg_num) const   { return _intervals.at(reg_num); }
+
+  GreedyIntervalList* new_intervals_from_allocation() const { return _new_intervals_from_allocation; }
+
+  // access to LIR_Ops and Blocks indexed by op_id
+  int          max_lir_op_id() const                { assert(_lir_ops.length() > 0, "no operations"); return (_lir_ops.length() - 1) << 1; }
+  LIR_Op*      lir_op_with_id(int op_id) const      { assert(op_id >= 0 && op_id <= max_lir_op_id() && op_id % 2 == 0, "op_id out of range or not even"); return _lir_ops.at(op_id >> 1); }
+  BlockBegin*  block_of_op_with_id(int op_id) const { assert(_block_of_op.length() > 0 && op_id >= 0 && op_id <= max_lir_op_id() + 1, "op_id out of range"); return _block_of_op.at(op_id >> 1); }
+
+  bool is_block_begin(int op_id)                    { return op_id == 0 || block_of_op_with_id(op_id) != block_of_op_with_id(op_id - 1); }
+  bool covers_block_begin(int op_id_1, int op_id_2) { return block_of_op_with_id(op_id_1) != block_of_op_with_id(op_id_2); }
+
+  bool has_call(int op_id)                          { assert(op_id % 2 == 0, "must be even"); return _has_call.at(op_id >> 1); }
+  bool has_info(int op_id)                          { assert(op_id % 2 == 0, "must be even"); return _has_info.at(op_id >> 1); }
+
+
+  // functions for converting LIR-Operands to register numbers
+  static bool is_valid_reg_num(int reg_num)         { return reg_num >= 0; }
+  static int  reg_num(LIR_Opr opr);
+  static int  reg_numHi(LIR_Opr opr);
+
+  // functions for classification of intervals
+  static bool is_precolored_interval(const GreedyInterval* i);
+  static bool is_virtual_interval(const GreedyInterval* i);
+
+  static bool is_precolored_cpu_interval(const GreedyInterval* i);
+  static bool is_virtual_cpu_interval(const GreedyInterval* i);
+  static bool is_precolored_fpu_interval(const GreedyInterval* i);
+  static bool is_virtual_fpu_interval(const GreedyInterval* i);
+
+  static bool is_in_fpu_register(const GreedyInterval* i);
+  static bool is_oop_interval(const GreedyInterval* i);
+
+
+  // General helper functions
+  int         allocate_spill_slot(bool double_word);
+  void        assign_spill_slot(GreedyInterval* it);
+  void        propagate_spill_slots();
+
+  GreedyInterval*   create_interval(int reg_num);
+  void        append_interval(GreedyInterval* it);
+  void        copy_register_flags(GreedyInterval* from, GreedyInterval* to);
+
+  // platform dependent functions
+  static bool is_processed_reg_num(int reg_num);
+  static int  num_physical_regs(BasicType type);
+  static bool requires_adjacent_regs(BasicType type);
+  static bool is_caller_save(int assigned_reg);
+
+  // spill move optimization: eliminate moves from register to stack if
+  // stack slot is known to be correct
+  void        change_spill_definition_pos(GreedyInterval* interval, int def_pos);
+  void        change_spill_state(GreedyInterval* interval, int spill_pos);
+  static bool must_store_at_definition(const GreedyInterval* i);
+  void        eliminate_spill_moves();
+
+  // Phase 1: number all instructions in all blocks
+  void number_instructions();
+
+  // Phase 2: compute local live sets separately for each block
+  // (sets live_gen and live_kill for each block)
+  //
+  // helper methods used by compute_local_live_sets()
+  void set_live_gen_kill(Value value, LIR_Op* op, BitMap& live_gen, BitMap& live_kill);
+
+  void compute_local_live_sets();
+
+  // Phase 3: perform a backward dataflow analysis to compute global live sets
+  // (sets live_in and live_out for each block)
+  void compute_global_live_sets();
+
+
+  // Phase 4: build intervals
+  // (fills the list _intervals)
+  //
+  // helper methods used by build_intervals()
+  void add_use (Value value, int from, int to, GreedyIntervalUseKind use_kind);
+
+  void add_def (LIR_Opr opr, int def_pos,      GreedyIntervalUseKind use_kind);
+  void add_use (LIR_Opr opr, int from, int to, GreedyIntervalUseKind use_kind);
+  void add_temp(LIR_Opr opr, int temp_pos,     GreedyIntervalUseKind use_kind);
+
+  void add_def (int reg_num, int def_pos,      GreedyIntervalUseKind use_kind, BasicType type);
+  void add_use (int reg_num, int from, int to, GreedyIntervalUseKind use_kind, BasicType type);
+  void add_temp(int reg_num, int temp_pos,     GreedyIntervalUseKind use_kind, BasicType type);
+
+  // Add platform dependent kills for particular LIR ops.  Can be used
+  // to add platform dependent behaviour for some operations.
+  void pd_add_temps(LIR_Op* op);
+
+  GreedyIntervalUseKind use_kind_of_output_operand(LIR_Op* op, LIR_Opr opr);
+  GreedyIntervalUseKind use_kind_of_input_operand(LIR_Op* op, LIR_Opr opr);
+  void handle_method_arguments(LIR_Op* op);
+  void handle_doubleword_moves(LIR_Op* op);
+  void add_register_hints(LIR_Op* op);
+
+  void build_intervals();
+
+
+  // Phase 5: actual register allocation
+  // (Uses GreedyWalker)
+  //
+  // helper functions for building a sorted list of intervals
+  NOT_PRODUCT(bool is_sorted(GreedyIntervalArray* intervals);)
+  static int interval_cmp(GreedyInterval** a, GreedyInterval** b);
+  void add_to_list(GreedyInterval** first, GreedyInterval** prev, GreedyInterval* interval);
+  void create_unhandled_lists(GreedyInterval** list1, GreedyInterval** list2, bool (is_list1)(const GreedyInterval* i), bool (is_list2)(const GreedyInterval* i));
+
+  void sort_intervals_before_allocation();
+  void sort_intervals_after_allocation();
+  void allocate_registers();
+
+
+  // Phase 6: resolve data flow
+  // (insert moves at edges between blocks if intervals have been split)
+  //
+  // helper functions for resolve_data_flow()
+  GreedyInterval* split_child_at_op_id(GreedyInterval* interval, int op_id, LIR_OpVisitState::OprMode mode);
+  GreedyInterval* interval_at_block_begin(BlockBegin* block, int reg_num);
+  GreedyInterval* interval_at_block_end(BlockBegin* block, int reg_num);
+  GreedyInterval* interval_at_op_id(int reg_num, int op_id);
+  void resolve_collect_mappings(BlockBegin* from_block, BlockBegin* to_block, GreedyMoveResolver &move_resolver);
+  void resolve_find_insert_pos(BlockBegin* from_block, BlockBegin* to_block, GreedyMoveResolver &move_resolver);
+  void resolve_data_flow();
+
+  void resolve_exception_entry(BlockBegin* block, int reg_num, GreedyMoveResolver &move_resolver);
+  void resolve_exception_entry(BlockBegin* block, GreedyMoveResolver &move_resolver);
+  void resolve_exception_edge(XHandler* handler, int throwing_op_id, int reg_num, Phi* phi, GreedyMoveResolver &move_resolver);
+  void resolve_exception_edge(XHandler* handler, int throwing_op_id, GreedyMoveResolver &move_resolver);
+  void resolve_exception_handlers();
+
+  // Phase 7: assign register numbers back to LIR
+  // (includes computation of debug information and oop maps)
+  //
+  // helper functions for assign_reg_num()
+  VMReg vm_reg_for_interval(GreedyInterval* interval);
+  VMReg vm_reg_for_operand(LIR_Opr opr);
+
+  static LIR_Opr operand_for_interval(GreedyInterval* interval);
+  static LIR_Opr calc_operand_for_interval(const GreedyInterval* interval);
+  LIR_Opr       canonical_spill_opr(GreedyInterval* interval);
+
+  LIR_Opr color_lir_opr(LIR_Opr opr, int id, LIR_OpVisitState::OprMode);
+
+  // methods used for oop map computation
+  GreedyIntervalWalker* init_compute_oop_maps();
+  OopMap*         compute_oop_map(GreedyIntervalWalker* iw, LIR_Op* op, CodeEmitInfo* info, bool is_call_site);
+  void            compute_oop_map(GreedyIntervalWalker* iw, const LIR_OpVisitState &visitor, LIR_Op* op);
+
+  // methods used for debug information computation
+  void init_compute_debug_info();
+
+  MonitorValue*  location_for_monitor_index(int monitor_index);
+  LocationValue* location_for_name(int name, Location::Type loc_type);
+  void set_oop(OopMap* map, VMReg name) {
+    if (map->legal_vm_reg_name(name)) {
+      map->set_oop(name);
+    } else {
+      bailout("illegal oopMap register name");
+    }
+  }
+
+  int append_scope_value_for_constant(LIR_Opr opr, GrowableArray<ScopeValue*>* scope_values);
+  int append_scope_value_for_operand(LIR_Opr opr, GrowableArray<ScopeValue*>* scope_values);
+  int append_scope_value(int op_id, Value value, GrowableArray<ScopeValue*>* scope_values);
+
+  IRScopeDebugInfo* compute_debug_info_for_scope(int op_id, IRScope* cur_scope, ValueStack* cur_state, ValueStack* innermost_state);
+  void compute_debug_info(CodeEmitInfo* info, int op_id);
+
+  void assign_reg_num(LIR_OpList* instructions, GreedyIntervalWalker* iw);
+  void assign_reg_num();
+
+
+  // Phase 8: fpu stack allocation
+  // (Used only on x86 when fpu operands are present)
+  void allocate_fpu_stack();
+
+
+  // helper functions for printing state
+#ifndef PRODUCT
+  static void print_bitmap(BitMap& bitmap);
+  void        print_intervals(const char* label);
+  void        print_lir(int level, const char* label, bool hir_valid = true);
+#endif
+
+#ifdef ASSERT
+  // verification functions for allocation
+  // (check that all intervals have a correct register and that no registers are overwritten)
+  void verify();
+  void verify_intervals();
+  void verify_no_oops_in_fixed_intervals();
+  void verify_constants();
+  void verify_registers();
+#endif
+
+ public:
+  // creation
+  Greedy(IR* ir, LIRGenerator* gen, FrameMap* frame_map);
+
+  // main entry function: perform greedy register allocation
+  void             do_greedy();
+
+  // accessors used by Compilation
+  int         max_spills()  const { return _max_spills; }
+  int         num_calls() const   { assert(_num_calls >= 0, "not set"); return _num_calls; }
+
+  // entry functions for printing
+#ifndef PRODUCT
+  static void print_statistics();
+  static void print_timers(double total);
+#endif
+};
+
+
+// Helper class for ordering moves that are inserted at the same position in the LIR
+// When moves between registers are inserted, it is important that the moves are
+// ordered such that no register is overwritten. So moves from register to stack
+// are processed prior to moves from stack to register. When moves have circular
+// dependencies, a temporary stack slot is used to break the circle.
+// The same logic is used in the GreedyWalker and in Greedy during resolve_data_flow
+// and therefore factored out in a separate class
+class GreedyMoveResolver: public StackObj {
+ private:
+  Greedy*      _allocator;
+
+  LIR_List*        _insert_list;
+  int              _insert_idx;
+  LIR_InsertionBuffer _insertion_buffer; // buffer where moves are inserted
+
+  GreedyIntervalList     _mapping_from;
+  LIR_OprList      _mapping_from_opr;
+  GreedyIntervalList     _mapping_to;
+  bool             _multiple_reads_allowed;
+  int              _register_blocked[Greedy::nof_regs];
+
+  int  register_blocked(int reg)                    { assert(reg >= 0 && reg < Greedy::nof_regs, "out of bounds"); return _register_blocked[reg]; }
+  void set_register_blocked(int reg, int direction) { assert(reg >= 0 && reg < Greedy::nof_regs, "out of bounds"); assert(direction == 1 || direction == -1, "out of bounds"); _register_blocked[reg] += direction; }
+
+  void block_registers(GreedyInterval* it);
+  void unblock_registers(GreedyInterval* it);
+  bool save_to_process_move(GreedyInterval* from, GreedyInterval* to);
+
+  void create_insertion_buffer(LIR_List* list);
+  void append_insertion_buffer();
+  void insert_move(GreedyInterval* from_interval, GreedyInterval* to_interval);
+  void insert_move(LIR_Opr from_opr, GreedyInterval* to_interval);
+
+  DEBUG_ONLY(void verify_before_resolve();)
+  void resolve_mappings();
+ public:
+  GreedyMoveResolver(Greedy* allocator);
+
+  DEBUG_ONLY(void check_empty();)
+  void set_multiple_reads_allowed() { _multiple_reads_allowed = true; }
+  void set_insert_position(LIR_List* insert_list, int insert_idx);
+  void move_insert_position(LIR_List* insert_list, int insert_idx);
+  void add_mapping(GreedyInterval* from, GreedyInterval* to);
+  void add_mapping(LIR_Opr from, GreedyInterval* to);
+  void resolve_and_append_moves();
+
+  Greedy* allocator()   { return _allocator; }
+  bool has_mappings()       { return _mapping_from.length() > 0; }
+};
+
+
+class GreedyRange : public CompilationResourceObj {
+  friend class GreedyInterval;
+
+ private:
+  static GreedyRange*    _end;       // sentinel (from == to == max_jint)
+
+  int              _from;      // from (inclusive)
+  int              _to;        // to (exclusive)
+  GreedyRange*           _next;      // greedy list of GreedyRanges
+
+  // used only by class GreedyInterval, so hide them
+  bool             intersects(GreedyRange* r) const    { return intersects_at(r) != -1; }
+  int              intersects_at(GreedyRange* r) const;
+
+ public:
+  GreedyRange(int from, int to, GreedyRange* next);
+
+  static void      initialize(Arena* arena);
+  static GreedyRange*    end()                         { return _end; }
+
+  int              from() const                  { return _from; }
+  int              to()   const                  { return _to; }
+  GreedyRange*           next() const                  { return _next; }
+  void             set_from(int from)            { _from = from; }
+  void             set_to(int to)                { _to = to; }
+  void             set_next(GreedyRange* next)         { _next = next; }
+
+  // for testing
+  void             print(outputStream* out = tty) const PRODUCT_RETURN;
+};
+
+
+// GreedyInterval is an ordered list of disjoint ranges.
+
+// For pre-colored double word LIR_Oprs, one interval is created for
+// the low word register and one is created for the hi word register.
+// On Intel for FPU double registers only one interval is created.  At
+// all times assigned_reg contains the reg. number of the physical
+// register.
+
+// For LIR_Opr in virtual registers a single interval can represent
+// single and double word values.  When a physical register is
+// assigned to the interval, assigned_reg contains the
+// phys. reg. number and for double word values assigned_regHi the
+// phys. reg. number of the hi word if there is any.  For spilled
+// intervals assigned_reg contains the stack index.  assigned_regHi is
+// always -1.
+
+class GreedyInterval : public CompilationResourceObj {
+ private:
+  static GreedyInterval* _end;          // sentinel (interval with only range GreedyRange::end())
+
+  int              _reg_num;
+  BasicType        _type;         // valid only for virtual registers
+  GreedyRange*           _first;        // sorted list of GreedyRanges
+  intStack         _use_pos_and_kinds; // sorted list of use-positions and their according use-kinds
+
+  GreedyRange*           _current;      // interval iteration: the current GreedyRange
+  GreedyInterval*        _next;         // interval iteration: sorted list of GreedyIntervals (ends with sentinel)
+  GreedyIntervalState    _state;        // interval iteration: to which set belongs this interval
+
+
+  int              _assigned_reg;
+  int              _assigned_regHi;
+
+  int              _cached_to;    // cached value: to of last range (-1: not cached)
+  LIR_Opr          _cached_opr;
+  VMReg            _cached_vm_reg;
+
+  GreedyInterval*        _split_parent;           // the original interval where this interval is derived from
+  GreedyIntervalList     _split_children;         // list of all intervals that are split off from this interval (only available for split parents)
+  GreedyInterval*        _current_split_child;    // the current split child that has been active or inactive last (always stored in split parents)
+
+  int              _canonical_spill_slot;   // the stack slot where all split parts of this interval are spilled to (always stored in split parents)
+  bool             _insert_move_when_activated; // true if move is inserted between _current_split_child and this interval when interval gets active the first time
+  GreedyIntervalSpillState _spill_state;          // for spill move optimization
+  int              _spill_definition_pos;   // position where the interval is defined (if defined only once)
+  GreedyInterval*        _register_hint;          // this interval should be in the same register as the hint interval
+
+  int              calc_to();
+  GreedyInterval*        new_split_child();
+ public:
+  GreedyInterval(int reg_num);
+
+  static void      initialize(Arena* arena);
+  static GreedyInterval* end()                         { return _end; }
+
+  // accessors
+  int              reg_num() const               { return _reg_num; }
+  void             set_reg_num(int r)            { assert(_reg_num == -1, "cannot change reg_num"); _reg_num = r; }
+  BasicType        type() const                  { assert(_reg_num == -1 || _reg_num >= LIR_OprDesc::vreg_base, "cannot access type for fixed interval"); return _type; }
+  void             set_type(BasicType type)      { assert(_reg_num < LIR_OprDesc::vreg_base || _type == T_ILLEGAL || _type == type, "overwriting existing type"); _type = type; }
+
+  GreedyRange*           first() const                 { return _first; }
+  int              from() const                  { return _first->from(); }
+  int              to()                          { if (_cached_to == -1) _cached_to = calc_to(); assert(_cached_to == calc_to(), "invalid cached value"); return _cached_to; }
+  int              num_use_positions() const     { return _use_pos_and_kinds.length() / 2; }
+
+  GreedyInterval*        next() const                  { return _next; }
+  GreedyInterval**       next_addr()                   { return &_next; }
+  void             set_next(GreedyInterval* next)      { _next = next; }
+
+  int              assigned_reg() const          { return _assigned_reg; }
+  int              assigned_regHi() const        { return _assigned_regHi; }
+  void             assign_reg(int reg)           { _assigned_reg = reg; _assigned_regHi = Greedy::any_reg; }
+  void             assign_reg(int reg,int regHi) { _assigned_reg = reg; _assigned_regHi = regHi; }
+
+  GreedyInterval*        register_hint(bool search_split_child = true) const; // calculation needed
+  void             set_register_hint(GreedyInterval* i) { _register_hint = i; }
+
+  int              state() const                 { return _state; }
+  void             set_state(GreedyIntervalState s)    { _state = s; }
+
+  // access to split parent and split children
+  bool             is_split_parent() const       { return _split_parent == this; }
+  bool             is_split_child() const        { return _split_parent != this; }
+  GreedyInterval*        split_parent() const          { assert(_split_parent->is_split_parent(), "must be"); return _split_parent; }
+  GreedyInterval*        split_child_at_op_id(int op_id, LIR_OpVisitState::OprMode mode);
+  GreedyInterval*        split_child_before_op_id(int op_id);
+  bool             split_child_covers(int op_id, LIR_OpVisitState::OprMode mode);
+  DEBUG_ONLY(void  check_split_children();)
+
+  // information stored in split parent, but available for all children
+  int              canonical_spill_slot() const            { return split_parent()->_canonical_spill_slot; }
+  void             set_canonical_spill_slot(int slot)      { assert(split_parent()->_canonical_spill_slot == -1, "overwriting existing value"); split_parent()->_canonical_spill_slot = slot; }
+  GreedyInterval*        current_split_child() const             { return split_parent()->_current_split_child; }
+  void             make_current_split_child()              { split_parent()->_current_split_child = this; }
+
+  bool             insert_move_when_activated() const      { return _insert_move_when_activated; }
+  void             set_insert_move_when_activated(bool b)  { _insert_move_when_activated = b; }
+
+  // for spill optimization
+  GreedyIntervalSpillState spill_state() const         { return split_parent()->_spill_state; }
+  int              spill_definition_pos() const  { return split_parent()->_spill_definition_pos; }
+  void             set_spill_state(GreedyIntervalSpillState state) {  assert(state >= spill_state(), "state cannot decrease"); split_parent()->_spill_state = state; }
+  void             set_spill_definition_pos(int pos) { assert(spill_definition_pos() == -1, "cannot set the position twice"); split_parent()->_spill_definition_pos = pos; }
+  // returns true if this interval has a shadow copy on the stack that is always correct
+  bool             always_in_memory() const      { return split_parent()->_spill_state == storeAtDefinition || split_parent()->_spill_state == startInMemory; }
+
+  // caching of values that take time to compute and are used multiple times
+  LIR_Opr          cached_opr() const            { return _cached_opr; }
+  VMReg            cached_vm_reg() const         { return _cached_vm_reg; }
+  void             set_cached_opr(LIR_Opr opr)   { _cached_opr = opr; }
+  void             set_cached_vm_reg(VMReg reg)  { _cached_vm_reg = reg; }
+
+  // access to use positions
+  int    first_usage(GreedyIntervalUseKind min_use_kind) const;           // id of the first operation requiring this interval in a register
+  int    next_usage(GreedyIntervalUseKind min_use_kind, int from) const;  // id of next usage seen from the given position
+  int    next_usage_exact(GreedyIntervalUseKind exact_use_kind, int from) const;
+  int    previous_usage(GreedyIntervalUseKind min_use_kind, int from) const;
+
+  // manipulating intervals
+  void   add_use_pos(int pos, GreedyIntervalUseKind use_kind);
+  void   add_range(int from, int to);
+  GreedyInterval* split(int split_pos);
+  GreedyInterval* split_from_start(int split_pos);
+  void remove_first_use_pos()                    { _use_pos_and_kinds.truncate(_use_pos_and_kinds.length() - 2); }
+
+  // test intersection
+  bool   covers(int op_id, LIR_OpVisitState::OprMode mode) const;
+  bool   has_hole_between(int from, int to);
+  bool   intersects(GreedyInterval* i) const           { return _first->intersects(i->_first); }
+  int    intersects_at(GreedyInterval* i) const        { return _first->intersects_at(i->_first); }
+
+  // range iteration
+  void   rewind_range()                          { _current = _first; }
+  void   next_range()                            { assert(this != _end, "not allowed on sentinel"); _current = _current->next(); }
+  int    current_from() const                    { return _current->from(); }
+  int    current_to() const                      { return _current->to(); }
+  bool   current_at_end() const                  { return _current == GreedyRange::end(); }
+  bool   current_intersects(GreedyInterval* it)        { return _current->intersects(it->_current); };
+  int    current_intersects_at(GreedyInterval* it)     { return _current->intersects_at(it->_current); };
+
+  // printing
+  void print(outputStream* out = tty) const      PRODUCT_RETURN;
+};
+
+
+class GreedyIntervalWalker : public CompilationResourceObj {
+ protected:
+  Compilation*     _compilation;
+  Greedy*      _allocator;
+
+  GreedyInterval*        _unhandled_first[nofKinds];  // sorted list of intervals, not life before the current position
+  GreedyInterval*        _active_first   [nofKinds];  // sorted list of intervals, life at the current position
+  GreedyInterval*        _inactive_first [nofKinds];  // sorted list of intervals, intervals in a life time hole at the current position
+
+  GreedyInterval*        _current;                     // the current interval coming from unhandled list
+  int              _current_position;            // the current position (intercept point through the intervals)
+  GreedyIntervalKind     _current_kind;                // and whether it is fixed_kind or any_kind.
+
+
+  Compilation*     compilation() const               { return _compilation; }
+  Greedy*      allocator() const                 { return _allocator; }
+
+  // unified bailout support
+  void             bailout(const char* msg) const    { compilation()->bailout(msg); }
+  bool             bailed_out() const                { return compilation()->bailed_out(); }
+
+  void check_bounds(GreedyIntervalKind kind) { assert(kind >= fixedKind && kind <= anyKind, "invalid interval_kind"); }
+
+  GreedyInterval** unhandled_first_addr(GreedyIntervalKind kind) { check_bounds(kind); return &_unhandled_first[kind]; }
+  GreedyInterval** active_first_addr(GreedyIntervalKind kind)    { check_bounds(kind); return &_active_first[kind]; }
+  GreedyInterval** inactive_first_addr(GreedyIntervalKind kind)  { check_bounds(kind); return &_inactive_first[kind]; }
+
+  void append_unsorted(GreedyInterval** first, GreedyInterval* interval);
+  void append_sorted(GreedyInterval** first, GreedyInterval* interval);
+  void append_to_unhandled(GreedyInterval** list, GreedyInterval* interval);
+
+  bool remove_from_list(GreedyInterval** list, GreedyInterval* i);
+  void remove_from_list(GreedyInterval* i);
+
+  void next_interval();
+  GreedyInterval*        current() const               { return _current; }
+  GreedyIntervalKind     current_kind() const          { return _current_kind; }
+
+  void walk_to(GreedyIntervalState state, int from);
+
+  // activate_current() is called when an unhandled interval becomes active (in current(), current_kind()).
+  // Return false if current() should not be moved the the active interval list.
+  // It is safe to append current to any interval list but the unhandled list.
+  virtual bool activate_current() { return true; }
+
+  // interval_moved() is called whenever an interval moves from one interval list to another.
+  // In the implementation of this method it is prohibited to move the interval to any list.
+  virtual void interval_moved(GreedyInterval* interval, GreedyIntervalKind kind, GreedyIntervalState from, GreedyIntervalState to);
+
+ public:
+  GreedyIntervalWalker(Greedy* allocator, GreedyInterval* unhandled_fixed_first, GreedyInterval* unhandled_any_first);
+
+  GreedyInterval* unhandled_first(GreedyIntervalKind kind)   { check_bounds(kind); return _unhandled_first[kind]; }
+  GreedyInterval* active_first(GreedyIntervalKind kind)      { check_bounds(kind); return _active_first[kind]; }
+  GreedyInterval* inactive_first(GreedyIntervalKind kind)    { check_bounds(kind); return _inactive_first[kind]; }
+
+  // active contains the intervals that are live after the lir_op
+  void walk_to(int lir_op_id);
+  // active contains the intervals that are live before the lir_op
+  void walk_before(int lir_op_id)  { walk_to(lir_op_id-1); }
+  // walk through all intervals
+  void walk()                      { walk_to(max_jint); }
+
+  int current_position()           { return _current_position; }
+};
+
+
+// The actual greedy register allocator
+class GreedyWalker : public GreedyIntervalWalker {
+  enum {
+    any_reg = Greedy::any_reg
+  };
+
+ private:
+  int              _first_reg;       // the reg. number of the first phys. register
+  int              _last_reg;        // the reg. nmber of the last phys. register
+  int              _num_phys_regs;   // required by current interval
+  bool             _adjacent_regs;   // have lo/hi words of phys. regs be adjacent
+
+  int              _use_pos[Greedy::nof_regs];
+  int              _block_pos[Greedy::nof_regs];
+  GreedyIntervalList*    _spill_intervals[Greedy::nof_regs];
+
+  GreedyMoveResolver     _move_resolver;   // for ordering spill moves
+
+  // accessors mapped to same functions in class Greedy
+  int         block_count() const      { return allocator()->block_count(); }
+  BlockBegin* block_at(int idx) const  { return allocator()->block_at(idx); }
+  BlockBegin* block_of_op_with_id(int op_id) const { return allocator()->block_of_op_with_id(op_id); }
+
+  void init_use_lists(bool only_process_use_pos);
+  void exclude_from_use(int reg);
+  void exclude_from_use(GreedyInterval* i);
+  void set_use_pos(int reg, GreedyInterval* i, int use_pos, bool only_process_use_pos);
+  void set_use_pos(GreedyInterval* i, int use_pos, bool only_process_use_pos);
+  void set_block_pos(int reg, GreedyInterval* i, int block_pos);
+  void set_block_pos(GreedyInterval* i, int block_pos);
+
+  void free_exclude_active_fixed();
+  void free_exclude_active_any();
+  void free_collect_inactive_fixed(GreedyInterval* cur);
+  void free_collect_inactive_any(GreedyInterval* cur);
+  void free_collect_unhandled(GreedyIntervalKind kind, GreedyInterval* cur);
+  void spill_exclude_active_fixed();
+  void spill_block_unhandled_fixed(GreedyInterval* cur);
+  void spill_block_inactive_fixed(GreedyInterval* cur);
+  void spill_collect_active_any();
+  void spill_collect_inactive_any(GreedyInterval* cur);
+
+  void insert_move(int op_id, GreedyInterval* src_it, GreedyInterval* dst_it);
+  int  find_optimal_split_pos(BlockBegin* min_block, BlockBegin* max_block, int max_split_pos);
+  int  find_optimal_split_pos(GreedyInterval* it, int min_split_pos, int max_split_pos, bool do_loop_optimization);
+  void split_before_usage(GreedyInterval* it, int min_split_pos, int max_split_pos);
+  void split_for_spilling(GreedyInterval* it);
+  void split_stack_interval(GreedyInterval* it);
+  void split_when_partial_register_available(GreedyInterval* it, int register_available_until);
+  void split_and_spill_interval(GreedyInterval* it);
+
+  int  find_free_reg(int reg_needed_until, int interval_to, int hint_reg, int ignore_reg, bool* need_split);
+  int  find_free_double_reg(int reg_needed_until, int interval_to, int hint_reg, bool* need_split);
+  bool alloc_free_reg(GreedyInterval* cur);
+
+  int  find_locked_reg(int reg_needed_until, int interval_to, int hint_reg, int ignore_reg, bool* need_split);
+  int  find_locked_double_reg(int reg_needed_until, int interval_to, int hint_reg, bool* need_split);
+  void split_and_spill_intersecting_intervals(int reg, int regHi);
+  void alloc_locked_reg(GreedyInterval* cur);
+
+  bool no_allocation_possible(GreedyInterval* cur);
+  void update_phys_reg_range(bool requires_cpu_register);
+  void init_vars_for_alloc(GreedyInterval* cur);
+  bool pd_init_regs_for_alloc(GreedyInterval* cur);
+
+  void combine_spilled_intervals(GreedyInterval* cur);
+  bool is_move(LIR_Op* op, GreedyInterval* from, GreedyInterval* to);
+
+  bool activate_current();
+
+ public:
+  GreedyWalker(Greedy* allocator, GreedyInterval* unhandled_fixed_first, GreedyInterval* unhandled_any_first);
+
+  // must be called when all intervals are allocated
+  void             finish_allocation()           { _move_resolver.resolve_and_append_moves(); }
+};
+
+
+
+/*
+When a block has more than one predecessor, and all predecessors end with
+the same sequence of move-instructions, than this moves can be placed once
+at the beginning of the block instead of multiple times in the predecessors.
+
+Similarly, when a block has more than one successor, then equal sequences of
+moves at the beginning of the successors can be placed once at the end of
+the block. But because the moves must be inserted before all branch
+instructions, this works only when there is exactly one conditional branch
+at the end of the block (because the moves must be inserted before all
+branches, but after all compares).
+
+This optimization affects all kind of moves (reg->reg, reg->stack and
+stack->reg). Because this optimization works best when a block contains only
+few moves, it has a huge impact on the number of blocks that are totally
+empty.
+*/
+class GreedyEdgeMoveOptimizer : public StackObj {
+ private:
+  // the class maintains a list with all lir-instruction-list of the
+  // successors (predecessors) and the current index into the lir-lists
+  GreedyLIR_OpListStack _edge_instructions;
+  intStack        _edge_instructions_idx;
+
+  void init_instructions();
+  void append_instructions(LIR_OpList* instructions, int instructions_idx);
+  LIR_Op* instruction_at(int edge);
+  void remove_cur_instruction(int edge, bool decrement_index);
+
+  bool operations_different(LIR_Op* op1, LIR_Op* op2);
+
+  void optimize_moves_at_block_end(BlockBegin* cur);
+  void optimize_moves_at_block_begin(BlockBegin* cur);
+
+  GreedyEdgeMoveOptimizer();
+
+ public:
+  static void optimize(BlockList* code);
+};
+
+
+
+class GreedyControlFlowOptimizer : public StackObj {
+ private:
+  BlockList _original_preds;
+
+  enum {
+    ShortLoopSize = 5
+  };
+  void reorder_short_loop(BlockList* code, BlockBegin* header_block, int header_idx);
+  void reorder_short_loops(BlockList* code);
+
+  bool can_delete_block(BlockBegin* cur);
+  void substitute_branch_target(BlockBegin* cur, BlockBegin* target_from, BlockBegin* target_to);
+  void delete_empty_blocks(BlockList* code);
+
+  void delete_unnecessary_jumps(BlockList* code);
+  void delete_jumps_to_return(BlockList* code);
+
+  DEBUG_ONLY(void verify(BlockList* code);)
+
+  GreedyControlFlowOptimizer();
+ public:
+  static void optimize(BlockList* code);
+};
+
+
+#ifndef PRODUCT
+
+// Helper class for collecting statistics of Greedy
+class GreedyStatistic : public StackObj {
+ public:
+  enum Counter {
+    // general counters
+    counter_method,
+    counter_fpu_method,
+    counter_loop_method,
+    counter_exception_method,
+    counter_loop,
+    counter_block,
+    counter_loop_block,
+    counter_exception_block,
+    counter_interval,
+    counter_fixed_interval,
+    counter_range,
+    counter_fixed_range,
+    counter_use_pos,
+    counter_fixed_use_pos,
+    counter_spill_slots,
+    blank_line_1,
+
+    // counter for classes of lir instructions
+    counter_instruction,
+    counter_label,
+    counter_entry,
+    counter_return,
+    counter_call,
+    counter_move,
+    counter_cmp,
+    counter_cond_branch,
+    counter_uncond_branch,
+    counter_stub_branch,
+    counter_alu,
+    counter_alloc,
+    counter_sync,
+    counter_throw,
+    counter_unwind,
+    counter_typecheck,
+    counter_fpu_stack,
+    counter_misc_inst,
+    counter_other_inst,
+    blank_line_2,
+
+    // counter for different types of moves
+    counter_move_total,
+    counter_move_reg_reg,
+    counter_move_reg_stack,
+    counter_move_stack_reg,
+    counter_move_stack_stack,
+    counter_move_reg_mem,
+    counter_move_mem_reg,
+    counter_move_const_any,
+
+    number_of_counters,
+    invalid_counter = -1
+  };
+
+ private:
+  int _counters_sum[number_of_counters];
+  int _counters_max[number_of_counters];
+
+  void inc_counter(Counter idx, int value = 1) { _counters_sum[idx] += value; }
+
+  const char* counter_name(int counter_idx);
+  Counter base_counter(int counter_idx);
+
+  void sum_up(GreedyStatistic &method_statistic);
+  void collect(Greedy* allocator);
+
+ public:
+  GreedyStatistic();
+  void print(const char* title);
+  static void compute(Greedy* allocator, GreedyStatistic &global_statistic);
+};
+
+
+// Helper class for collecting compilation time of Greedy
+class GreedyTimers : public StackObj {
+ public:
+  enum Timer {
+    timer_do_nothing,
+    timer_number_instructions,
+    timer_compute_local_live_sets,
+    timer_compute_global_live_sets,
+    timer_build_intervals,
+    timer_sort_intervals_before,
+    timer_allocate_registers,
+    timer_resolve_data_flow,
+    timer_sort_intervals_after,
+    timer_eliminate_spill_moves,
+    timer_assign_reg_num,
+    timer_allocate_fpu_stack,
+    timer_optimize_lir,
+
+    number_of_timers
+  };
+
+ private:
+  elapsedTimer _timers[number_of_timers];
+  const char*  timer_name(int idx);
+
+ public:
+  GreedyTimers();
+
+  void begin_method();                     // called for each method when register allocation starts
+  void end_method(Greedy* allocator);  // called for each method when register allocation completed
+  void print(double total_time);           // called before termination of VM to print global summary
+
+  elapsedTimer* timer(int idx) { return &(_timers[idx]); }
+};
+
+
+#endif // ifndef PRODUCT
+
+
+// Pick up platform-dependent implementation details
+#ifdef TARGET_ARCH_x86
+# include "c1_Greedy_x86.hpp"
+#endif
+#ifdef TARGET_ARCH_sparc
+# include "c1_Greedy_sparc.hpp"
+#endif
+#ifdef TARGET_ARCH_arm
+# include "c1_Greedy_arm.hpp"
+#endif
+#ifdef TARGET_ARCH_ppc
+# include "c1_Greedy_ppc.hpp"
+#endif
+
+
+#endif // SHARE_VM_C1_C1_GREEDY_HPP
diff -r 555c45b3456e src/share/vm/c1/c1_IR.hpp
--- a/src/share/vm/c1/c1_IR.hpp	Sat Mar 24 11:03:39 2018 +0800
+++ b/src/share/vm/c1/c1_IR.hpp	Sat Mar 24 11:04:51 2018 +0800
@@ -247,6 +247,7 @@
 
 class CodeEmitInfo: public CompilationResourceObj {
   friend class LinearScan;
+  friend class Greedy;
  private:
   IRScopeDebugInfo* _scope_debug_info;
   IRScope*          _scope;
@@ -323,11 +324,14 @@
   // The linear-scan order and the code emission order are equal, but
   // this may change in future
   BlockList* linear_scan_order() {  assert(_code != NULL, "not computed"); return _code; }
+  // The greedy order
+  BlockList* greedy_order() { assert(_code != NULL, "not computed"); return _code; }
 
   // iteration
   void iterate_preorder   (BlockClosure* closure);
   void iterate_postorder  (BlockClosure* closure);
   void iterate_linear_scan_order(BlockClosure* closure);
+  void iterate_greedy_order(BlockClosure* closure);
 
   // debugging
   static void print(BlockBegin* start, bool cfg_only, bool live_only = false) PRODUCT_RETURN;
diff -r 555c45b3456e src/share/vm/c1/c1_Instruction.hpp
--- a/src/share/vm/c1/c1_Instruction.hpp	Sat Mar 24 11:03:39 2018 +0800
+++ b/src/share/vm/c1/c1_Instruction.hpp	Sat Mar 24 11:04:51 2018 +0800
@@ -1607,6 +1607,7 @@
   int        _bci;                               // start-bci of block
   int        _depth_first_number;                // number of this block in a depth-first ordering
   int        _linear_scan_number;                // number of this block in linear-scan ordering
+  int        _greedy_number;                     // number of this block in greedy ordering
   int        _dominator_depth;
   int        _loop_depth;                        // the loop nesting level of this block
   int        _loop_index;                        // number of the innermost loop of this block
@@ -1666,6 +1667,7 @@
   , _bci(bci)
   , _depth_first_number(-1)
   , _linear_scan_number(-1)
+  , _greedy_number(-1)
   , _loop_depth(0)
   , _flags(0)
   , _dominator_depth(-1)
@@ -1706,6 +1708,7 @@
   int dominator_depth() const                    { return _dominator_depth; }
   int depth_first_number() const                 { return _depth_first_number; }
   int linear_scan_number() const                 { return _linear_scan_number; }
+  int greedy_number() const                      { return _greedy_number; }
   BlockEnd* end() const                          { return _end; }
   Label* label()                                 { return &_label; }
   LIR_List* lir() const                          { return _lir; }
@@ -1727,6 +1730,7 @@
   void set_dominator_depth(int d)                { _dominator_depth = d; }
   void set_depth_first_number(int dfn)           { _depth_first_number = dfn; }
   void set_linear_scan_number(int lsn)           { _linear_scan_number = lsn; }
+  void set_greedy_number(int gn)                 { _greedy_number = gn; }
   void set_end(BlockEnd* end);
   void clear_end();
   void disconnect_from_graph();
@@ -1787,7 +1791,9 @@
     critical_edge_split_flag      = 1 << 8, // set for all blocks that are introduced when critical edges are split
     linear_scan_loop_header_flag  = 1 << 9, // set during loop-detection for LinearScan
     linear_scan_loop_end_flag     = 1 << 10, // set during loop-detection for LinearScan
-    donot_eliminate_range_checks  = 1 << 11  // Should be try to eliminate range checks in this block
+    donot_eliminate_range_checks  = 1 << 11,  // Should be try to eliminate range checks in this block
+    greedy_loop_header_flag       = 1 << 12, // set during loop-detection for Greedy
+    greedy_loop_end_flag          = 1 << 13  // set during loop-detection for Greedy
   };
 
   void set(Flag f)                               { _flags |= f; }
diff -r 555c45b3456e src/share/vm/c1/c1_globals.hpp
--- a/src/share/vm/c1/c1_globals.hpp	Sat Mar 24 11:03:39 2018 +0800
+++ b/src/share/vm/c1/c1_globals.hpp	Sat Mar 24 11:04:51 2018 +0800
@@ -227,6 +227,21 @@
                                                                             \
   develop(bool, CountLinearScan, false,                                     \
           "collect statistic counters during LinearScan")                   \
+	                                                                    \
+  develop(intx, TraceGreedyLevel, 0,                                        \
+          "Debug levels for the greedy allocator")                          \
+                                                                            \
+  develop(bool, StressGreedy, false,                                        \
+          "scramble block order used by Greedy (stress test)")              \
+                                                                            \
+  product(bool, TimeGreedy, false,                                          \
+          "detailed timing of Greedy phases")                               \
+                                                                            \
+  develop(bool, TimeEachGreedy, false,                                      \
+          "print detailed timing of each Greedy run")                       \
+                                                                            \
+  develop(bool, CountGreedy, false,                                         \
+          "collect statistic counters during Greedy")                       \
                                                                             \
   /* C1 variable */                                                         \
                                                                             \
